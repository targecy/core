import { GraphQLClient } from 'graphql-request';
import { GraphQLClientRequestHeaders } from 'graphql-request/build/cjs/types';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: any;
  DecimalNumber: any;
  DecimalNumberAsDiv: any;
  ISO8601Date: any;
  ISO8601DateTime: any;
};

/** Account */
export type Account = {
  __typename?: 'Account';
  /** Account ID */
  id: Scalars['String'];
  /** Account number, the equivalent of a human-friendly public key */
  num: Scalars['Int'];
  /** Realm number  */
  realmId: Scalars['Int'];
  /** Shard number */
  shardId: Scalars['Int'];
};

/** Solana Action */
export type Action = {
  __typename?: 'Action';
  name: Scalars['String'];
  type: Scalars['String'];
};

export type ActionEnum =
  /** Add Quantity */
  | 'addQuantity'
  /** Burn */
  | 'burn'
  /** Mint */
  | 'create'
  /** Fee */
  | 'fee'
  /** Mint */
  | 'localMint'
  /** Transaction */
  | 'transaction'
  /** Transfer */
  | 'transfer';

/** Select by action */
export type ActionSelector = {
  /** Action in the list */
  in?: InputMaybe<Array<ActionEnum>>;
  /** Action is */
  is?: InputMaybe<ActionEnum>;
  /** Action not */
  not?: InputMaybe<ActionEnum>;
  /** Action not in the list */
  notIn?: InputMaybe<Array<ActionEnum>>;
};

export type ActiveAddress =
  /** Address */
  | 'address';

export type ActiveAddressUniq =
  /** Address */
  | 'address';

/** ActivePeriod */
export type ActivePeriod = {
  __typename?: 'ActivePeriod';
  /** Billing day */
  billingDay: Scalars['Int'];
  /** Period ends at */
  ends: UtilitiesDate;
  /** Is blocked */
  isBlocked: Scalars['Boolean'];
  /** Is paid */
  isPaid: Scalars['Boolean'];
  /** Is points consumed */
  isPointsConsumed: Scalars['Boolean'];
  /** Is spent */
  isSpent: Scalars['Boolean'];
  /** Total available points */
  points: Scalars['BigInt'];
  /** Remaining points */
  pointsRemaining: Scalars['BigInt'];
  /** Period starts at */
  starts: UtilitiesDate;
};

/** Blockchain address */
export type Address = {
  __typename?: 'Address';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
};

/** Address selector */
export type AddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Address selector */
export type AddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
};

/** Address with statistics */
export type AddressStatDimension = {
  __typename?: 'AddressStatDimension';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']>;
  /** First active */
  firstActive?: Maybe<DateTime>;
  /** Inbound transactions */
  inboundTransactions?: Maybe<Scalars['Int']>;
  /** Inflows */
  inflows?: Maybe<Scalars['Float']>;
  /** Last active */
  lastActive?: Maybe<DateTime>;
  /** Outbound transactions */
  outboundTransactions?: Maybe<Scalars['Int']>;
  /** Outflows */
  outflows?: Maybe<Scalars['Float']>;
  /** Unique days with transfers */
  uniqueDaysWithTransfers?: Maybe<Scalars['Int']>;
  /** Unique receivers */
  uniqueReceivers?: Maybe<Scalars['Int']>;
  /** Unique senders */
  uniqueSenders?: Maybe<Scalars['Int']>;
};


/** Address with statistics */
export type AddressStatDimension_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Blockchain account with address and type */
export type AddressWithAccount = {
  __typename?: 'AddressWithAccount';
  /** Account ID */
  account: Scalars['String'];
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Account type */
  type: Scalars['String'];
};

/** Algorand Blockchain */
export type Algorand = {
  __typename?: 'Algorand';
  /** Basic information about address ( or smart contract ) */
  address: Array<AlgorandAddressInfo>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<AlgorandArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<AlgorandBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<AlgorandCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<AlgorandSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<AlgorandTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<AlgorandTransfers>>;
};


/** Algorand Blockchain */
export type Algorand_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Algorand Blockchain */
export type Algorand_ArgumentsArgs = {
  any?: InputMaybe<Array<AlgorandArgumentFilter>>;
  argindex?: InputMaybe<ArgumentIndexSelector>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  caller?: InputMaybe<Array<AddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  reference?: InputMaybe<Array<AddressSelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Algorand Blockchain */
export type Algorand_BlocksArgs = {
  any?: InputMaybe<Array<AlgorandBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  options?: InputMaybe<QueryOptions>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Algorand Blockchain */
export type Algorand_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Algorand Blockchain */
export type Algorand_SmartContractCallsArgs = {
  any?: InputMaybe<Array<AlgorandSmartContractCallFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};


/** Algorand Blockchain */
export type Algorand_TransactionsArgs = {
  any?: InputMaybe<Array<AlgorandTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  group?: InputMaybe<GroupSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txSubtype?: InputMaybe<TxSubtypeSelector>;
  txType?: InputMaybe<TxTypeSelector>;
};


/** Algorand Blockchain */
export type Algorand_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<AlgorandTransferFilter>>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<Array<AddressSelector>>;
  sender?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<AlgorandTransferTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};

/** Address detailed information for Algorand network */
export type AlgorandAddressInfo = {
  __typename?: 'AlgorandAddressInfo';
  /** Address */
  address?: Maybe<Address>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** Created Assets */
  createdAssets?: Maybe<Array<AlgorandCreatedAssets>>;
  /** Current pending rewards */
  pendingRewards?: Maybe<Scalars['Float']>;
  /** Current rewards */
  rewards?: Maybe<Scalars['Float']>;
  /** Current round */
  round?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Current status */
  status?: Maybe<Scalars['String']>;
  /** Total amount of created apps */
  totalCreatedApps?: Maybe<Scalars['Int']>;
  /** Total amount of created assets */
  totalCreatedAssets?: Maybe<Scalars['Int']>;
};


/** Address detailed information for Algorand network */
export type AlgorandAddressInfo_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type AlgorandAddressInfo_PendingRewardsArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type AlgorandAddressInfo_RewardsArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

export type AlgorandArgumentFilter = {
  argindex?: InputMaybe<ArgumentIndexSelector>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  caller?: InputMaybe<Array<AddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<AddressSelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls */
export type AlgorandArguments = {
  __typename?: 'AlgorandArguments';
  any?: Maybe<Scalars['String']>;
  /** Sequential index of value in array ( multi-dimensional) */
  argindex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash64?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<AlgorandTxType>;
  /** The Value of argument */
  value?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_AnyArgs = {
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_CountArgs = {
  argindex?: InputMaybe<ArgumentIndexSelector>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  caller?: InputMaybe<Array<AddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<AddressSelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_CountBigIntArgs = {
  argindex?: InputMaybe<ArgumentIndexSelector>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  caller?: InputMaybe<Array<AddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<AddressSelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_MaximumArgs = {
  get?: InputMaybe<AlgorandArgumentsMeasureable>;
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_MinimumArgs = {
  get?: InputMaybe<AlgorandArgumentsMeasureable>;
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_TransactionArgs = {
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_TxSenderArgs = {
  txSender?: InputMaybe<Array<AddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_TxTypeArgs = {
  txType?: InputMaybe<Array<AlgorandTxType>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArguments_ValueArgs = {
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

export type AlgorandArgumentsMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type AlgorandBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};

/** Blocks in Algorand blockchain */
export type AlgorandBlocks = {
  __typename?: 'AlgorandBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  currentProtocol?: Maybe<Scalars['String']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  frac: Scalars['BigInt'];
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  nextProtocol?: Maybe<Scalars['String']>;
  nextProtocolApprovals?: Maybe<Scalars['BigInt']>;
  nextProtocolSwitchOn?: Maybe<Scalars['BigInt']>;
  nextProtocolVoteBefore?: Maybe<Scalars['BigInt']>;
  /** Previous block hash */
  previousBlockHash: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Address>;
  rate?: Maybe<Scalars['Float']>;
  reward?: Maybe<Scalars['Float']>;
  seed?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  txnRoot: Scalars['String'];
  upgradeApprove?: Maybe<Scalars['Int']>;
  upgradePropose?: Maybe<Scalars['String']>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_AnyArgs = {
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<AlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<AlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_MaximumArgs = {
  get?: InputMaybe<AlgorandBlocksMeasureable>;
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_MinimumArgs = {
  get?: InputMaybe<AlgorandBlocksMeasureable>;
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_ProposerArgs = {
  proposer?: InputMaybe<Array<AddressSelector>>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_RateArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_RewardArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currentProtocol?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nextProtocol?: InputMaybe<StringIdSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};

export type AlgorandBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Block Reward */
  | 'block_reward'
  /** Date */
  | 'date'
  /** Next protocol approvals */
  | 'next_protocol_approvals'
  /** Block Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type AlgorandBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique proposer count */
  | 'proposers';

export type AlgorandCallsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

/** Coinpath */
export type AlgorandCoinpath = {
  __typename?: 'AlgorandCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type AlgorandCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type AlgorandCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type AlgorandCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type AlgorandCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Algorand created assets */
export type AlgorandCreatedAssets = {
  __typename?: 'AlgorandCreatedAssets';
  /** Creator */
  creator?: Maybe<Scalars['String']>;
  /** Decimals */
  decimals?: Maybe<Scalars['Int']>;
  /** Asset Index */
  index?: Maybe<Scalars['Int']>;
  /** Manager */
  manager?: Maybe<Scalars['String']>;
  /** Name */
  name?: Maybe<Scalars['String']>;
  /** Reserve */
  reserve?: Maybe<Scalars['String']>;
  /** symbol */
  symbol?: Maybe<Scalars['String']>;
  /** URL */
  url?: Maybe<Scalars['String']>;
};

/**
 * Currency selector in Algorand blockchain.
 *   Currency is selected by asset ID. To select ALGO use ID=0
 */
export type AlgorandCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['Int']>;
  /** Currency not */
  not?: InputMaybe<Scalars['Int']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type AlgorandNetwork =
  /** Algorand Mainnet (ALGO) */
  | 'algorand'
  /** Algorand Betanet */
  | 'algorand_betanet'
  /** Algorand Testnet */
  | 'algorand_testnet';

/** Algorand smart contract */
export type AlgorandSmartContract = {
  __typename?: 'AlgorandSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract byte code */
  bytecode?: Maybe<Scalars['String']>;
  /** Smart Contract Deassembled source code */
  source?: Maybe<Scalars['String']>;
};

export type AlgorandSmartContractCallFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};

/** Smart Contract Calls */
export type AlgorandSmartContractCalls = {
  __typename?: 'AlgorandSmartContractCalls';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Fee used in transaction call */
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash64?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<AlgorandTxType>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_AnyArgs = {
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_MaximumArgs = {
  get?: InputMaybe<AlgorandCallsMeasureable>;
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_MinimumArgs = {
  get?: InputMaybe<AlgorandCallsMeasureable>;
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_TransactionArgs = {
  txFrom?: InputMaybe<Array<AddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_TxSenderArgs = {
  txSender?: InputMaybe<Array<AddressSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCalls_TxTypeArgs = {
  txType?: InputMaybe<Array<AlgorandTxType>>;
};

export type AlgorandTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  group?: InputMaybe<GroupSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txSubtype?: InputMaybe<TxSubtypeSelector>;
  txType?: InputMaybe<TxTypeSelector>;
};

/** Algorand transaction with attributes */
export type AlgorandTransactionWithAttributes = {
  __typename?: 'AlgorandTransactionWithAttributes';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']>;
  /** Transaction fee */
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  /** Transaction rewards ( from )  */
  fromrewards?: Maybe<Scalars['Float']>;
  group?: Maybe<Scalars['String']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  lastRound?: Maybe<Scalars['Int']>;
  lease?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Transfer transaction sender */
  sender?: Maybe<Address>;
  /** Transaction sub type */
  subtype?: Maybe<AlgorandTxSubType>;
  /** Transaction type in which the transfer happened */
  type?: Maybe<AlgorandTxType>;
};

/** Transactions in Algorand blockchain */
export type AlgorandTransactions = {
  __typename?: 'AlgorandTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Asset related to transaction */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['String']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Transaction sender */
  sender?: Maybe<Address>;
  /** Transaction sub type */
  subtype?: Maybe<AlgorandTxSubType>;
  /** Transaction type */
  type?: Maybe<AlgorandTxType>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_AnyArgs = {
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_CountArgs = {
  date?: InputMaybe<DateSelector>;
  group?: InputMaybe<GroupSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txSubtype?: InputMaybe<TxSubtypeSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<AlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  group?: InputMaybe<GroupSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txSubtype?: InputMaybe<TxSubtypeSelector>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<AlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_CurrencyArgs = {
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  group?: InputMaybe<GroupSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  time?: InputMaybe<DateTimeSelector>;
  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txSubtype?: InputMaybe<TxSubtypeSelector>;
  txType?: InputMaybe<TxTypeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_IndexArgs = {
  txIndex?: InputMaybe<Array<TxIndexSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_MaximumArgs = {
  get?: InputMaybe<AlgorandTransactionsMeasureable>;
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_MinimumArgs = {
  get?: InputMaybe<AlgorandTransactionsMeasureable>;
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_SenderArgs = {
  txSender?: InputMaybe<Array<AddressSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_SubtypeArgs = {
  txType?: InputMaybe<TxSubtypeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactions_TypeArgs = {
  txType?: InputMaybe<TxTypeSelector>;
};

export type AlgorandTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee value */
  | 'fee'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender';

export type AlgorandTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique TX senders count */
  | 'senders';

export type AlgorandTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<AddressSelector>>;
  sender?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<AlgorandTransferTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};

export type AlgorandTransferType =
  /** Close */
  | 'close'
  /** Create Asset */
  | 'create'
  /** Asset Freeze */
  | 'freeze'
  /** Genesis Block */
  | 'genesis'
  /** Reward */
  | 'reward'
  /** Send */
  | 'send'
  /** Asset Unfreeze */
  | 'unfreeze';

/** Select transfers by type */
export type AlgorandTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<AlgorandTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<AlgorandTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<AlgorandTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<AlgorandTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers = {
  __typename?: 'AlgorandTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  firstRound?: Maybe<Scalars['Int']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transaction where transfer happened */
  transaction?: Maybe<AlgorandTransactionWithAttributes>;
  /** Transfer Type */
  transferType?: Maybe<AlgorandTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<Array<AddressSelector>>;
  sender?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<AlgorandTransferTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_AnyArgs = {
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<AddressSelector>>;
  sender?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<AlgorandTransferTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<AddressSelector>>;
  sender?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<AlgorandTransferTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<AddressSelector>>;
  txType?: InputMaybe<TxTypeSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_CurrencyArgs = {
  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_MaximumArgs = {
  get?: InputMaybe<AlgorandTransfersMeasureable>;
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_MinimumArgs = {
  get?: InputMaybe<AlgorandTransfersMeasureable>;
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_ReceiverArgs = {
  receiver?: InputMaybe<Array<AddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_SenderArgs = {
  sender?: InputMaybe<Array<AddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers_TransferTypeArgs = {
  transferType?: InputMaybe<Array<AlgorandTransferType>>;
};

export type AlgorandTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Asset ID */
  | 'asset_id'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transfer type */
  | 'transfer_type'
  /** Transaction hash */
  | 'tx_hash'
  /** TX Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type AlgorandTxSubType =
  /** Close */
  | 'close'
  /** Asset Configuration */
  | 'configure'
  /** Create */
  | 'create'
  /** Asset Freeze */
  | 'freeze'
  /** Key Reg */
  | 'keyreg'
  /** None */
  | 'none'
  /** Send */
  | 'send'
  /** Asset Unfreeze */
  | 'unfreeze';

export type AlgorandTxType =
  /** Asset Configuration */
  | 'acfg'
  /** Asset Freeze or Unfreeze */
  | 'afrz'
  /** Application Call */
  | 'appl'
  /** Asset Transfer */
  | 'axfer'
  /** Genesis Block */
  | 'genesis'
  /** Key Reg */
  | 'keyreg'
  /** Pay */
  | 'pay';

export type AmountAggregateFunction =
  /** Any value */
  | 'any'
  /** Last value */
  | 'anyLast'
  /** Average */
  | 'average'
  /** Maximum */
  | 'maximum'
  /** Median */
  | 'median'
  /** Minimum */
  | 'minimum'
  /** Sum (total) */
  | 'sum'
  /** Unique estimate fast */
  | 'unique'
  /** Unique exact */
  | 'uniqueExact';

/** Select by amount */
export type AmountSelector = {
  /** Amount in range */
  between?: InputMaybe<Array<Scalars['Float']>>;
  /** Amount greater than */
  gt?: InputMaybe<Scalars['Float']>;
  /** Amount greater or equal than */
  gteq?: InputMaybe<Scalars['Float']>;
  /** Amount in the list */
  in?: InputMaybe<Array<Scalars['Float']>>;
  /** Amount is */
  is?: InputMaybe<Scalars['Float']>;
  /** Amount less than */
  lt?: InputMaybe<Scalars['Float']>;
  /** Amount less or equal than */
  lteq?: InputMaybe<Scalars['Float']>;
  /** Amount not */
  not?: InputMaybe<Scalars['Float']>;
  /** Amount not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

/** Selector of index of argument in call */
export type ArgumentIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Argument of Smart contract method or event */
export type ArgumentName = {
  __typename?: 'ArgumentName';
  /** Name */
  name: Scalars['String'];
  /** Type */
  type: Scalars['String'];
};

/** Argument name and value of smart contract call or event */
export type ArgumentNameValue = {
  __typename?: 'ArgumentNameValue';
  /** Argument name */
  argument: Scalars['String'];
  /** Argument data type */
  argumentType: Scalars['String'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  /** Value as String */
  value: Scalars['String'];
};

/** Selector of argument for smart contract method or event */
export type ArgumentSelector = {
  /** Argument in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Argument is */
  is?: InputMaybe<Scalars['String']>;
  /** Argument not */
  not?: InputMaybe<Scalars['String']>;
  /** Argument not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Selector of argument type for smart contract method or event */
export type ArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Argument type is */
  is?: InputMaybe<Scalars['String']>;
  /** Argument type not */
  not?: InputMaybe<Scalars['String']>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Argument value of smart contract call or event */
export type ArgumentValue = {
  __typename?: 'ArgumentValue';
  /** Value as Address */
  address?: Maybe<EthereumAddressInfo>;
  /** Value as String */
  value: Scalars['String'];
};

/** Selector of value of argument for smart contract method or event */
export type ArgumentValueSelector = {
  /** Value in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Value is */
  is?: InputMaybe<Scalars['String']>;
  /** Value not */
  not?: InputMaybe<Scalars['String']>;
  /** Value not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type BaseCurrencyEnum =
  /** Binance Smart Chain */
  | 'BNB'
  /** Bitcoin */
  | 'BTC'
  /** Ethereum */
  | 'ETH'
  /** Dollar */
  | 'USD'
  /** Tether USDT */
  | 'USDT';

/** Select by ID with BigInt datatype */
export type BigIntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['BigInt']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['BigInt']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['BigInt']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  /** ID is */
  is?: InputMaybe<Scalars['BigInt']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['BigInt']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['BigInt']>;
  /** ID not */
  not?: InputMaybe<Scalars['BigInt']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

/** Select by big number */
export type BigIntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['BigInt']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['BigInt']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['BigInt']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  /** is */
  is?: InputMaybe<Scalars['BigInt']>;
  /** less than */
  lt?: InputMaybe<Scalars['BigInt']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['BigInt']>;
  /** not */
  not?: InputMaybe<Scalars['BigInt']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

/** Binance DEX */
export type Binance = {
  __typename?: 'Binance';
  /** Binance DEX Network Blocks */
  blocks?: Maybe<Array<BinanceBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BinanceCoinpath>>;
  /** Binance DEX Network Exchange Orders */
  orders?: Maybe<Array<BinanceOrders>>;
  /** Binance DEX Network Trades between currencies */
  trades?: Maybe<Array<BinanceTrades>>;
  /** Binance DEX Network Transactions */
  transactions?: Maybe<Array<BinanceTransactions>>;
  /** Binance DEX Network Currency Transfers */
  transfers?: Maybe<Array<BinanceTransfers>>;
};


/** Binance DEX */
export type Binance_BlocksArgs = {
  any?: InputMaybe<Array<BinanceBlockFilter>>;
  blockId?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;
  validatorMoniker?: InputMaybe<StringIdSelector>;
  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;
};


/** Binance DEX */
export type Binance_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  finalAddress?: InputMaybe<BinanceAddressSelectorIn>;
  initialAddress?: InputMaybe<BinanceAddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<BinanceAddressSelector>;
  sender?: InputMaybe<BinanceAddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Binance DEX */
export type Binance_OrdersArgs = {
  any?: InputMaybe<Array<BinanceOrderFilter>>;
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX */
export type Binance_TradesArgs = {
  any?: InputMaybe<Array<BinanceTradeFilter>>;
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX */
export type Binance_TransactionsArgs = {
  any?: InputMaybe<Array<BinanceTransactionFilter>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  deposit?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  proposalId?: InputMaybe<StringIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCode?: InputMaybe<IntIdSelector>;
  transactionSource?: InputMaybe<IntIdSelector>;
  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX */
export type Binance_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<BinanceTransferFilter>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BinanceAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BinanceAddressSelectorIn = {
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']>;
};

/** Block */
export type BinanceBlock = {
  __typename?: 'BinanceBlock';
  any?: Maybe<Scalars['String']>;
  /** Block ID */
  blockId?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Validator consensus pubkey */
  validatorConsensusPubkey?: Maybe<Scalars['String']>;
  /** Validator fee address */
  validatorFeeAddr?: Maybe<Address>;
  /** Validator moniker */
  validatorMoniker?: Maybe<Scalars['String']>;
  /** Validator operator HR address */
  validatorOperaHrAddress?: Maybe<Address>;
  /** Validator operator address */
  validatorOperatorAddress?: Maybe<Address>;
};


/** Block */
export type BinanceBlock_AnyArgs = {
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlock_BlockIdArgs = {
  blockId?: InputMaybe<StringIdSelector>;
};


/** Block */
export type BinanceBlock_CountArgs = {
  blockId?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<BinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;
  validatorMoniker?: InputMaybe<StringIdSelector>;
  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlock_CountBigIntArgs = {
  blockId?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<BinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;
  validatorMoniker?: InputMaybe<StringIdSelector>;
  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type BinanceBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block */
export type BinanceBlock_MaximumArgs = {
  get?: InputMaybe<BinanceBlocksMeasureable>;
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlock_MinimumArgs = {
  get?: InputMaybe<BinanceBlocksMeasureable>;
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlock_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type BinanceBlock_ValidatorConsensusPubkeyArgs = {
  validatorConsensusPubkey?: InputMaybe<StringIdSelector>;
};


/** Block */
export type BinanceBlock_ValidatorFeeAddrArgs = {
  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlock_ValidatorMonikerArgs = {
  validatorMoniker?: InputMaybe<StringIdSelector>;
};


/** Block */
export type BinanceBlock_ValidatorOperaHrAddressArgs = {
  validatorOperaHrAddress?: InputMaybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlock_ValidatorOperatorAddressArgs = {
  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;
};

export type BinanceBlockFilter = {
  blockId?: InputMaybe<StringIdSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;
  validatorMoniker?: InputMaybe<StringIdSelector>;
  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;
};

export type BinanceBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Validator fee addresses */
  | 'validator_fee_addresses'
  /** Validator operators */
  | 'validator_operator_addresses';

export type BinanceBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator moniker */
  | 'validator_moniker';

/** Coinpath */
export type BinanceCoinpath = {
  __typename?: 'BinanceCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<BinanceCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BinanceCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
};


/** Coinpath */
export type BinanceCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type BinanceCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BinanceCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BinanceCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Binance network */
export type BinanceCoinpathAddress = {
  __typename?: 'BinanceCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  amountIn?: Maybe<Scalars['DecimalNumber']>;
  amountOut?: Maybe<Scalars['DecimalNumber']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumber']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

/**
 * Binance token selector by tokenId.
 *     Native binance token has BNB symbol.
 *     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
 */
export type BinanceCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type BinanceOrderFilter = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};

export type BinanceOrderSide =
  /** Buy Side */
  | 'buy'
  /** Sell Side */
  | 'sell';

export type BinanceOrderStatus =
  /** Ack */
  | 'Ack'
  /** Canceled */
  | 'Canceled'
  /** Expired */
  | 'Expired'
  /** Failed Blocking */
  | 'FailedBlocking'
  /** Fully Fill */
  | 'FullyFill'
  /** Ioc Expire */
  | 'IocExpire'
  /** Ioc No Fill */
  | 'IocNoFill'
  /** Partial Fill */
  | 'PartialFill';

export type BinanceOrderTimeInForce =
  /** Good Till Expiry */
  | 'GTE'
  /** Immediate Or Cancel */
  | 'IOC';

export type BinanceOrderType =
  /** Limit Order */
  | 'LimitOrder';

/** Binance DEX Order */
export type BinanceOrders = {
  __typename?: 'BinanceOrders';
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  baseCurrency?: Maybe<Currency>;
  /** Block where order transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Order ID */
  orderId?: Maybe<Scalars['String']>;
  /** Order owner address */
  orderOwner?: Maybe<Address>;
  /** Order Side */
  orderSide?: Maybe<BinanceOrderSide>;
  /** Order Status */
  orderStatus?: Maybe<BinanceOrderStatus>;
  /** Order Time In Force */
  orderTimeInForce?: Maybe<BinanceOrderTimeInForce>;
  /** Order Type */
  orderType?: Maybe<BinanceOrderType>;
  price?: Maybe<Scalars['Float']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  quoteCurrency?: Maybe<Currency>;
  /** Transaction where order created */
  transaction?: Maybe<TransactionHash>;
};


/** Binance DEX Order */
export type BinanceOrders_AnyArgs = {
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrders_BaseAmountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX Order */
export type BinanceOrders_BaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Binance DEX Order */
export type BinanceOrders_CountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BinanceOrders_CountBigIntArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BinanceOrders_ExpressionArgs = {
  get: Scalars['String'];
};


/** Binance DEX Order */
export type BinanceOrders_MaximumArgs = {
  get?: InputMaybe<BinanceOrdersMeasureable>;
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrders_MinimumArgs = {
  get?: InputMaybe<BinanceOrdersMeasureable>;
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrders_OrderIdArgs = {
  orderId?: InputMaybe<Array<OrderIdSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_OrderOwnerArgs = {
  owner?: InputMaybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_OrderSideArgs = {
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_OrderStatusArgs = {
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_OrderTimeInForceArgs = {
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_OrderTypeArgs = {
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_QuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<OrderSideSelector>>;
  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<OrderTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX Order */
export type BinanceOrders_QuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BinanceOrders_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type BinanceOrdersMeasureable =
  /** Base Amount */
  | 'base_amount'
  /** Base currency */
  | 'base_currency'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Order ID */
  | 'order_id'
  /** Order owner */
  | 'order_owner'
  /** Order side */
  | 'order_side'
  /** Order status */
  | 'order_status'
  /** Price */
  | 'price'
  /** Quote Amount */
  | 'quote_amount'
  /** Quote currency */
  | 'quote_currency'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BinanceOrdersUniq =
  /** Unique base currencies */
  | 'base_currencies'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique order ID count */
  | 'orders'
  /** Unique order owners */
  | 'owners'
  /** Unique quote currencies */
  | 'quote_currencies'
  /** Unique Transactions */
  | 'txs';

export type BinanceTradeFilter = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Binance DEX Trades */
export type BinanceTrades = {
  __typename?: 'BinanceTrades';
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  baseCurrency?: Maybe<Currency>;
  /** Block where trade transaction is included */
  block?: Maybe<Block>;
  /** Buy Order ID */
  buyOrderId?: Maybe<Scalars['String']>;
  /** Trade buyer address */
  buyer?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  quoteCurrency?: Maybe<Currency>;
  /** Sell Order ID */
  sellOrderId?: Maybe<Scalars['String']>;
  /** Trade seller address */
  seller?: Maybe<Address>;
  /** Trade ID */
  tradeId?: Maybe<Scalars['String']>;
  /** Transaction where trade happened */
  transaction?: Maybe<TransactionHashIndex>;
};


/** Binance DEX Trades */
export type BinanceTrades_AnyArgs = {
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTrades_BaseAmountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX Trades */
export type BinanceTrades_BaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Binance DEX Trades */
export type BinanceTrades_BuyOrderIdArgs = {
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_BuyerArgs = {
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_CountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BinanceTrades_CountBigIntArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BinanceTrades_ExpressionArgs = {
  get: Scalars['String'];
};


/** Binance DEX Trades */
export type BinanceTrades_MaximumArgs = {
  get?: InputMaybe<BinanceTradesMeasureable>;
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTrades_MinimumArgs = {
  get?: InputMaybe<BinanceTradesMeasureable>;
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTrades_QuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<AmountSelector>>;
  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;
  buyer?: InputMaybe<Array<BinanceAddressSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  price?: InputMaybe<Array<AmountSelector>>;
  quoteAmount?: InputMaybe<Array<AmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Binance DEX Trades */
export type BinanceTrades_QuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_SellOrderIdArgs = {
  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_SellerArgs = {
  seller?: InputMaybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_TradeIdArgs = {
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTrades_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type BinanceTradesMeasureable =
  /** Base Amount */
  | 'base_amount'
  /** Base currency */
  | 'base_currency'
  /** Block */
  | 'block'
  /** Buy Order ID */
  | 'buy_order_id'
  /** Buyer */
  | 'buyer'
  /** Date */
  | 'date'
  /** Price */
  | 'price'
  /** Quote Amount */
  | 'quote_amount'
  /** Quote currency */
  | 'quote_currency'
  /** Sell Order ID */
  | 'sell_order_id'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Trade ID */
  | 'trade_id'
  /** Transaction hash */
  | 'tx_hash';

export type BinanceTradesUniq =
  /** Unique base currencies */
  | 'base_currencies'
  /** Unique blocks */
  | 'blocks'
  /** Buy Orders */
  | 'buy_orders'
  /** Unique buyers count */
  | 'buyers'
  /** Unique date count */
  | 'dates'
  /** Unique quote currencies */
  | 'quote_currencies'
  /** Sell Orders */
  | 'sell_orders'
  /** Unique sellers count */
  | 'sellers'
  /** Trades */
  | 'trades'
  /** Unique Transactions */
  | 'txs';

export type BinanceTransactionFilter = {
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  deposit?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  proposalId?: InputMaybe<StringIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCode?: InputMaybe<IntIdSelector>;
  transactionSource?: InputMaybe<IntIdSelector>;
  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
};

export type BinanceTransactionType =
  /** Bind */
  | 'BIND'
  /** Submit evidence */
  | 'BSC_SUBMIT_EVIDENCE'
  /** Burn */
  | 'BURN'
  /** Cancel Order */
  | 'CANCEL_ORDER'
  /** Cross chain claim */
  | 'CLAIM'
  /** Hash Timer Locked Claim */
  | 'CLAIM_HTL'
  /** Create sidechain validator */
  | 'CREATE_SIDECHAIN_VALIDATOR'
  /** Deposit */
  | 'DEPOSIT'
  /** Hash Timer Locked Deposit */
  | 'DEPOSIT_HTL'
  /** Edit sidechain validator */
  | 'EDIT_SIDECHAIN_VALIDATOR'
  /** Freeze Token */
  | 'FREEZE_TOKEN'
  /** Hash Timer Locked Transfer */
  | 'HTL_TRANSFER'
  /** Issue */
  | 'ISSUE'
  /** Listing */
  | 'LISTING'
  /** Mini Token Issue */
  | 'MINI_TOKEN_ISSUE'
  /** Mini Token Listing */
  | 'MINI_TOKEN_LIST'
  /** Mini Token Set URI */
  | 'MINI_TOKEN_SET_URI'
  /** Mint */
  | 'MINT'
  /** New Order */
  | 'NEW_ORDER'
  /** Hash Timer Locked  Refund */
  | 'REFUND_HTL'
  /** Delegate for sidechain */
  | 'SIDECHAIN_DELEGATE'
  /** ReDelegate for sidechain */
  | 'SIDECHAIN_REDELEGATE'
  /** Unbond from sidechain */
  | 'SIDECHAIN_UNBOND'
  /** Unjail from sidechain */
  | 'SIDECHAIN_UNJAIL'
  /** Side chain deposit */
  | 'SIDE_DEPOSIT'
  /** Side chain submit poroposal */
  | 'SIDE_SUBMIT_PROPOSAL'
  /** Side chain vote */
  | 'SIDE_VOTE'
  /** Submit Proposal */
  | 'SUBMIT_PROPOSAL'
  /** Set Account Flag */
  | 'SetAccountFlag'
  /** Tiny Token Issue */
  | 'TINY_TOKEN_ISSUE'
  /** Tiny Token Listing */
  | 'TINY_TOKEN_LIST'
  /** Tiny Token Set URI */
  | 'TINY_TOKEN_SET_URI'
  /** Transfer */
  | 'TRANSFER'
  /** Cross chain transfer */
  | 'TRANSFER_OUT'
  /** Time Lock */
  | 'TimeLock'
  /** Time Relock */
  | 'TimeRelock'
  /** Time Unlock */
  | 'TimeUnlock'
  /** UnBind */
  | 'UNBIND'
  /** Unfreeze Token */
  | 'UNFREEZE_TOKEN'
  /** Vote */
  | 'VOTE';

/** Select by transaction type */
export type BinanceTransactionTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<BinanceTransactionType>>;
  /** Transaction Type is */
  is?: InputMaybe<BinanceTransactionType>;
  /** Transaction Type not */
  not?: InputMaybe<BinanceTransactionType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<BinanceTransactionType>>;
};

/** Transaction */
export type BinanceTransactions = {
  __typename?: 'BinanceTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency issued in transaction */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Deposit amount in transaction */
  deposit?: Maybe<Scalars['Float']>;
  /** Transaction Description */
  description?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** TX index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Transaction Log */
  log?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction Memo */
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proposal ID */
  proposalId?: Maybe<Scalars['Int']>;
  /** Transaction Type */
  transactionCode?: Maybe<Scalars['Int']>;
  /** Transaction Source */
  transactionSource?: Maybe<TransactionSource>;
  /** Transaction Type */
  transactionType?: Maybe<BinanceTransactionType>;
};


/** Transaction */
export type BinanceTransactions_AnyArgs = {
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction */
export type BinanceTransactions_CountArgs = {
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  deposit?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  proposalId?: InputMaybe<StringIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCode?: InputMaybe<IntIdSelector>;
  transactionSource?: InputMaybe<IntIdSelector>;
  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceTransactionsUniq>;
};


/** Transaction */
export type BinanceTransactions_CountBigIntArgs = {
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  deposit?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  proposalId?: InputMaybe<StringIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCode?: InputMaybe<IntIdSelector>;
  transactionSource?: InputMaybe<IntIdSelector>;
  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<BinanceTransactionsUniq>;
};


/** Transaction */
export type BinanceTransactions_CurrencyArgs = {
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Transaction */
export type BinanceTransactions_DepositArgs = {
  deposit?: InputMaybe<Array<AmountSelector>>;
};


/** Transaction */
export type BinanceTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction */
export type BinanceTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transaction */
export type BinanceTransactions_MaximumArgs = {
  get?: InputMaybe<BinanceTransactionsMeasureable>;
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactions_MinimumArgs = {
  get?: InputMaybe<BinanceTransactionsMeasureable>;
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactions_ProposalIdArgs = {
  proposalId?: InputMaybe<Array<IntIdSelector>>;
};


/** Transaction */
export type BinanceTransactions_TransactionCodeArgs = {
  transactionCode?: InputMaybe<IntIdSelector>;
};


/** Transaction */
export type BinanceTransactions_TransactionSourceArgs = {
  transactionSource?: InputMaybe<IntIdSelector>;
};


/** Transaction */
export type BinanceTransactions_TransactionTypeArgs = {
  transactionType?: InputMaybe<Array<BinanceTransactionTypeSelector>>;
};

export type BinanceTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Currency */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction Code */
  | 'transaction_code'
  /** Transaction Memo */
  | 'transaction_memo'
  /** Transaction Source Code */
  | 'transaction_source_code'
  /** Transaction Source Name */
  | 'transaction_source_name'
  /** Transaction Type */
  | 'transaction_type'
  /** Transaction hash */
  | 'tx_hash';

export type BinanceTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction source count */
  | 'transaction_sources';

export type BinanceTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

export type BinanceTransferType =
  /** Bind */
  | 'BIND'
  /** Reward for block */
  | 'BLOCK_REWARD'
  /** Submit evidence */
  | 'BSC_SUBMIT_EVIDENCE'
  /** Burning amount */
  | 'BURN'
  /** Cross chain claim */
  | 'CLAIM'
  /** Claiming Hash Timer Locked Transfer */
  | 'CLAIM_HTL'
  /** Create sidechain validator */
  | 'CREATE_SIDECHAIN_VALIDATOR'
  /** Deposit for Hash Timer Locked Transfer */
  | 'DEPOSIT_HTL'
  /** Fee for DEX orders */
  | 'DEX_FEE'
  /** Edit sidechain validator */
  | 'EDIT_SIDECHAIN_VALIDATOR'
  /** Genesis declaration */
  | 'GENESIS_DELEGATION'
  /** Genesis supply declaration */
  | 'GENESIS_SUPPLY'
  /** Hash Timer Locked Transfer */
  | 'HTL_TRANSFER'
  /** Issue token */
  | 'ISSUE'
  /** Mini Token Issue */
  | 'MINI_TOKEN_ISSUE'
  /** Mint token */
  | 'MINT'
  /** Delegate for sidechain */
  | 'SIDECHAIN_DELEGATE'
  /** ReDelegate for sidechain */
  | 'SIDECHAIN_REDELEGATE'
  /** Unbond from sidechain */
  | 'SIDECHAIN_UNBOND'
  /** Side chain deposit */
  | 'SIDE_DEPOSIT'
  /** Side chain submit poroposal */
  | 'SIDE_SUBMIT_PROPOSAL'
  /** Side chain vote */
  | 'SIDE_VOTE'
  /** Tiny Token Issue */
  | 'TINY_TOKEN_ISSUE'
  /** Trade buy side */
  | 'TRADE_BUY'
  /** Trade sell side */
  | 'TRADE_SELL'
  /** Transfer */
  | 'TRANSFER'
  /** Cross chain transfer */
  | 'TRANSFER_OUT'
  /** Transaction fee */
  | 'TX_FEE'
  /** UnBind */
  | 'UNBIND';

/** Select transfer type(s) */
export type BinanceTransferTypeSelector = {
  /** Transfer type in the list */
  in?: InputMaybe<Array<BinanceTransferType>>;
  /** Transfer type is */
  is?: InputMaybe<BinanceTransferType>;
  /** Transfer type not */
  not?: InputMaybe<BinanceTransferType>;
  /** Transfer type not in the list */
  notIn?: InputMaybe<Array<BinanceTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers = {
  __typename?: 'BinanceTransfers';
  /** Transfer amount */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Transfer count */
  count?: Maybe<Scalars['Int']>;
  /** Transfer count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Order Id of trade where transfer happened */
  orderId?: Maybe<Scalars['String']>;
  /** Index of the output for the transfer, 0-based */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Id of trade where transfer happened */
  tradeId?: Maybe<Scalars['String']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transfer type */
  transferType?: Maybe<BinanceTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_AnyArgs = {
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  orderId?: InputMaybe<Array<OrderIdSelector>>;
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_CurrencyArgs = {
  currency?: InputMaybe<Array<BinanceCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_MaximumArgs = {
  get?: InputMaybe<BinanceTransfersMeasureable>;
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_MinimumArgs = {
  get?: InputMaybe<BinanceTransfersMeasureable>;
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_OrderIdArgs = {
  orderId?: InputMaybe<Array<OrderIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_OutputIndexArgs = {
  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_ReceiverArgs = {
  receiver?: InputMaybe<Array<BinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_SenderArgs = {
  sender?: InputMaybe<Array<BinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_TradeIdArgs = {
  tradeId?: InputMaybe<Array<TradeIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers_TransferTypeArgs = {
  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;
};

export type BinanceTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Bitcoin and other UTXO type blockchains */
export type Bitcoin = {
  __typename?: 'Bitcoin';
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitcoinAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitcoinBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitcoinCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitcoinTransactionInput>>;
  /** Blockchain Transaction OmniTransactions */
  omniTransactions?: Maybe<Array<BitcoinOmniTransactiosn>>;
  /** Blockchain Transaction OmniTransfers */
  omniTransfers?: Maybe<Array<BitcoinOmniTransfers>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitcoinTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitcoinTransaction>>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_AddressStatsArgs = {
  address: AddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_BlocksArgs = {
  any?: InputMaybe<Array<BitcoinBlockFilter>>;
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<BitcoinCoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_InputsArgs = {
  any?: InputMaybe<Array<BitcoinInputFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_OmniTransactionsArgs = {
  any?: InputMaybe<Array<BitcoinOmniTransactionsFilter>>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_OmniTransfersArgs = {
  any?: InputMaybe<Array<BitcoinOmniTransfersFilter>>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_OutputsArgs = {
  any?: InputMaybe<Array<BitcoinOutputFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputScriptType?: InputMaybe<StringSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type Bitcoin_TransactionsArgs = {
  any?: InputMaybe<Array<BitcoinTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};

/** AddressStat */
export type BitcoinAddressStats = {
  __typename?: 'BitcoinAddressStats';
  /** Address With Statistics */
  address?: Maybe<AddressStatDimension>;
};

/** Block */
export type BitcoinBlock = {
  __typename?: 'BitcoinBlock';
  any?: Maybe<Scalars['String']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']>;
  /** Block size */
  blockSizeBigInt?: Maybe<Scalars['BigInt']>;
  /** Block stripped size */
  blockStrippedSize?: Maybe<Scalars['Int']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']>;
  /** Block weight */
  blockWeight?: Maybe<Scalars['Int']>;
  /** Block chainwork */
  chainwork?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['Float']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block median timestamp */
  medianTime?: Maybe<DateTime>;
  minimum?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']>;
};


/** Block */
export type BitcoinBlock_AnyArgs = {
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlock_BlockHashArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
};


/** Block */
export type BitcoinBlock_BlockSizeArgs = {
  blockSize?: InputMaybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlock_BlockStrippedSizeArgs = {
  blockStrippedSize?: InputMaybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlock_BlockVersionArgs = {
  blockVersion?: InputMaybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlock_BlockWeightArgs = {
  blockWeight?: InputMaybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlock_CountArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinBlockUniq>;
};


/** Block */
export type BitcoinBlock_CountBigIntArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinBlockUniq>;
};


/** Block */
export type BitcoinBlock_DifficultyArgs = {
  difficulty?: InputMaybe<FloatSelector>;
};


/** Block */
export type BitcoinBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type BitcoinBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block */
export type BitcoinBlock_MaximumArgs = {
  get?: InputMaybe<BitcoinBlocksMeasureable>;
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlock_MinimumArgs = {
  get?: InputMaybe<BitcoinBlocksMeasureable>;
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlock_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type BitcoinBlock_TransactionCountArgs = {
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type BitcoinBlockFilter = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type BitcoinBlockUniq =
  /** Unique date count */
  | 'dates';

export type BitcoinBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Tx Count */
  | 'transaction_count';

/** Coinpath */
export type BitcoinCoinpath = {
  __typename?: 'BitcoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<BitcoinCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitcoinCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitcoinTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type BitcoinCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type BitcoinCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BitcoinCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BitcoinCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Bitcoin network */
export type BitcoinCoinpathAddress = {
  __typename?: 'BitcoinCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

export type BitcoinCoinpathMethod =
  /** Tracking money flow by amounts, ignoring coins (default) */
  | 'moneyflow'
  /** Tracking coins by UTXO transactions */
  | 'utxo';

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitcoinCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<BitcoinCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: InputMaybe<FlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']>;
};

export type BitcoinInputFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type BitcoinInputUniq =
  /** Unique addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type BitcoinInputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Input index */
  | 'input_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type BitcoinNetwork =
  /** Bitcoin Cash ( BCH ) */
  | 'bitcash'
  /** Bitcoin ( BTC ) */
  | 'bitcoin'
  /** Bitcoin SV ( BSV ) */
  | 'bitcoinsv'
  /** Dash ( DASH ) */
  | 'dash'
  /** Dogecoin ( DOGE ) */
  | 'dogecoin'
  /** Litecoin ( LTC ) */
  | 'litecoin'
  /** ZCash ( ZCASH ) */
  | 'zcash';

export type BitcoinOmniTransactionsFilter = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};

export type BitcoinOmniTransactionsMeasureablse =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Time */
  | 'time'
  /** Transactions hash */
  | 'tx_hash'
  /** Transactions index */
  | 'tx_index';

export type BitcoinOmniTransactionsUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction sender */
  | 'tx_sender';

/** OmniTransactions */
export type BitcoinOmniTransactiosn = {
  __typename?: 'BitcoinOmniTransactiosn';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Hash of the block */
  blockHash: Scalars['String'];
  /** OmniTransaction s count */
  count?: Maybe<Scalars['Int']>;
  /** OmniTransaction s count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** OmniTransactions index in block, 0-based */
  index: Scalars['String'];
  /** Invalid Reason */
  invalidReason: Scalars['String'];
  /** Invalid Reason */
  json: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  txSender: Scalars['String'];
  /** Type */
  type: Scalars['String'];
  /** Type Int */
  typeInt: Scalars['Int'];
  /** Version */
  valid: Scalars['Int'];
  /** Version */
  version: Scalars['Int'];
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_AnyArgs = {
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_CountArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_ExpressionArgs = {
  get: Scalars['String'];
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_FeeValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_HashArgs = {
  txHash?: InputMaybe<StringIdSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_IndexArgs = {
  txIndex?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_InvalidReasonArgs = {
  invalidReason?: InputMaybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_JsonArgs = {
  json?: InputMaybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_MaximumArgs = {
  get?: InputMaybe<BitcoinOmniTransactionsMeasureablse>;
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_MinimumArgs = {
  get?: InputMaybe<BitcoinOmniTransactionsMeasureablse>;
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_TxSenderArgs = {
  txSender?: InputMaybe<HashSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_TypeArgs = {
  type?: InputMaybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_TypeIntArgs = {
  typeInt?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_ValidArgs = {
  valid?: InputMaybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosn_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};

/** OmniTransfers */
export type BitcoinOmniTransfers = {
  __typename?: 'BitcoinOmniTransfers';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Hash of the block */
  blockHash: Scalars['String'];
  /** Transaction s count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction s count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  /** Divisible */
  divisible?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transactions index in block, 0-based */
  index: Scalars['String'];
  /** Ismine */
  ismine?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer From */
  transferFrom: Scalars['String'];
  /** Transfer From */
  transferTo: Scalars['String'];
  /** Transaction Sender */
  txSender: Scalars['String'];
  /** Type */
  type: Scalars['String'];
  /** Type Int */
  typeInt: Scalars['Int'];
  /** value */
  value?: Maybe<Scalars['Float']>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_AnyArgs = {
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_CountArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOmniTransfersUniq>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOmniTransfersUniq>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_DirectionArgs = {
  direction?: InputMaybe<StringSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_DivisibleArgs = {
  divisible?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** OmniTransfers */
export type BitcoinOmniTransfers_FeeValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_HashArgs = {
  txHash?: InputMaybe<StringIdSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_IndexArgs = {
  txIndex?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_IsmineArgs = {
  ismine?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_MaximumArgs = {
  get?: InputMaybe<BitcoinOmniTransfersMeasureablse>;
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_MinimumArgs = {
  get?: InputMaybe<BitcoinOmniTransfersMeasureablse>;
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_TransferFromArgs = {
  transferFrom?: InputMaybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_TransferToArgs = {
  transferTo?: InputMaybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_TxSenderArgs = {
  txSender?: InputMaybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_TypeArgs = {
  type?: InputMaybe<StringSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_TypeIntArgs = {
  typeInt?: InputMaybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfers_ValueArgs = {
  value?: InputMaybe<FloatSelector>;
};

export type BitcoinOmniTransfersFilter = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  invalidReason?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSender?: InputMaybe<HashSelector>;
  type?: InputMaybe<StringSelector>;
  typeId?: InputMaybe<IntegerSelector>;
  valid?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<IntegerSelector>;
};

export type BitcoinOmniTransfersMeasureablse =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Time */
  | 'time'
  /** Transactions hash */
  | 'tx_hash'
  /** Transactions index */
  | 'tx_index';

export type BitcoinOmniTransfersUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction sender */
  | 'tx_sender';

export type BitcoinOutputDirection =
  /** Change return */
  | 'change'
  /** Fee */
  | 'fee'
  /** Genesis */
  | 'genesis'
  /** Likely Change return */
  | 'likely_change'
  /** Likely Not a change return */
  | 'likely_not_change'
  /** Mining */
  | 'mining'
  /** Minting */
  | 'minting'
  /** Not a change return */
  | 'not_change'
  /** Not defined */
  | 'unknown';

/** A guessed direction of output */
export type BitcoinOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<BitcoinOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<BitcoinOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<BitcoinOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<BitcoinOutputDirection>>;
};

export type BitcoinOutputFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputScriptType?: InputMaybe<StringSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type BitcoinOutputUniq =
  /** Unique input addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type BitcoinOutputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Output index */
  | 'output_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

/** Transaction */
export type BitcoinTransaction = {
  __typename?: 'BitcoinTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction total mined value */
  minedValue?: Maybe<Scalars['Float']>;
  /** Transaction total mined value */
  minedValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  /** Transaction is coinbase */
  txCoinbase?: Maybe<Scalars['Boolean']>;
  /** Transaction locktime */
  txLocktime?: Maybe<Scalars['BigInt']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']>;
  /** Transaction version */
  txVersion?: Maybe<Scalars['Int']>;
  /** Transaction vsize */
  txVsize?: Maybe<Scalars['Int']>;
  /** Transaction weight */
  txWeight?: Maybe<Scalars['Int']>;
};


/** Transaction */
export type BitcoinTransaction_AnyArgs = {
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransaction_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction */
export type BitcoinTransaction_CountArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinTransactionUniq>;
};


/** Transaction */
export type BitcoinTransaction_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinTransactionUniq>;
};


/** Transaction */
export type BitcoinTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction */
export type BitcoinTransaction_FeeValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_FeeValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_HashArgs = {
  txHash?: InputMaybe<StringIdSelector>;
};


/** Transaction */
export type BitcoinTransaction_IndexArgs = {
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_InputCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_InputCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_InputValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_InputValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_MaximumArgs = {
  get?: InputMaybe<BitcoinTransactionsMeasureable>;
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransaction_MinedValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_MinedValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_MinimumArgs = {
  get?: InputMaybe<BitcoinTransactionsMeasureable>;
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransaction_OutputCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_OutputCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_OutputValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_OutputValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_TxCoinbaseArgs = {
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
};


/** Transaction */
export type BitcoinTransaction_TxLocktimeArgs = {
  txLocktime?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_TxSizeArgs = {
  txSize?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_TxVersionArgs = {
  txVersion?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_TxVsizeArgs = {
  txVsize?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransaction_TxWeightArgs = {
  txWeight?: InputMaybe<IntegerSelector>;
};

export type BitcoinTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  minedValue?: InputMaybe<FloatSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txLocktime?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  txVersion?: InputMaybe<IntegerSelector>;
  txVsize?: InputMaybe<IntegerSelector>;
  txWeight?: InputMaybe<IntegerSelector>;
};

/** Blockchain transaction */
export type BitcoinTransactionHashIndexValues = {
  __typename?: 'BitcoinTransactionHashIndexValues';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction value in input */
  valueIn: Scalars['Float'];
  /** Transaction value in input */
  valueInDecimal: Scalars['DecimalNumber'];
  /** Transaction value in output */
  valueOut: Scalars['Float'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['DecimalNumber'];
};

/** Transaction Input */
export type BitcoinTransactionInput = {
  __typename?: 'BitcoinTransactionInput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Input count */
  count?: Maybe<Scalars['Int']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Input address */
  inputAddress?: Maybe<Address>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']>;
  /** Input script */
  inputScript?: Maybe<Scalars['String']>;
  /** Input script type and attributes */
  inputScriptType?: Maybe<InputScript>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<TransactionHashIndex>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumber']>;
};


/** Transaction Input */
export type BitcoinTransactionInput_AnyArgs = {
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInput_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinInputUniq>;
};


/** Transaction Input */
export type BitcoinTransactionInput_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinInputUniq>;
};


/** Transaction Input */
export type BitcoinTransactionInput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction Input */
export type BitcoinTransactionInput_InputAddressArgs = {
  inputAddress?: InputMaybe<AddressSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_InputIndexArgs = {
  inputIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_InputScriptTypeArgs = {
  inputScriptType?: InputMaybe<StringSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_MaximumArgs = {
  get?: InputMaybe<BitcoinInputsMeasureable>;
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInput_MinimumArgs = {
  get?: InputMaybe<BitcoinInputsMeasureable>;
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInput_OutputTransactionArgs = {
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<StringIdSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_TransactionArgs = {
  txId?: InputMaybe<StringIdSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_ValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInput_ValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

/** Transaction Output */
export type BitcoinTransactionOutput = {
  __typename?: 'BitcoinTransactionOutput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Output count */
  count?: Maybe<Scalars['Int']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output address */
  outputAddress?: Maybe<Address>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitcoinOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Output script */
  outputScript?: Maybe<Scalars['String']>;
  /** Output script type and attributes */
  outputScriptType?: Maybe<OutputScript>;
  reqSigs?: Maybe<Scalars['Int']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']>;
  /** Output value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumber']>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_AnyArgs = {
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutput_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputScriptType?: InputMaybe<StringSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOutputUniq>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputScriptType?: InputMaybe<StringSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<BitcoinOutputUniq>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction Output */
export type BitcoinTransactionOutput_MaximumArgs = {
  get?: InputMaybe<BitcoinOutputsMeasureable>;
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutput_MinimumArgs = {
  get?: InputMaybe<BitcoinOutputsMeasureable>;
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutput_OutputAddressArgs = {
  outputAddress?: InputMaybe<AddressSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_OutputDirectionArgs = {
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_OutputIndexArgs = {
  outputIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_OutputScriptTypeArgs = {
  inputScriptType?: InputMaybe<StringSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_TransactionArgs = {
  txId?: InputMaybe<StringIdSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_ValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputScriptType?: InputMaybe<StringSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutput_ValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputScriptType?: InputMaybe<StringSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type BitcoinTransactionUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type BitcoinTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Input count */
  | 'input_count'
  /** Transaction input value */
  | 'input_value'
  /** Output count */
  | 'output_count'
  /** Transaction output value */
  | 'output_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index'
  /** Transaction size */
  | 'tx_size';

/** Block */
export type Block = {
  __typename?: 'Block';
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** BlockExtended */
export type BlockExtended = {
  __typename?: 'BlockExtended';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** ConfluxBlock */
export type BlockInfo = {
  __typename?: 'BlockInfo';
  /** Block hash */
  hash?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** Select block by height ( sequence number) */
export type BlockSelector = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']>;
  /** Block height in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Block height is */
  is?: InputMaybe<Scalars['Int']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
  /** Block height not */
  not?: InputMaybe<Scalars['Int']>;
  /** Block height not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Select block by height ( sequence number) */
export type BlockSelectorRange = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']>;
  /** Block height eq */
  is?: InputMaybe<Scalars['Int']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
};

/** Blockchain network */
export type BlockchainNetwork = {
  __typename?: 'BlockchainNetwork';
  /** Network name */
  network: Network;
  /** Network protocol type */
  protocol: Protocol;
};

/** Select by boolean (sequence number) */
export type BooleanSelector = {
  /** Is */
  is?: InputMaybe<Scalars['Boolean']>;
  /** Is not */
  not?: InputMaybe<Scalars['Boolean']>;
};

/** Cardano */
export type Cardano = {
  __typename?: 'Cardano';
  /** Information about address */
  address: Array<CardanoAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<CardanoAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<CardanoBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<CardanoCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<CardanoTransactionInput>>;
  /** Blockchain Tokens Mints */
  mints?: Maybe<Array<CardanoTransactionMint>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<CardanoTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<CardanoTransaction>>;
};


/** Cardano */
export type Cardano_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Cardano */
export type Cardano_AddressStatsArgs = {
  address: AddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** Cardano */
export type Cardano_BlocksArgs = {
  any?: InputMaybe<Array<CardanoBlockFilter>>;
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  opCert?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  slot?: InputMaybe<IntegerSelector>;
  slotInEpoch?: InputMaybe<IntegerSelector>;
  slotLeaderHash?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<StringSelector>;
  vrfKey?: InputMaybe<StringSelector>;
};


/** Cardano */
export type Cardano_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CardanoCoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Cardano */
export type Cardano_InputsArgs = {
  any?: InputMaybe<Array<CardanoInputFilter>>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Cardano */
export type Cardano_MintsArgs = {
  any?: InputMaybe<Array<CardanoMintFilter>>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<FloatSelector>;
};


/** Cardano */
export type Cardano_OutputsArgs = {
  any?: InputMaybe<Array<CardanoOutputFilter>>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Cardano */
export type Cardano_TransactionsArgs = {
  any?: InputMaybe<Array<CardanoTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};

/** Address balance information for Cardano network */
export type CardanoAddressBalance = {
  __typename?: 'CardanoAddressBalance';
  /** Currency */
  currency?: Maybe<Currency>;
  /** Currency value */
  value?: Maybe<Scalars['Float']>;
};

/** Address detailed information for Cardano network */
export type CardanoAddressInfo = {
  __typename?: 'CardanoAddressInfo';
  /** Address */
  address?: Maybe<Address>;
  /** Current address balances */
  balance?: Maybe<Array<CardanoAddressBalance>>;
  /** Current staking addressese info */
  staking?: Maybe<Array<CardanoStakingAddress>>;
};

/** AddressStat */
export type CardanoAddressStats = {
  __typename?: 'CardanoAddressStats';
  /** Address With Statistics */
  address?: Maybe<AddressStatDimension>;
};

/** Block */
export type CardanoBlock = {
  __typename?: 'CardanoBlock';
  any?: Maybe<Scalars['String']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Epoch number */
  epoch?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op cert */
  opCert?: Maybe<Scalars['String']>;
  /** Slot number */
  slot?: Maybe<Scalars['Int']>;
  /** Slot in epoch number */
  slotInEpoch?: Maybe<Scalars['Int']>;
  /** Slot leader description */
  slotLeaderDescription?: Maybe<Scalars['String']>;
  /** Slot leader hash */
  slotLeaderHash?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']>;
  /** VRF Key */
  vrfKey?: Maybe<Scalars['String']>;
};


/** Block */
export type CardanoBlock_AnyArgs = {
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlock_BlockHashArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
};


/** Block */
export type CardanoBlock_BlockSizeArgs = {
  blockSize?: InputMaybe<IntegerSelector>;
};


/** Block */
export type CardanoBlock_BlockVersionArgs = {
  blockVersion?: InputMaybe<IntegerSelector>;
};


/** Block */
export type CardanoBlock_CountArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoBlockUniq>;
};


/** Block */
export type CardanoBlock_CountBigIntArgs = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockStrippedSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  blockWeight?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoBlockUniq>;
};


/** Block */
export type CardanoBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type CardanoBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block */
export type CardanoBlock_MaximumArgs = {
  get?: InputMaybe<CardanoBlocksMeasureable>;
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlock_MinimumArgs = {
  get?: InputMaybe<CardanoBlocksMeasureable>;
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlock_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type CardanoBlock_TransactionCountArgs = {
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type CardanoBlockFilter = {
  blockHash?: InputMaybe<StringIdSelector>;
  blockSize?: InputMaybe<IntegerSelector>;
  blockVersion?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  opCert?: InputMaybe<StringSelector>;
  slot?: InputMaybe<IntegerSelector>;
  slotInEpoch?: InputMaybe<IntegerSelector>;
  slotLeaderHash?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  version?: InputMaybe<StringSelector>;
  vrfKey?: InputMaybe<StringSelector>;
};

export type CardanoBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique epoch */
  | 'epoch'
  /** Unique slot */
  | 'slot'
  /** Unique slot leader */
  | 'slot_leader'
  /** Unique version */
  | 'version';

export type CardanoBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Tx Count */
  | 'transaction_count';

/** Coinpath */
export type CardanoCoinpath = {
  __typename?: 'CardanoCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<CardanoCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<CardanoCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<CardanoTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type CardanoCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type CardanoCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type CardanoCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type CardanoCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Cardano network */
export type CardanoCoinpathAddress = {
  __typename?: 'CardanoCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

export type CardanoCoinpathMethod =
  /** Tracking money flow by amounts, ignoring coins (default) */
  | 'moneyflow'
  /** Tracking coins by UTXO transactions */
  | 'utxo';

/** Limits, Ordering, Constraints, Coinpath Options */
export type CardanoCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<CardanoCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: InputMaybe<FlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']>;
  /** Option to get info for staking addresses */
  stakingAddress?: InputMaybe<Scalars['Boolean']>;
};

/**
 * Cardano token selector by tokenId.
 *     Native binance token has ADA symbol, pass it as argument.
 *     Otherwise pass asset fingerprint, starting from asset...
 */
export type CardanoCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type CardanoInputFilter = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type CardanoInputSource =
  /** Input */
  | 'input'
  /** Stake Deregistration */
  | 'stake_deregistration'
  /** Withdrawal */
  | 'withdrawal';

/** A source input */
export type CardanoInputSourcenSelector = {
  /** In the list of source */
  in?: InputMaybe<Array<CardanoInputSource>>;
  /** Equal to source */
  is?: InputMaybe<CardanoInputSource>;
  /** Not Equal to source */
  not?: InputMaybe<CardanoInputSource>;
  /** Not in the list of source */
  notIn?: InputMaybe<Array<CardanoInputSource>>;
};

export type CardanoInputUniq =
  /** Unique addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique source count */
  | 'sources'
  /** Unique transactions count */
  | 'transactions';

export type CardanoInputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Input index */
  | 'input_index'
  /** Input source */
  | 'source'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type CardanoMintFilter = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<FloatSelector>;
};

export type CardanoMintUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type CardanoMintsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type CardanoNetwork =
  /** Cardano ( ADA ) */
  | 'cardano';

export type CardanoOutputDirection =
  /** Change return */
  | 'change'
  /** Stake Registration */
  | 'deposit'
  /** Genesis */
  | 'genesis'
  /** Not a change return */
  | 'not_change'
  /** Stake Registration */
  | 'stake_registration'
  /** Not defined */
  | 'unknown';

/** A guessed direction of output */
export type CardanoOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<CardanoOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<CardanoOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<CardanoOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<CardanoOutputDirection>>;
};

export type CardanoOutputFilter = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type CardanoOutputUniq =
  /** Unique input addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique direction count */
  | 'directions'
  /** Unique transactions count */
  | 'transactions';

export type CardanoOutputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Output direction */
  | 'direction'
  /** Output index */
  | 'output_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

/** Address staking information for Cardano network */
export type CardanoStakingAddress = {
  __typename?: 'CardanoStakingAddress';
  /** Staking Address */
  address?: Maybe<Address>;
  /** Controlled total stake */
  controlledTotalStake?: Maybe<Scalars['Float']>;
  /** Rewards value */
  rewardsAmount?: Maybe<Scalars['Float']>;
  /** Rewards available */
  rewardsAvailable?: Maybe<Scalars['Float']>;
  /** Staked value */
  stakedAmount?: Maybe<Scalars['Float']>;
  /** Staked value including rewards */
  stakedAmountWithRewards?: Maybe<Scalars['Float']>;
  /** Withdrawn value */
  withdrawnAmount?: Maybe<Scalars['Float']>;
};

/** Transaction */
export type CardanoTransaction = {
  __typename?: 'CardanoTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction total deposit value */
  depositValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  depositValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Included at timestamp */
  includedAt?: Maybe<DateTime>;
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Invalid before */
  invalidBefore?: Maybe<Scalars['String']>;
  /** Invalid hereafter */
  invalidHereafter?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction total mint count */
  mintCount?: Maybe<Scalars['Int']>;
  /** Transaction total mint count */
  mintCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']>;
  /** Transaction total withdrawal count */
  withdrawalCount?: Maybe<Scalars['Int']>;
  /** Transaction total withdrawal count */
  withdrawalCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total withdrawal value */
  withdrawalValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  withdrawalValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction */
export type CardanoTransaction_AnyArgs = {
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransaction_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction */
export type CardanoTransaction_CountArgs = {
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_DepositValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_DepositValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction */
export type CardanoTransaction_FeeValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_FeeValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_HashArgs = {
  txHash?: InputMaybe<StringIdSelector>;
};


/** Transaction */
export type CardanoTransaction_IndexArgs = {
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type CardanoTransaction_InputCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_InputCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_InputValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_InputValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_MaximumArgs = {
  get?: InputMaybe<CardanoTransactionsMeasureable>;
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransaction_MinimumArgs = {
  get?: InputMaybe<CardanoTransactionsMeasureable>;
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransaction_MintCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_MintCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_OutputCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_OutputCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_OutputValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_OutputValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_TxSizeArgs = {
  txSize?: InputMaybe<IntegerSelector>;
};


/** Transaction */
export type CardanoTransaction_WithdrawalCountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_WithdrawalCountBigIntArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_WithdrawalValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransaction_WithdrawalValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};

export type CardanoTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  depositValue?: InputMaybe<FloatSelector>;
  feeValue?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  inputAddress?: InputMaybe<AddressSelectorIn>;
  inputCount?: InputMaybe<IntegerSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  mintCount?: InputMaybe<IntegerSelector>;
  outputAddress?: InputMaybe<AddressSelectorIn>;
  outputCount?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txSize?: InputMaybe<IntegerSelector>;
  withdrawalCount?: InputMaybe<IntegerSelector>;
  withdrawalValue?: InputMaybe<FloatSelector>;
};

/** Blockchain transaction */
export type CardanoTransactionHashIndexValues = {
  __typename?: 'CardanoTransactionHashIndexValues';
  depositValue: Scalars['Float'];
  /** Transaction deposit value as decimal */
  depositValueDecimal: Scalars['DecimalNumberAsDiv'];
  feeValue: Scalars['Float'];
  /** Transaction fee value as decimal */
  feeValueDecimal: Scalars['DecimalNumberAsDiv'];
  /** Hash hex representation */
  hash: Scalars['String'];
  includedAt: DateTime;
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  invalidBefore: Scalars['String'];
  invalidHereafter: Scalars['String'];
  metadata: Scalars['String'];
  txSize: Scalars['Int'];
  /** Transaction value in input */
  valueIn: Scalars['Float'];
  /** Transaction value in input as decimal */
  valueInDecimal: Scalars['DecimalNumberAsDiv'];
  /** Transaction value in output */
  valueOut: Scalars['Float'];
  /** Transaction value in output as decimal */
  valueOutDecimal: Scalars['DecimalNumberAsDiv'];
  withdrawalValue: Scalars['Float'];
  /** Transaction withdraw value as decimal */
  withdrawalValueDecimal: Scalars['DecimalNumberAsDiv'];
};

/** Transaction Input */
export type CardanoTransactionInput = {
  __typename?: 'CardanoTransactionInput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Input count */
  count?: Maybe<Scalars['Int']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the input */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Input address */
  inputAddress?: Maybe<Address>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<TransactionHashIndex>;
  /** Source of the input */
  source?: Maybe<CardanoInputSource>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction Input */
export type CardanoTransactionInput_AnyArgs = {
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInput_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_CountArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoInputUniq>;
};


/** Transaction Input */
export type CardanoTransactionInput_CountBigIntArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoInputUniq>;
};


/** Transaction Input */
export type CardanoTransactionInput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction Input */
export type CardanoTransactionInput_InputAddressArgs = {
  inputAddress?: InputMaybe<AddressSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_InputIndexArgs = {
  inputIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_MaximumArgs = {
  get?: InputMaybe<CardanoInputsMeasureable>;
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInput_MinimumArgs = {
  get?: InputMaybe<CardanoInputsMeasureable>;
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInput_OutputTransactionArgs = {
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<StringIdSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_TransactionArgs = {
  txId?: InputMaybe<StringIdSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_ValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInput_ValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

/** Transaction Mint */
export type CardanoTransactionMint = {
  __typename?: 'CardanoTransactionMint';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Mint count */
  count?: Maybe<Scalars['Int']>;
  /** Mint count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the mint */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Mint value */
  value?: Maybe<Scalars['Float']>;
};


/** Transaction Mint */
export type CardanoTransactionMint_AnyArgs = {
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMint_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMint_CountArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoMintUniq>;
  value?: InputMaybe<FloatSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMint_CountBigIntArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoMintUniq>;
  value?: InputMaybe<FloatSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMint_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction Mint */
export type CardanoTransactionMint_MaximumArgs = {
  get?: InputMaybe<CardanoMintsMeasureable>;
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMint_MinimumArgs = {
  get?: InputMaybe<CardanoMintsMeasureable>;
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMint_TransactionArgs = {
  txId?: InputMaybe<StringIdSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMint_ValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<FloatSelector>;
};

/** Transaction Output */
export type CardanoTransactionOutput = {
  __typename?: 'CardanoTransactionOutput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Output count */
  count?: Maybe<Scalars['Int']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the output */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output address */
  outputAddress?: Maybe<Address>;
  /** Output guessed direction */
  outputDirection?: Maybe<CardanoOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction Output */
export type CardanoTransactionOutput_AnyArgs = {
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutput_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_CountArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoOutputUniq>;
};


/** Transaction Output */
export type CardanoTransactionOutput_CountBigIntArgs = {
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<CardanoOutputUniq>;
};


/** Transaction Output */
export type CardanoTransactionOutput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction Output */
export type CardanoTransactionOutput_MaximumArgs = {
  get?: InputMaybe<CardanoOutputsMeasureable>;
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutput_MinimumArgs = {
  get?: InputMaybe<CardanoOutputsMeasureable>;
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutput_OutputAddressArgs = {
  outputAddress?: InputMaybe<AddressSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_OutputDirectionArgs = {
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_OutputIndexArgs = {
  outputIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_TransactionArgs = {
  txId?: InputMaybe<StringIdSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_ValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  outputAddress?: InputMaybe<AddressSelector>;
  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<IntegerSelector>;
  outputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutput_ValueDecimalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<CardanoCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  inOutputIndex?: InputMaybe<IntegerSelector>;
  inOutputTxId?: InputMaybe<HashSelector>;
  inputAddress?: InputMaybe<AddressSelector>;
  inputIndex?: InputMaybe<IntegerSelector>;
  inputSource?: InputMaybe<CardanoInputSourcenSelector>;
  inputValue?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
};

export type CardanoTransactionUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type CardanoTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Transaction deposit value */
  | 'deposit_value'
  /** Input count */
  | 'input_count'
  /** Transaction input value */
  | 'input_value'
  /** Transaction mint count */
  | 'mint_count'
  /** Output count */
  | 'output_count'
  /** Transaction output value */
  | 'output_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index'
  /** Transaction size */
  | 'tx_size'
  /** Transaction withdrawal count */
  | 'withdrawal_count'
  /** Transaction withdrawal value */
  | 'withdrawal_value';

/** Transaction attributes in coinpath */
export type CoinpathEntry = {
  __typename?: 'CoinpathEntry';
  /** Amount involved in the flow */
  amount: Scalars['Float'];
  /** Block of transaction */
  height: Scalars['Int'];
  /** Time of transaction in ISO 8601 format */
  timestamp: Scalars['ISO8601DateTime'];
  /** Hash of transaction */
  txHash: Scalars['String'];
  /** Amount transfered in transaction */
  txValue: Scalars['Float'];
};

export type CoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Limits, Ordering, Constraints, Coinpath Options */
export type CoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: InputMaybe<FlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']>;
};

/** Conflux Chain */
export type Conflux = {
  __typename?: 'Conflux';
  /** Conflux Active Addresses */
  activeAddresses?: Maybe<Array<ConfluxActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<ConfluxAddressInfoWithBalance>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<ConfluxArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<ConfluxBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<ConfluxCoinpath>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<ConfluxReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<ConfluxSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<ConfluxSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<ConfluxTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<ConfluxTransfers>>;
};


/** Conflux Chain */
export type Conflux_ActiveAddressesArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Conflux Chain */
export type Conflux_AddressArgs = {
  address: Array<ConfluxAddressSelectorIn>;
};


/** Conflux Chain */
export type Conflux_ArgumentsArgs = {
  any?: InputMaybe<Array<ConfluxArgumentFilter>>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Conflux Chain */
export type Conflux_BlocksArgs = {
  any?: InputMaybe<Array<ConfluxBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  options?: InputMaybe<QueryOptions>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Conflux Chain */
export type Conflux_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<ConfluxAddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<ConfluxAddressSelector>;
  sender?: InputMaybe<ConfluxAddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Conflux Chain */
export type Conflux_ReferencesArgs = {
  any?: InputMaybe<Array<ConfluxReferencesFilter>>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Conflux Chain */
export type Conflux_SmartContractCallsArgs = {
  any?: InputMaybe<Array<ConfluxSmartContractCallFilter>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Conflux Chain */
export type Conflux_SmartContractEventsArgs = {
  any?: InputMaybe<Array<ConfluxSmartContractEventFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Conflux Chain */
export type Conflux_TransactionsArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<ConfluxTransactionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Conflux Chain */
export type Conflux_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<ConfluxTransferFilter>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Address that have been active in transfers */
export type ConfluxActiveAddress = {
  __typename?: 'ConfluxActiveAddress';
  /** Transfer address */
  address?: Maybe<ConfluxAddressInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
};


/** Address that have been active in transfers */
export type ConfluxActiveAddress_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq: ActiveAddressUniq;
};


/** Address that have been active in transfers */
export type ConfluxActiveAddress_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq: ActiveAddressUniq;
};

/** Address detailed information for Conflux network */
export type ConfluxAddressInfo = {
  __typename?: 'ConfluxAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<ConfluxSmartContractInfo>;
};

/** Blockchain address */
export type ConfluxAddressInfoWithBalance = {
  __typename?: 'ConfluxAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<ConfluxBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<ConfluxSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type ConfluxAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Blockchain address */
export type ConfluxAddressInfoWithBalance_BalancesArgs = {
  currency?: InputMaybe<ConfluxCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelectorRange>;
  time?: InputMaybe<DateTimeSelector>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type ConfluxAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type ConfluxAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
};

export type ConfluxArgumentFilter = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

/** Argument name and value of smart contract call or event */
export type ConfluxArgumentNameValue = {
  __typename?: 'ConfluxArgumentNameValue';
  /** Argument name */
  argument: Scalars['String'];
  /** Argument data type */
  argumentType: Scalars['String'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  /** Value as String */
  value: Scalars['String'];
};

/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments = {
  __typename?: 'ConfluxArguments';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<ConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** Address value of method or event argument */
  reference?: Maybe<ConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<ConfluxSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<ConfluxTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<ArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_AnyArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_ArgumentArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_CallerArgs = {
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_CountArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_CountBigIntArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_MaximumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<ConfluxArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_MinimumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<ConfluxArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_NumberArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_ReferenceArgs = {
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_SmartContractSignatureArgs = {
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_TransactionArgs = {
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type ConfluxArguments_ValueArgs = {
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

export type ConfluxArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type ConfluxArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Balance in a currency */
export type ConfluxBalance = {
  __typename?: 'ConfluxBalance';
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<ConfluxBalanceChange>>;
  value?: Maybe<Scalars['Float']>;
};


/** Balance in a currency */
export type ConfluxBalance_ValueArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type ConfluxBalanceChange = {
  __typename?: 'ConfluxBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']>;
  value?: Maybe<Scalars['Float']>;
};

export type ConfluxBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};

/** Blocks in Conflux blockchain */
export type ConfluxBlocks = {
  __typename?: 'ConfluxBlocks';
  /** Block is adaptive */
  adaptive: Scalars['Boolean'];
  any?: Maybe<Scalars['String']>;
  /** Blame */
  blame: Scalars['Int'];
  /** Block index in epoch */
  blockPosition: Scalars['Int'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Epoch in blockchain */
  epoch: Scalars['Int'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block height in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block miner */
  miner?: Maybe<EthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']>;
  /** Block nonce */
  nonce: Scalars['Int'];
  /** Parent block hash */
  parentHash: Scalars['String'];
  /** Block is pivot */
  pivot: Scalars['Boolean'];
  /** Power Quality */
  powerQuality: Scalars['BigInt'];
  refereeCount?: Maybe<Scalars['Int']>;
  refereeCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Reference Block hash */
  referenceBlockHash: Scalars['String'];
  size?: Maybe<Scalars['Int']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalDifficulty?: Maybe<Scalars['Float']>;
  transactionCount?: Maybe<Scalars['Int']>;
  transactionCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Hash of Transaction included in block */
  txHash: Scalars['String'];
  uncleCount?: Maybe<Scalars['Int']>;
  uncleCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_AnyArgs = {
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
  uniq?: InputMaybe<EthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
  uniq?: InputMaybe<EthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_EpochArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_MaximumArgs = {
  get?: InputMaybe<ConfluxBlocksMeasureable>;
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_MinerArgs = {
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_MinimumArgs = {
  get?: InputMaybe<ConfluxBlocksMeasureable>;
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_RefereeCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_RefereeCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_ReferenceBlockHashArgs = {
  referenceBlockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_SizeArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_TotalDifficultyArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_TransactionCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_TransactionCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_TxHashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_UncleCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocks_UncleCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BlockSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<ConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']>;
  refereeCount?: InputMaybe<Array<IntegerSelector>>;
  referenceBlockHash?: InputMaybe<HashSelector>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};

export type ConfluxBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Block Referee Count */
  | 'referee_count'
  /** Time */
  | 'time'
  /** Block TX Count */
  | 'transaction_count';

export type ConfluxCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Coinpath */
export type ConfluxCoinpath = {
  __typename?: 'ConfluxCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<ConfluxCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<ConfluxCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type ConfluxCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type ConfluxCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type ConfluxCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type ConfluxCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Conflux network */
export type ConfluxCoinpathAddress = {
  __typename?: 'ConfluxCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  amountIn?: Maybe<Scalars['DecimalNumber']>;
  amountOut?: Maybe<Scalars['DecimalNumber']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumber']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<ConfluxSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

/**
 * Currency selector in Conflux blockchain.
 *   Currencies supported are native ( CFX ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols CFX are reserved for native currencies in Conflux mainnet and classic.
 *   Conflux Smart contract address should start from cfx: and contain 42 symbols.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type ConfluxCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfluxEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Event Signature */
  | 'signature'
  /** Smart Contract Event Signature Hash */
  | 'signature_hash'
  /** Smart Contract Event Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type ConfluxNetwork =
  /** Conflux Hydra */
  | 'conflux_hydra'
  /** Conflux Oceanus */
  | 'conflux_oceanus'
  /** Conflux Tethys */
  | 'conflux_tethys';

export type ConfluxReferencesFilter = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Address value of method or event argument */
export type ConfluxReferencess = {
  __typename?: 'ConfluxReferencess';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<ConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** Address value of method or event argument */
  reference?: Maybe<ConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_AnyArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_ArgumentArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_CallerArgs = {
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_CountArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_CountBigIntArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_ExpressionArgs = {
  get: Scalars['String'];
};


/** Address value of method or event argument */
export type ConfluxReferencess_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_MaximumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<ConfluxReferencessMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_MinimumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<ConfluxReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<ConfluxReferencessMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: ConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_NumberArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_ReferenceArgs = {
  reference?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_SmartContractSignatureArgs = {
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Address value of method or event argument */
export type ConfluxReferencess_TransactionArgs = {
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type ConfluxReferencessConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type ConfluxReferencessMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Conflux smart contract */
export type ConfluxSmartContract = {
  __typename?: 'ConfluxSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type ConfluxSmartContractCallFilter = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Smart Contract Calls */
export type ConfluxSmartContractCalls = {
  __typename?: 'ConfluxSmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Call arguments */
  arguments?: Maybe<Array<ConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<ConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<ConfluxSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<ConfluxTransactionInfo>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_AmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_AnyArgs = {
  of: ConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_CallerArgs = {
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_CountArgs = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_CountBigIntArgs = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<ConfluxAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']>>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_MaximumArgs = {
  get?: InputMaybe<ConfluxCallsMeasureable>;
  of: ConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_MinimumArgs = {
  get?: InputMaybe<ConfluxCallsMeasureable>;
  of: ConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type ConfluxSmartContractCalls_TransactionArgs = {
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

/** Smart Contract Events */
export type ConfluxSmartContractEvent = {
  __typename?: 'ConfluxSmartContractEvent';
  any?: Maybe<Scalars['String']>;
  /** Event arguments */
  arguments?: Maybe<Array<ConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<ConfluxSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<Event>;
  /** Transaction where event happened */
  transaction?: Maybe<ConfluxTransactionInfo>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_AnyArgs = {
  of: ConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_MaximumArgs = {
  get?: InputMaybe<ConfluxEventsMeasureable>;
  of: ConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_MinimumArgs = {
  get?: InputMaybe<ConfluxEventsMeasureable>;
  of: ConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_SmartContractEventArgs = {
  smartContractEvent?: InputMaybe<EventSelector>;
};


/** Smart Contract Events */
export type ConfluxSmartContractEvent_TransactionArgs = {
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type ConfluxSmartContractEventFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<ConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<ConfluxSmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Blockchain smart contract */
export type ConfluxSmartContractInfo = {
  __typename?: 'ConfluxSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type ConfluxSmartContractInfoWithAttribute = {
  __typename?: 'ConfluxSmartContractInfoWithAttribute';
  /** Value as address if applicable */
  address?: Maybe<ConfluxAddressInfo>;
  /** Method name */
  name: Scalars['String'];
  /** Method return type */
  type: Scalars['String'];
  /** Method return value */
  value: Scalars['String'];
};

/** Blockchain smart contract */
export type ConfluxSmartContractInfoWithAttributes = {
  __typename?: 'ConfluxSmartContractInfoWithAttributes';
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<ConfluxSmartContractInfoWithAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

/** Selector of smart contract type */
export type ConfluxSmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<SmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<SmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<SmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<SmartContractType>>;
};

export type ConfluxTransactionFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};

/** Blockchain transaction info */
export type ConfluxTransactionInfo = {
  __typename?: 'ConfluxTransactionInfo';
  /** Gas consumed */
  gas: Scalars['Int'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  /** Gas value cost */
  gasValue: Scalars['Float'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction from address */
  txFrom: ConfluxAddressInfo;
};

/** Transactions in Conflux blockchain */
export type ConfluxTransactions = {
  __typename?: 'ConfluxTransactions';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Created smart contract */
  creates?: Maybe<EthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error message if any */
  error?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_AnyArgs = {
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_BlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
  uniq?: InputMaybe<EthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
  uniq?: InputMaybe<EthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_CreatesArgs = {
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_GasArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_GasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_GasPriceArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_GasValueArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_IndexArgs = {
  txIndex?: InputMaybe<Array<TxIndexSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_MaximumArgs = {
  get?: InputMaybe<ConfluxTransactionsMeasureable>;
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_MinimumArgs = {
  get?: InputMaybe<ConfluxTransactionsMeasureable>;
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_SenderArgs = {
  txSender?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactions_ToArgs = {
  txTo?: InputMaybe<Array<ConfluxAddressSelector>>;
};

export type ConfluxTransactionsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender';

export type ConfluxTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers = {
  __typename?: 'ConfluxTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<ConfluxAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<ConfluxAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<ConfluxTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_AnyArgs = {
  of: ConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_CurrencyArgs = {
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_EntityIdArgs = {
  entityId?: InputMaybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_GasValueArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<ConfluxCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_MaximumArgs = {
  get?: InputMaybe<ConfluxTransfersMeasureable>;
  of: ConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_MinimumArgs = {
  get?: InputMaybe<ConfluxTransfersMeasureable>;
  of: ConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_ReceiverArgs = {
  receiver?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_SenderArgs = {
  sender?: InputMaybe<Array<ConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type ConfluxTransfers_TransactionArgs = {
  txFrom?: InputMaybe<Array<ConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type ConfluxTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Cosmos Blockchain */
export type Cosmos = {
  __typename?: 'Cosmos';
  /** Basic information about address */
  address: Array<CosmosAddressInfo>;
  /** Cosmos Attributes */
  attributes?: Maybe<Array<CosmosAttribute>>;
  /** Cosmos Blocks */
  blocks?: Maybe<Array<CosmosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<CosmosCoinpath>>;
  /** Cosmos Messages */
  messages?: Maybe<Array<CosmosMessage>>;
  /** Cosmos Transactions */
  transactions?: Maybe<Array<CosmosTransaction>>;
  /** Cosmos Transfers */
  transfers?: Maybe<Array<CosmosTransfers>>;
};


/** Cosmos Blockchain */
export type Cosmos_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Cosmos Blockchain */
export type Cosmos_AttributesArgs = {
  any?: InputMaybe<Array<CosmosAttributeFilter>>;
  attribute?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  eventType?: InputMaybe<StringSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageType?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<StringSelector>;
  value?: InputMaybe<StringSelector>;
  valueIndex?: InputMaybe<IntegerSelector>;
};


/** Cosmos Blockchain */
export type Cosmos_BlocksArgs = {
  any?: InputMaybe<Array<CosmosBlocksFilter>>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Cosmos Blockchain */
export type Cosmos_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<CosmosCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Cosmos Blockchain */
export type Cosmos_MessagesArgs = {
  any?: InputMaybe<Array<CosmosMessageFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Cosmos Blockchain */
export type Cosmos_TransactionsArgs = {
  any?: InputMaybe<Array<CosmosTransactionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Cosmos Blockchain */
export type Cosmos_TransfersArgs = {
  any?: InputMaybe<Array<CosmosTransferFilter>>;
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  value?: InputMaybe<AmountSelector>;
};

/** Address detailed information for Cosmos network */
export type CosmosAddressInfo = {
  __typename?: 'CosmosAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<CosmosTokensInfo>>;
};


/** Address detailed information for Cosmos network */
export type CosmosAddressInfo_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Attribute in Cosmos blockchain */
export type CosmosAttribute = {
  __typename?: 'CosmosAttribute';
  any?: Maybe<Scalars['String']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']>;
  /** Block info where transaction included */
  block?: Maybe<CosmosBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Type of the attribute */
  eventType?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message info */
  message?: Maybe<CosmosMessageDimension>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction info where message included */
  transaction?: Maybe<CosmosTransactionDimension>;
  /** Attribute value */
  value?: Maybe<Scalars['String']>;
  /** Index of attribute */
  valueIndex: Scalars['Int'];
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_AnyArgs = {
  of: CosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_CountArgs = {
  attribute?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  eventType?: InputMaybe<StringSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageType?: InputMaybe<StringSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosAttributeUniq>;
  value?: InputMaybe<StringSelector>;
  valueIndex?: InputMaybe<IntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_CountBigIntArgs = {
  attribute?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  eventType?: InputMaybe<StringSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageType?: InputMaybe<StringSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosAttributeUniq>;
  value?: InputMaybe<StringSelector>;
  valueIndex?: InputMaybe<IntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_ExpressionArgs = {
  get: Scalars['String'];
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_MaximumArgs = {
  get?: InputMaybe<CosmosAttributesMeasurable>;
  of: CosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type CosmosAttribute_MinimumArgs = {
  get?: InputMaybe<CosmosAttributesMeasurable>;
  of: CosmosAttributesMeasurable;
};

export type CosmosAttributeFilter = {
  attribute?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  eventType?: InputMaybe<StringSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageType?: InputMaybe<StringSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<StringSelector>;
  value?: InputMaybe<StringSelector>;
  valueIndex?: InputMaybe<IntegerSelector>;
};

export type CosmosAttributeUniq =
  /** Unique attributes */
  | 'attributes'
  /** Unique block hashes */
  | 'blockHashes'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique event types */
  | 'eventTypes'
  /** Unique message indices */
  | 'messageIndices'
  /** Unique message senders */
  | 'messageSenders'
  /** Unique message types */
  | 'messageTypes'
  /** Unique time */
  | 'times'
  /** Unique transaction hashes */
  | 'transactionHashes'
  /** Unique transaction indices */
  | 'transactionIndices'
  /** Unique transaction signers */
  | 'transactionSigners'
  /** Unique value indices */
  | 'valueIndices'
  /** Unique values */
  | 'values';

export type CosmosAttributesMeasurable =
  /**  attribute  */
  | 'attribute'
  /** Number of block in the blockhains */
  | 'block'
  /** Hash of the block */
  | 'blockHash'
  /** Date */
  | 'date'
  /** Type of attr */
  | 'eventType'
  /** Message index in transaction */
  | 'messageIndex'
  /** Message senders */
  | 'messageSenders'
  /** Message success */
  | 'messageSuccess'
  /** Type of message */
  | 'messageType'
  /** Time */
  | 'time'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction in block */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** attributeValue */
  | 'value'
  /** valueIndex */
  | 'valueIndex';

/** Block */
export type CosmosBlock = {
  __typename?: 'CosmosBlock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block Hash */
  hash?: Maybe<Scalars['String']>;
  /** Block Header */
  header?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proposer Address */
  proposer?: Maybe<Address>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};


/** Block */
export type CosmosBlock_AnyArgs = {
  of: CosmosBlockMeasurable;
};


/** Block */
export type CosmosBlock_CountArgs = {
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<CosmosBlockUniq>;
};


/** Block */
export type CosmosBlock_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<CosmosBlockUniq>;
};


/** Block */
export type CosmosBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type CosmosBlock_MaximumArgs = {
  get?: InputMaybe<CosmosBlockMeasurable>;
  of: CosmosBlockMeasurable;
};


/** Block */
export type CosmosBlock_MinimumArgs = {
  get?: InputMaybe<CosmosBlockMeasurable>;
  of: CosmosBlockMeasurable;
};

/** Information about block */
export type CosmosBlockDimension = {
  __typename?: 'CosmosBlockDimension';
  /** Block Hash */
  hash?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

export type CosmosBlockMeasurable =
  /** Date */
  | 'date'
  /** Block hash */
  | 'hash'
  /** Block */
  | 'height'
  /** Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type CosmosBlockUniq =
  /** Number of block in the blockchains */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Block Hash */
  | 'hashes'
  /** Block proposer */
  | 'proposers'
  /** Unique timestamps count */
  | 'times';

export type CosmosBlocksFilter = {
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

/** Coinpath */
export type CosmosCoinpath = {
  __typename?: 'CosmosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Message of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type CosmosCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type CosmosCoinpath_AnyArgs = {
  of: CosmosCoinpathMeasurable;
};


/** Coinpath */
export type CosmosCoinpath_MaximumArgs = {
  get?: InputMaybe<CosmosCoinpathMeasurable>;
  of: CosmosCoinpathMeasurable;
};


/** Coinpath */
export type CosmosCoinpath_MinimumArgs = {
  get?: InputMaybe<CosmosCoinpathMeasurable>;
  of: CosmosCoinpathMeasurable;
};

export type CosmosCoinpathMeasurable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transaction_hash';

/** Currency selector in Cosmos blockchain */
export type CosmosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Message in Cosmos blockchain */
export type CosmosMessage = {
  __typename?: 'CosmosMessage';
  any?: Maybe<Scalars['String']>;
  /** Block info where transaction included */
  block?: Maybe<CosmosBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Index in tx */
  index: Scalars['Int'];
  /** Body of message  */
  json?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction info where message included */
  transaction?: Maybe<CosmosTransactionDimension>;
  /** Type of the message */
  type?: Maybe<Scalars['String']>;
};


/** Message in Cosmos blockchain */
export type CosmosMessage_AnyArgs = {
  of: CosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type CosmosMessage_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type CosmosMessage_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type CosmosMessage_ExpressionArgs = {
  get: Scalars['String'];
};


/** Message in Cosmos blockchain */
export type CosmosMessage_MaximumArgs = {
  get?: InputMaybe<CosmosMessageMeasurable>;
  of: CosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type CosmosMessage_MinimumArgs = {
  get?: InputMaybe<CosmosMessageMeasurable>;
  of: CosmosMessageMeasurable;
};

/** Information about message */
export type CosmosMessageDimension = {
  __typename?: 'CosmosMessageDimension';
  /** Index in tx */
  index: Scalars['Int'];
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']>;
  /** Type of the message */
  type?: Maybe<Scalars['String']>;
};

export type CosmosMessageFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  senders?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
};

export type CosmosMessageMeasurable =
  /** Hash of the block */
  | 'blockHash'
  /** Number of block in the blockhains */
  | 'blockHeight'
  /** Date */
  | 'date'
  /** Message index in transaction */
  | 'index'
  /** Message json */
  | 'json'
  /** Message senders */
  | 'senders'
  /** Message success */
  | 'success'
  /** Time */
  | 'time'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** Type of message */
  | 'type';

export type CosmosMessageUniq =
  /** Uniq blocks */
  | 'blocks'
  /** Uniq date */
  | 'dates'
  /** Uniq senders */
  | 'senders'
  /** Uniq transaction hashes */
  | 'transactionHashes'
  /** Uniq transaction indices */
  | 'transactionIndices'
  /** Uniq transaction signers */
  | 'transactionSigners'
  /** Uniq types */
  | 'types';

export type CosmosNetwork =
  /** Cosmos Hub Network */
  | 'cosmoshub'
  /** Crypto.org Mainnet */
  | 'crypto_mainnet'
  /** Crypto.org Croeseid Testnet */
  | 'crypto_testnet'
  /** Heimdall (Matic Verification Network) */
  | 'heimdall'
  /** Terra Mainnet */
  | 'terra';

/** Tokens Info */
export type CosmosTokensInfo = {
  __typename?: 'CosmosTokensInfo';
  /** Token Balance */
  balance?: Maybe<Scalars['Float']>;
  /** Denom */
  denom?: Maybe<Scalars['String']>;
};

/** Transaction in Cosmos blockchain */
export type CosmosTransaction = {
  __typename?: 'CosmosTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block info where transaction included */
  block?: Maybe<CosmosBlockDimension>;
  /** code */
  code?: Maybe<Scalars['Int']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  feeDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Gas Used */
  gasUsed: Scalars['BigInt'];
  /** Gas Wanted */
  gasWanted: Scalars['BigInt'];
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Memo */
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Raw Tx */
  rawTx?: Maybe<Scalars['String']>;
  /** Transaction Signer */
  signer?: Maybe<Address>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']>;
  /** Type of the transactions */
  type?: Maybe<Scalars['String']>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_AnyArgs = {
  of: CosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<CosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_FeeArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_FeeDecimalArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_GasUsedArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_GasWantedArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_MaximumArgs = {
  get?: InputMaybe<CosmosTransactionMeasurable>;
  of: CosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type CosmosTransaction_MinimumArgs = {
  get?: InputMaybe<CosmosTransactionMeasurable>;
  of: CosmosTransactionMeasurable;
};

/** Information about transaction */
export type CosmosTransactionDimension = {
  __typename?: 'CosmosTransactionDimension';
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']>;
  /** Transaction Signer */
  signer?: Maybe<Address>;
};

export type CosmosTransactionFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  code?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<AmountSelector>;
  gasUsed?: InputMaybe<IntegerSelector>;
  gasWanted?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  memo?: InputMaybe<StringSelector>;
  signer?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};

export type CosmosTransactionMeasurable =
  /** Hash of the block */
  | 'block_hash'
  /** Number of block in the blockhains */
  | 'block_height'
  /** Transaction Code */
  | 'code'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Hash of the transaction */
  | 'hash'
  /** Transaction Index */
  | 'index'
  /** Transaction Memo */
  | 'memo'
  /** Raw Transaction */
  | 'rawTx'
  /** Transaction Signer */
  | 'signer'
  /** Time */
  | 'time'
  /** Type of the transaction */
  | 'type';

export type CosmosTransactionUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique timecodes */
  | 'codes'
  /** Unique date count */
  | 'dates'
  /** Unique hashes */
  | 'hashes'
  /** Unique indices */
  | 'indices'
  /** Unique memos */
  | 'memos'
  /** Unique signers */
  | 'signers'
  /** Unique time */
  | 'times'
  /** Unique types */
  | 'types';

export type CosmosTransferFilter = {
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  value?: InputMaybe<AmountSelector>;
};

export type CosmosTransferUniq =
  /** Unique block hashes */
  | 'blockHashes'
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique dates */
  | 'dates'
  /** Unique message indices */
  | 'messageIndices'
  /** Unique message types */
  | 'messageTypes'
  /** Unique time */
  | 'receiver'
  /** Unique senders (field sender) */
  | 'sender'
  /** Unique senders (field senders) */
  | 'senders'
  /** Unique times */
  | 'times'
  /** Unique transaction hashes */
  | 'transactionHashes'
  /** Unique transaction indices */
  | 'transactionIndices'
  /** Unique transaction signers */
  | 'transactionSigners'
  /** Unique transfer types */
  | 'types';

/** Transfers in Cosmos  blockchain */
export type CosmosTransfers = {
  __typename?: 'CosmosTransfers';
  any?: Maybe<Scalars['String']>;
  /** Block info where transaction included */
  block?: Maybe<CosmosBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Is delegated */
  delegated?: Maybe<Scalars['Boolean']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  /** Index in tx */
  messageIndex: Scalars['Int'];
  /** Type of the message */
  messageType?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']>;
  /** Transaction info where message included */
  transaction?: Maybe<CosmosTransactionDimension>;
  /** Type of the Transfer */
  type?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_AnyArgs = {
  of: CosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_CountArgs = {
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  uniq?: InputMaybe<CosmosTransferUniq>;
  value?: InputMaybe<AmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_CountBigIntArgs = {
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  uniq?: InputMaybe<CosmosTransferUniq>;
  value?: InputMaybe<AmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_MaximumArgs = {
  get?: InputMaybe<CosmosTransfersMeasurable>;
  of: CosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_MinimumArgs = {
  get?: InputMaybe<CosmosTransfersMeasurable>;
  of: CosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_ValueArgs = {
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  value?: InputMaybe<AmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type CosmosTransfers_ValueDecimalArgs = {
  block?: InputMaybe<BlockSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CosmosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  index?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  senders?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSigner?: InputMaybe<AddressSelector>;
  type?: InputMaybe<StringSelector>;
  typeTransfer?: InputMaybe<BooleanSelector>;
  value?: InputMaybe<AmountSelector>;
};

export type CosmosTransfersMeasurable =
  /** Hash of the block */
  | 'blockHash'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Message index in transaction */
  | 'messageIndex'
  /** Type of message */
  | 'messageType'
  /** Transfer To */
  | 'receiver'
  /** Transfer From */
  | 'sender'
  /** Message senders */
  | 'senders'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** Type of transfer */
  | 'type'
  /** Transfer value */
  | 'value';

/** Crypto currency ( token, coin, currency ) */
export type Currency = {
  __typename?: 'Currency';
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']>;
  /** Decimals */
  decimals: Scalars['Int'];
  /** Currency name */
  name?: Maybe<Scalars['String']>;
  /** Properties */
  properties?: Maybe<Scalars['String']>;
  /** Currency symbol */
  symbol: Scalars['String'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']>;
};

/** Currency selector */
export type CurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Instruction Data */
export type Data = {
  __typename?: 'Data';
  base58: Scalars['String'];
  hex: Scalars['String'];
};

/** Date */
export type Date = {
  __typename?: 'Date';
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int'];
  /** Month number (1-12) */
  month: Scalars['Int'];
  /**
   * Returns start of date interval ,
   *     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
   *   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
   */
  startOfInterval: Scalars['String'];
  /** Year number */
  year: Scalars['Int'];
};


/** Date */
export type Date_DateArgs = {
  format?: InputMaybe<Scalars['String']>;
};


/** Date */
export type Date_StartOfIntervalArgs = {
  format?: InputMaybe<Scalars['String']>;
  interval?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  unit: DateInterval;
};

export type DateInterval =
  /** Day */
  | 'day'
  /** Month */
  | 'month'
  /** Week */
  | 'week'
  /** Year */
  | 'year';

/** Selecting the date in a range, list or just date */
export type DateSelector = {
  /** After date */
  after?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Before date */
  before?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Range of dates */
  between?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** In dates */
  in?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** Date equals */
  is?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Date not equals */
  not?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Not in dates */
  notIn?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** Since date */
  since?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Till date */
  till?: InputMaybe<Scalars['ISO8601DateTime']>;
};

/** Date and Time */
export type DateTime = {
  __typename?: 'DateTime';
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int'];
  /** Hour (0-23) */
  hour: Scalars['Int'];
  /** ISO8601 date time such as '2020-03-02T13:30:41+00:00' */
  iso8601: Scalars['ISO8601DateTime'];
  /** Minute (0-59) */
  minute: Scalars['Int'];
  /** Month number (1-12) */
  month: Scalars['Int'];
  /** Second (0-59) */
  second: Scalars['Int'];
  /** String date representation with default format as YYYY-MM-DD */
  time: Scalars['String'];
  /** Unix timestamp */
  unixtime: Scalars['Int'];
  /** Year number */
  year: Scalars['Int'];
};


/** Date and Time */
export type DateTime_TimeArgs = {
  format?: InputMaybe<Scalars['String']>;
};

/** Selecting the time in a range, list or just time */
export type DateTimeSelector = {
  /** After time */
  after?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Before time */
  before?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Range of time */
  between?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** In times */
  in?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** Time equals */
  is?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Time not equals */
  not?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Not in times */
  notIn?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;
  /** Since time */
  since?: InputMaybe<Scalars['ISO8601DateTime']>;
  /** Till time */
  till?: InputMaybe<Scalars['ISO8601DateTime']>;
};

export type DiemNetwork =
  /** Diem Testnet */
  | 'diem_testnet'
  /** Libra Testnet */
  | 'libra_testnet';

/** Elrond Chain */
export type Elrond = {
  __typename?: 'Elrond';
  /** Basic information about address */
  address: Array<ElrondAddressInfoWithBalance>;
  /** Information about validators of the block */
  blockValidators?: Maybe<Array<ElrondBlockValidator>>;
  /** Information about blocks */
  blocks?: Maybe<Array<ElrondBlock>>;
  /** Information about calls */
  callResults?: Maybe<Array<ElrondCallResult>>;
  /** Information about Event */
  events?: Maybe<Array<ElrondEvent>>;
  /** Information about miniblocks */
  miniblocks?: Maybe<Array<ElrondMiniblock>>;
  /** Information about notarized block */
  notarizedBlock?: Maybe<Array<ElrondNotarizedBlock>>;
  /** Information about Token Operations */
  operations?: Maybe<Array<ElrondOperation>>;
  /** Information about transactions */
  transactions?: Maybe<Array<ElrondTransaction>>;
  /** Information about transactions */
  transfers?: Maybe<Array<ElrondTransfer>>;
};


/** Elrond Chain */
export type Elrond_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Elrond Chain */
export type Elrond_BlockValidatorsArgs = {
  any?: InputMaybe<Array<ElrondBlockValidatorFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  validator?: InputMaybe<HashSelector>;
};


/** Elrond Chain */
export type Elrond_BlocksArgs = {
  any?: InputMaybe<Array<ElrondBlockFilter>>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Elrond Chain */
export type Elrond_CallResultsArgs = {
  any?: InputMaybe<Array<ElrondCallResultFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  callResultData?: InputMaybe<StringSelector>;
  callResultDataOperation?: InputMaybe<StringSelector>;
  callResultGasLimit?: InputMaybe<FloatSelector>;
  callResultGasPrice?: InputMaybe<FloatSelector>;
  callResultHash?: InputMaybe<HashSelector>;
  callResultIndex?: InputMaybe<IntegerSelector>;
  callResultNonce?: InputMaybe<IntegerSelector>;
  callResultReceiver?: InputMaybe<HashSelector>;
  callResultRelayedValue?: InputMaybe<FloatSelector>;
  callResultSender?: InputMaybe<HashSelector>;
  callResultType?: InputMaybe<StringSelector>;
  callResultValue?: InputMaybe<FloatSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  previousTxHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  relayed?: InputMaybe<StringSelector>;
  returnMessage?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Elrond Chain */
export type Elrond_EventsArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<ElrondEventFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  callResultPath?: InputMaybe<StringSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  eventType?: InputMaybe<EventTypeSelector>;
  height?: InputMaybe<BlockSelector>;
  identifier?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Elrond Chain */
export type Elrond_MiniblocksArgs = {
  any?: InputMaybe<Array<ElrondMiniblockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  receiverBlockHash?: InputMaybe<HashSelector>;
  receiverShard?: InputMaybe<BigIntIdSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Elrond Chain */
export type Elrond_NotarizedBlockArgs = {
  any?: InputMaybe<Array<ElrondNotarizedBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  notarizedBlockHash?: InputMaybe<HashSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Elrond Chain */
export type Elrond_OperationsArgs = {
  any?: InputMaybe<Array<ElrondOperationFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  operationAction?: InputMaybe<StringSelector>;
  operationData?: InputMaybe<StringSelector>;
  operationIndex?: InputMaybe<IntegerSelector>;
  operationReceiver?: InputMaybe<AddressSelector>;
  operationSender?: InputMaybe<AddressSelector>;
  operationType?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Elrond Chain */
export type Elrond_TransactionsArgs = {
  actionCategory?: InputMaybe<StringSelector>;
  actionDescription?: InputMaybe<StringSelector>;
  actionName?: InputMaybe<StringSelector>;
  any?: InputMaybe<Array<ElrondTransactionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<FloatSelector>;
  function?: InputMaybe<StringSelector>;
  gasLimit?: InputMaybe<FloatSelector>;
  gasPrice?: InputMaybe<FloatSelector>;
  gasUsed?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txNonce?: InputMaybe<IntegerSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  txValue?: InputMaybe<FloatSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Elrond Chain */
export type Elrond_TransfersArgs = {
  action?: InputMaybe<ActionSelector>;
  any?: InputMaybe<Array<ElrondTransferFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  currency?: InputMaybe<CurrencySelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  epoch?: InputMaybe<IntegerSelector>;
  esdtType?: InputMaybe<StringSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  transferReceiver?: InputMaybe<AddressSelector>;
  transferSender?: InputMaybe<AddressSelector>;
  transferType?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

/** Blockchain address hash */
export type ElrondAddressHash = {
  __typename?: 'ElrondAddressHash';
  /** String hex address representation */
  hex: Scalars['String'];
};

/** Address detailed information for Elrond network */
export type ElrondAddressInfoWithBalance = {
  __typename?: 'ElrondAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']>;
  /** Extra information abount address from node */
  extraInfo?: Maybe<ElrondExtraInfo>;
  /** Staked EGLD */
  staking?: Maybe<Scalars['Float']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<ElrondTokensInfo>>;
};


/** Address detailed information for Elrond network */
export type ElrondAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Address detailed information for Elrond network */
export type ElrondAddressInfoWithBalance_StakingArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Blocks in Elrond  blockchain */
export type ElrondBlock = {
  __typename?: 'ElrondBlock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  proposer?: Maybe<ElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']>;
  /** Round */
  round?: Maybe<Scalars['BigInt']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']>;
  /** Size */
  size?: Maybe<Scalars['Int']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_AnyArgs = {
  of: ElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_CountArgs = {
  uniq?: InputMaybe<ElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_MaximumArgs = {
  get?: InputMaybe<ElrondBlocksMeasureable>;
  of: ElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlock_MinimumArgs = {
  get?: InputMaybe<ElrondBlocksMeasureable>;
  of: ElrondBlocksMeasureable;
};

/** Information about block */
export type ElrondBlockDimension = {
  __typename?: 'ElrondBlockDimension';
  /** Epoch */
  epoch?: Maybe<Scalars['Int']>;
  /** Hash of the block */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  proposer?: Maybe<ElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']>;
  /** Round */
  round?: Maybe<Scalars['BigInt']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']>;
  /** Size */
  size?: Maybe<Scalars['Int']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BigInt']>;
};

export type ElrondBlockFilter = {
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type ElrondBlockUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator = {
  __typename?: 'ElrondBlockValidator';
  any?: Maybe<Scalars['String']>;
  /** Information about blocks notarized block */
  block?: Maybe<ElrondBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Hash of validator */
  validator?: Maybe<ElrondAddressHash>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_AnyArgs = {
  of: ElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_BlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_CountArgs = {
  uniq?: InputMaybe<ElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_MaximumArgs = {
  get?: InputMaybe<ElrondBlockValidatorsMeasureable>;
  of: ElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator_MinimumArgs = {
  get?: InputMaybe<ElrondBlockValidatorsMeasureable>;
  of: ElrondBlockValidatorsMeasureable;
};

export type ElrondBlockValidatorFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  validator?: InputMaybe<HashSelector>;
};

export type ElrondBlockValidatorUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times'
  /** Unique number of validators */
  | 'validators';

export type ElrondBlockValidatorsMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count'
  /** Hash of the validator */
  | 'validator';

export type ElrondBlocksMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** CallResults in Elrond blockchain */
export type ElrondCallResult = {
  __typename?: 'ElrondCallResult';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Call result data */
  data?: Maybe<Scalars['String']>;
  /** Call result data operation */
  dataOperation?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Call result gas limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Call result gas price */
  gasPrice?: Maybe<Scalars['BigInt']>;
  /** Hash of the call result */
  hash?: Maybe<Scalars['String']>;
  /** Call result index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Nonce of the call result */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Hash of the previous transaction */
  previousTxHash?: Maybe<Scalars['String']>;
  /** Call result receiver */
  receiver?: Maybe<Address>;
  /** Call result relayed */
  relayed?: Maybe<Scalars['String']>;
  relayedValue?: Maybe<Scalars['Float']>;
  /** Call result return message */
  returnMessage?: Maybe<Scalars['String']>;
  /** Call result sender */
  sender?: Maybe<Address>;
  /** Information about calls block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<TransactionElrond>;
  /** Call result type */
  type?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_AnyArgs = {
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_CountArgs = {
  uniq?: InputMaybe<ElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_DataArgs = {
  callResultData?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_DataOperationArgs = {
  callResultDataOperation?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_ExpressionArgs = {
  get: Scalars['String'];
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_GasLimitArgs = {
  callResultGasLimit?: InputMaybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_GasPriceArgs = {
  callResultGasPrice?: InputMaybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_HashArgs = {
  callResultHash?: InputMaybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_IndexArgs = {
  callResultIndex?: InputMaybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_MaximumArgs = {
  get?: InputMaybe<ElrondCallResultsMeasureable>;
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_MiniblockArgs = {
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_MinimumArgs = {
  get?: InputMaybe<ElrondCallResultsMeasureable>;
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_NonceArgs = {
  callResultNonce?: InputMaybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_PreviousTxHashArgs = {
  previousTxHash?: InputMaybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_ReceiverArgs = {
  callResultReceiver?: InputMaybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_RelayedArgs = {
  relayed?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_RelayedValueArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callResultData?: InputMaybe<StringSelector>;
  callResultDataOperation?: InputMaybe<StringSelector>;
  callResultGasLimit?: InputMaybe<FloatSelector>;
  callResultGasPrice?: InputMaybe<FloatSelector>;
  callResultHash?: InputMaybe<HashSelector>;
  callResultIndex?: InputMaybe<IntegerSelector>;
  callResultNonce?: InputMaybe<IntegerSelector>;
  callResultReceiver?: InputMaybe<HashSelector>;
  callResultRelayedValue?: InputMaybe<FloatSelector>;
  callResultSender?: InputMaybe<HashSelector>;
  callResultType?: InputMaybe<StringSelector>;
  callResultValue?: InputMaybe<FloatSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  previousTxHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  relayed?: InputMaybe<StringSelector>;
  returnMessage?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_ReturnMessageArgs = {
  returnMessage?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_SenderArgs = {
  callResultSender?: InputMaybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_SenderBlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_TransactionArgs = {
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  signature?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_TypeArgs = {
  callResultType?: InputMaybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResult_ValueArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callResultData?: InputMaybe<StringSelector>;
  callResultDataOperation?: InputMaybe<StringSelector>;
  callResultGasLimit?: InputMaybe<FloatSelector>;
  callResultGasPrice?: InputMaybe<FloatSelector>;
  callResultHash?: InputMaybe<HashSelector>;
  callResultIndex?: InputMaybe<IntegerSelector>;
  callResultNonce?: InputMaybe<IntegerSelector>;
  callResultReceiver?: InputMaybe<HashSelector>;
  callResultRelayedValue?: InputMaybe<FloatSelector>;
  callResultSender?: InputMaybe<HashSelector>;
  callResultType?: InputMaybe<StringSelector>;
  callResultValue?: InputMaybe<FloatSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  previousTxHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  relayed?: InputMaybe<StringSelector>;
  returnMessage?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondCallResultFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  callResultData?: InputMaybe<StringSelector>;
  callResultDataOperation?: InputMaybe<StringSelector>;
  callResultGasLimit?: InputMaybe<FloatSelector>;
  callResultGasPrice?: InputMaybe<FloatSelector>;
  callResultHash?: InputMaybe<HashSelector>;
  callResultIndex?: InputMaybe<IntegerSelector>;
  callResultNonce?: InputMaybe<IntegerSelector>;
  callResultReceiver?: InputMaybe<HashSelector>;
  callResultRelayedValue?: InputMaybe<FloatSelector>;
  callResultSender?: InputMaybe<HashSelector>;
  callResultType?: InputMaybe<StringSelector>;
  callResultValue?: InputMaybe<FloatSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  previousTxHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  relayed?: InputMaybe<StringSelector>;
  returnMessage?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondCallResultUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of call results */
  | 'index'
  /** Unique time */
  | 'times';

export type ElrondCallResultsMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Data of the call result */
  | 'call_result_data'
  /** Hash of the call result */
  | 'call_result_hash'
  /** Index of the call result */
  | 'call_result_index'
  /** Receiver of the call result */
  | 'call_result_receiver'
  /** Sender of the call result */
  | 'call_result_sender'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Previous transaction hash of the call result */
  | 'previous_tx_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Events in Elrond blockchain */
export type ElrondEvent = {
  __typename?: 'ElrondEvent';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Call Result Path */
  callResultPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Identifier */
  identifier?: Maybe<Scalars['String']>;
  /** Index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Information about calls block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Data */
  topics?: Maybe<Array<Scalars['String']>>;
  /** Information about transactions */
  transaction?: Maybe<TransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_AnyArgs = {
  of: ElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type ElrondEvent_CountArgs = {
  uniq?: InputMaybe<ElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_ExpressionArgs = {
  get: Scalars['String'];
};


/** Events in Elrond blockchain */
export type ElrondEvent_MaximumArgs = {
  get?: InputMaybe<ElrondEventsMeasureable>;
  of: ElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type ElrondEvent_MiniblockArgs = {
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_MinimumArgs = {
  get?: InputMaybe<ElrondEventsMeasureable>;
  of: ElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type ElrondEvent_SenderBlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_TransactionArgs = {
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  signature?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
};


/** Events in Elrond blockchain */
export type ElrondEvent_ValueArgs = {
  address?: InputMaybe<AddressSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callResultPath?: InputMaybe<StringSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  eventType?: InputMaybe<EventTypeSelector>;
  height?: InputMaybe<BlockSelector>;
  identifier?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondEventFilter = {
  address?: InputMaybe<AddressSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  callResultPath?: InputMaybe<StringSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  eventType?: InputMaybe<EventTypeSelector>;
  height?: InputMaybe<BlockSelector>;
  identifier?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondEventUniq =
  /** Unique date count */
  | 'dates'
  /** Unique count of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type ElrondEventsMeasureable =
  /** Address */
  | 'address'
  /** Hash of the the block */
  | 'block_hash'
  /** Call Result Path */
  | 'call_result_path'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Event Index */
  | 'event_index'
  /** Event Type */
  | 'event_type'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Identifier */
  | 'identifier'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

export type ElrondExtraInfo = {
  __typename?: 'ElrondExtraInfo';
  /** Root Hash */
  rootHash?: Maybe<Scalars['String']>;
  /** Shard */
  shard?: Maybe<Scalars['BigInt']>;
  /** Transactions Count */
  txCount?: Maybe<Scalars['BigInt']>;
};

/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock = {
  __typename?: 'ElrondMiniblock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']>;
  /** Information about miniblocks block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_AnyArgs = {
  of: ElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_CountArgs = {
  uniq?: InputMaybe<ElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_MaximumArgs = {
  get?: InputMaybe<ElrondMiniblocksMeasureable>;
  of: ElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock_MinimumArgs = {
  get?: InputMaybe<ElrondMiniblocksMeasureable>;
  of: ElrondMiniblocksMeasureable;
};

export type ElrondMiniblockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  receiverBlockHash?: InputMaybe<HashSelector>;
  receiverShard?: InputMaybe<BigIntIdSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondMiniblockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type ElrondMiniblocksMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Hash of the miniblock */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Hash of the miniblocks receiver block */
  | 'receiver_block_hash'
  /** Miniblock receiver shard */
  | 'receiver_shard'
  /** Time */
  | 'time'
  /** Count of transactions */
  | 'transaction_count'
  /** Type of miniblock */
  | 'type';

export type ElrondNetwork =
  /** Elrond mainnet */
  | 'elrond';

/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock = {
  __typename?: 'ElrondNotarizedBlock';
  any?: Maybe<Scalars['String']>;
  /** Information about blocks notarized block */
  block?: Maybe<ElrondBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Hash of the notarized block */
  notarizedBlockHash?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_AnyArgs = {
  of: ElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_CountArgs = {
  uniq?: InputMaybe<ElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_MaximumArgs = {
  get?: InputMaybe<ElrondNotarizedBlocksMeasureable>;
  of: ElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock_MinimumArgs = {
  get?: InputMaybe<ElrondNotarizedBlocksMeasureable>;
  of: ElrondNotarizedBlocksMeasureable;
};

export type ElrondNotarizedBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  notarizedBlockHash?: InputMaybe<HashSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type ElrondNotarizedBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique hash of notarized block */
  | 'notarized_block_hash'
  /** Unique time */
  | 'times';

export type ElrondNotarizedBlocksMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** Notarized block hash */
  | 'notarized_block_hash'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** Operations in Elrond blockchain */
export type ElrondOperation = {
  __typename?: 'ElrondOperation';
  /** Action */
  action?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message */
  message?: Maybe<Scalars['String']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Information about calls block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<TransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']>;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_AnyArgs = {
  of: ElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_CountArgs = {
  uniq?: InputMaybe<ElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_ExpressionArgs = {
  get: Scalars['String'];
};


/** Operations in Elrond blockchain */
export type ElrondOperation_MaximumArgs = {
  get?: InputMaybe<ElrondOperationsMeasureable>;
  of: ElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_MiniblockArgs = {
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_MinimumArgs = {
  get?: InputMaybe<ElrondOperationsMeasureable>;
  of: ElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_SenderBlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Operations in Elrond blockchain */
export type ElrondOperation_TransactionArgs = {
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  signature?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
};

export type ElrondOperationFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  operationAction?: InputMaybe<StringSelector>;
  operationData?: InputMaybe<StringSelector>;
  operationIndex?: InputMaybe<IntegerSelector>;
  operationReceiver?: InputMaybe<AddressSelector>;
  operationSender?: InputMaybe<AddressSelector>;
  operationType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondOperationUniq =
  /** Unique date count */
  | 'dates'
  /** Unique count of block in the blockchains */
  | 'height'
  /** Unique count of operations */
  | 'operations'
  /** Unique time */
  | 'times';

export type ElrondOperationsMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** Operation Action */
  | 'operation_action'
  /** Operation data */
  | 'operation_data'
  /** Operation Index */
  | 'operation_index'
  /** Operation message */
  | 'operation_message'
  /** Operation receiver */
  | 'operation_receiver'
  /** Operation sender */
  | 'operation_sender'
  /** Operation type */
  | 'operation_type'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Tokens Info */
export type ElrondTokensInfo = {
  __typename?: 'ElrondTokensInfo';
  /** Token Balance */
  balance?: Maybe<Scalars['Float']>;
  /** Currency Info */
  currency?: Maybe<Currency>;
};

/** Transactions in Elrond blockchain */
export type ElrondTransaction = {
  __typename?: 'ElrondTransaction';
  /** Transaction Action */
  action?: Maybe<ElrondTransactionAction>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** Data operation */
  dataOperation?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  /** Tx function */
  function?: Maybe<Scalars['String']>;
  /** Number of gas limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Number of gas price */
  gasPrice?: Maybe<Scalars['BigInt']>;
  /** Number of gas used */
  gasUsed?: Maybe<Scalars['BigInt']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about transactions miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** TX  receiver */
  receiver?: Maybe<Address>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BigInt']>;
  /** Hash of the sender */
  sender?: Maybe<Address>;
  /** Information about transactions block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BigInt']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Tx Status */
  status?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  value?: Maybe<Scalars['Float']>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_AnyArgs = {
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_CountArgs = {
  uniq?: InputMaybe<ElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_CountBigIntArgs = {
  uniq?: InputMaybe<ElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_FeeArgs = {
  actionCategory?: InputMaybe<StringSelector>;
  actionDescription?: InputMaybe<StringSelector>;
  actionName?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<FloatSelector>;
  function?: InputMaybe<StringSelector>;
  gasLimit?: InputMaybe<FloatSelector>;
  gasPrice?: InputMaybe<FloatSelector>;
  gasUsed?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txNonce?: InputMaybe<IntegerSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  txValue?: InputMaybe<FloatSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_MaximumArgs = {
  get?: InputMaybe<ElrondTransactionsMeasureable>;
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_MinimumArgs = {
  get?: InputMaybe<ElrondTransactionsMeasureable>;
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransaction_ValueArgs = {
  actionCategory?: InputMaybe<StringSelector>;
  actionDescription?: InputMaybe<StringSelector>;
  actionName?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<FloatSelector>;
  function?: InputMaybe<StringSelector>;
  gasLimit?: InputMaybe<FloatSelector>;
  gasPrice?: InputMaybe<FloatSelector>;
  gasUsed?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txNonce?: InputMaybe<IntegerSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  txValue?: InputMaybe<FloatSelector>;
  type?: InputMaybe<StringSelector>;
};

/** Action of transction information */
export type ElrondTransactionAction = {
  __typename?: 'ElrondTransactionAction';
  /** Category */
  category?: Maybe<Scalars['String']>;
  /** Description */
  description?: Maybe<Scalars['String']>;
  /** Name */
  name?: Maybe<Scalars['String']>;
};

export type ElrondTransactionFilter = {
  actionCategory?: InputMaybe<StringSelector>;
  actionDescription?: InputMaybe<StringSelector>;
  actionName?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<FloatSelector>;
  function?: InputMaybe<StringSelector>;
  gasLimit?: InputMaybe<FloatSelector>;
  gasPrice?: InputMaybe<FloatSelector>;
  gasUsed?: InputMaybe<FloatSelector>;
  height?: InputMaybe<BlockSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  txNonce?: InputMaybe<IntegerSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  txValue?: InputMaybe<FloatSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondTransactionUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type ElrondTransactionsMeasureable =
  /** Action Category */
  | 'action_category'
  /** Action Description */
  | 'action_description'
  /** Action Name */
  | 'action_name'
  /** Hash of the the block */
  | 'block_hash'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Action Function */
  | 'function'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Transaction hash */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Type of miniblock */
  | 'type'
  /** Value */
  | 'value';

/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer = {
  __typename?: 'ElrondTransfer';
  /** Action */
  action?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Entity ID */
  entityId?: Maybe<Scalars['BigInt']>;
  /** Esdt Type */
  esdtType?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about arguments miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver account address */
  receiver?: Maybe<Address>;
  /** Sender account address */
  sender?: Maybe<Address>;
  /** Information about arguments block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about arguments transaction */
  transaction?: Maybe<TransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_AmountArgs = {
  action?: InputMaybe<ActionSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  epoch?: InputMaybe<IntegerSelector>;
  esdtType?: InputMaybe<StringSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  transferReceiver?: InputMaybe<AddressSelector>;
  transferSender?: InputMaybe<AddressSelector>;
  transferType?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_AnyArgs = {
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_CountArgs = {
  uniq?: InputMaybe<ElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_CountBigIntArgs = {
  action?: InputMaybe<ActionSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  currency?: InputMaybe<CurrencySelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  epoch?: InputMaybe<IntegerSelector>;
  esdtType?: InputMaybe<StringSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  transferReceiver?: InputMaybe<AddressSelector>;
  transferSender?: InputMaybe<AddressSelector>;
  transferType?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<ElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_CurrencyArgs = {
  currency?: InputMaybe<CurrencySelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_MaximumArgs = {
  get?: InputMaybe<ElrondTransfersMeasureable>;
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_MiniblockArgs = {
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_MinimumArgs = {
  get?: InputMaybe<ElrondTransfersMeasureable>;
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_SenderBlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  epoch?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer_TransactionArgs = {
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  signature?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  txFunction?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
};

export type ElrondTransferFilter = {
  action?: InputMaybe<ActionSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockNonce?: InputMaybe<IntegerSelector>;
  currency?: InputMaybe<CurrencySelector>;
  data?: InputMaybe<StringSelector>;
  dataOperation?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  epoch?: InputMaybe<IntegerSelector>;
  esdtType?: InputMaybe<StringSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  miniblockHash?: InputMaybe<HashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;
  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  proposer?: InputMaybe<HashSelector>;
  publicKeyBitmap?: InputMaybe<StringSelector>;
  round?: InputMaybe<IntegerSelector>;
  shard?: InputMaybe<BigIntIdSelector>;
  signature?: InputMaybe<HashSelector>;
  size?: InputMaybe<IntegerSelector>;
  sizeTxs?: InputMaybe<IntegerSelector>;
  stateRootHash?: InputMaybe<HashSelector>;
  status?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
  transferReceiver?: InputMaybe<AddressSelector>;
  transferSender?: InputMaybe<AddressSelector>;
  transferType?: InputMaybe<StringSelector>;
  txHash?: InputMaybe<HashSelector>;
  txReceiver?: InputMaybe<HashSelector>;
  txReceiverShard?: InputMaybe<BigIntIdSelector>;
  txSender?: InputMaybe<HashSelector>;
  txSenderShard?: InputMaybe<BigIntIdSelector>;
  type?: InputMaybe<StringSelector>;
};

export type ElrondTransferUniq =
  /** Unique Number of block in the blockchains */
  | 'block_height'
  /** Unique date count */
  | 'dates'
  /** Unique Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times'
  /** Unique count of transfers type */
  | 'transferType';

export type ElrondTransfersMeasureable =
  /** Action */
  | 'action'
  /** Transfer Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** ESDT Type */
  | 'esdtType'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transfer Type */
  | 'transferType'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Entity */
export type Entity = {
  __typename?: 'Entity';
  /** Entity ID */
  id: Scalars['String'];
  /** Entity number */
  num: Scalars['Int'];
  /** Entity realm ID */
  realmId: Scalars['Int'];
  /** Entity shard ID */
  shardId: Scalars['Int'];
  /** Entity Type */
  type: Scalars['String'];
};


/** Entity */
export type Entity_IdArgs = {
  entityId?: InputMaybe<Scalars['String']>;
};

/** Selector of entity ID for NFT  tokens */
export type EntitySelector = {
  /** EntityID in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** EntityID is */
  is?: InputMaybe<Scalars['String']>;
  /** EntityID not */
  not?: InputMaybe<Scalars['String']>;
  /** EntityID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type EntityTypeEnum =
  /** account */
  | 'account'
  /** contract */
  | 'contract'
  /** file */
  | 'file'
  /** schedule */
  | 'schedule'
  /** token */
  | 'token'
  /** topic */
  | 'topic';

/** Select by entity type */
export type EntityTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<EntityTypeEnum>>;
  /** Type is */
  is?: InputMaybe<EntityTypeEnum>;
  /** Type not */
  not?: InputMaybe<EntityTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<EntityTypeEnum>>;
};

/** EOS Chain */
export type Eos = {
  __typename?: 'Eos';
  /** Basic information about address ( or smart contract ) */
  address: Array<EosAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<EosAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<EosBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EosCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<EosSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<EosTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<EosTransfers>>;
};


/** EOS Chain */
export type Eos_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** EOS Chain */
export type Eos_AddressStatsArgs = {
  address: AddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** EOS Chain */
export type Eos_BlocksArgs = {
  any?: InputMaybe<Array<EosBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** EOS Chain */
export type Eos_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  finalAddress?: InputMaybe<AddressSelectorIn>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** EOS Chain */
export type Eos_SmartContractCallsArgs = {
  any?: InputMaybe<Array<EosSmartContractCallFilter>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** EOS Chain */
export type Eos_TransactionsArgs = {
  any?: InputMaybe<Array<EosTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** EOS Chain */
export type Eos_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<EosTransferFilter>>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Address detailed information for EOS network */
export type EosAddressInfo = {
  __typename?: 'EosAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EosSmartContractInfo>;
};

/** Address with statistics */
export type EosAddressStat = {
  __typename?: 'EosAddressStat';
  /** Address */
  address?: Maybe<Address>;
  /** Balance */
  balance?: Maybe<Scalars['BigInt']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BigInt']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BigInt']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BigInt']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BigInt']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BigInt']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BigInt']>;
  /** First transfer at */
  firstTransferAt?: Maybe<DateTime>;
  /** First tx at */
  firstTxAt?: Maybe<DateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<DateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<DateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BigInt']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['BigInt']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BigInt']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BigInt']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BigInt']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['BigInt']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BigInt']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BigInt']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BigInt']>;
};

/** AddressStat */
export type EosAddressStats = {
  __typename?: 'EosAddressStats';
  /** Address With Statistics */
  address?: Maybe<EosAddressStat>;
};

export type EosBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

/** Blocks in EOS blockchain */
export type EosBlocks = {
  __typename?: 'EosBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block producer */
  producer?: Maybe<Address>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_AnyArgs = {
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocks_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<EosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  proposer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<EosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in EOS blockchain */
export type EosBlocks_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_MaximumArgs = {
  get?: InputMaybe<EosBlocksMeasureable>;
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocks_MinimumArgs = {
  get?: InputMaybe<EosBlocksMeasureable>;
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocks_ProducerArgs = {
  producer?: InputMaybe<AddressSelector>;
};


/** Blocks in EOS blockchain */
export type EosBlocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};

export type EosBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type EosBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique proposer count */
  | 'proposers';

export type EosCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Sender */
  | 'tx_sender'
  /** Action To */
  | 'tx_to';

/** Coinpath */
export type EosCoinpath = {
  __typename?: 'EosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<EosCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<EosCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
};


/** Coinpath */
export type EosCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type EosCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EosCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EosCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Eos network */
export type EosCoinpathAddress = {
  __typename?: 'EosCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  amountIn?: Maybe<Scalars['DecimalNumber']>;
  amountOut?: Maybe<Scalars['DecimalNumber']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumber']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EosSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

/**
 * Currency selector in EOS blockchain.
 * Token identified by address of contract ( eosio.token for main EOS token )
 */
export type EosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type EosNetwork =
  /** EOS mainnet */
  | 'eos';

/** Eos smart contract */
export type EosSmartContract = {
  __typename?: 'EosSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EosSmartContractCallFilter = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Smart Contract Calls */
export type EosSmartContractCalls = {
  __typename?: 'EosSmartContractCalls';
  /** Actors */
  actors?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Console */
  console?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error Code */
  errorCode?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Permissions */
  permissions?: Maybe<Scalars['String']>;
  /** Receivers */
  receivers?: Maybe<Scalars['String']>;
  /** True if call scheduled */
  scheduled?: Maybe<Scalars['Boolean']>;
  /** Smart contract being called */
  smartContract?: Maybe<EosSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_AnyArgs = {
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_CountArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_ErrorCodeArgs = {
  errorCode?: InputMaybe<IntIdSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Calls */
export type EosSmartContractCalls_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_MaximumArgs = {
  get?: InputMaybe<EosCallsMeasureable>;
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_MinimumArgs = {
  get?: InputMaybe<EosCallsMeasureable>;
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_ScheduledArgs = {
  scheduled?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_SmartContractArgs = {
  smartContractAddress?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCalls_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

/** Blockchain smart contract */
export type EosSmartContractInfo = {
  __typename?: 'EosSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EosTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};

/** Transactions in EOS blockchain */
export type EosTransactions = {
  __typename?: 'EosTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  cpuUsageUs?: Maybe<Scalars['Int']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsageWords?: Maybe<Scalars['Int']>;
  /** Success */
  scheduled?: Maybe<Scalars['Boolean']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_AnyArgs = {
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  uniq?: InputMaybe<EosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  uniq?: InputMaybe<EosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_CpuUsageUsArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in EOS blockchain */
export type EosTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_IndexArgs = {
  txIndex?: InputMaybe<Array<TxIndexSelector>>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_MaximumArgs = {
  get?: InputMaybe<EosTransactionsMeasureable>;
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactions_MinimumArgs = {
  get?: InputMaybe<EosTransactionsMeasureable>;
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactions_NetUsageWordsArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_ScheduledArgs = {
  scheduled?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in EOS blockchain */
export type EosTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};

export type EosTransactionsMeasureable =
  /** Block */
  | 'block'
  /** CPU Usage */
  | 'cpu_usage_us'
  /** Date */
  | 'date'
  /** Net Usage */
  | 'net_usage_words'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type EosTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type EosTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers = {
  __typename?: 'EosTransfers';
  /** Actors */
  actors?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  /** Memo */
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_AnyArgs = {
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<EosCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_CurrencyArgs = {
  currency?: InputMaybe<EosCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_EntityIdArgs = {
  entityId?: InputMaybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_MaximumArgs = {
  get?: InputMaybe<EosTransfersMeasureable>;
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_MinimumArgs = {
  get?: InputMaybe<EosTransfersMeasureable>;
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

export type EosTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Ethereum Chain */
export type Ethereum = {
  __typename?: 'Ethereum';
  /** Ethereum Active Addresses */
  activeAddresses?: Maybe<Array<EthereumActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<EthereumAddressInfoWithBalance>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<EthereumAddressStats>>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<EthereumArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<EthereumBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EthereumCoinpath>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<EthereumDexTrades>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<EthereumReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<EthereumSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<EthereumSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<EthereumTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<EthereumTransfers>>;
};


/** Ethereum Chain */
export type Ethereum_ActiveAddressesArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Ethereum Chain */
export type Ethereum_AddressArgs = {
  address: Array<EthereumAddressSelectorIn>;
};


/** Ethereum Chain */
export type Ethereum_AddressStatsArgs = {
  address: EthereumAddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** Ethereum Chain */
export type Ethereum_ArgumentsArgs = {
  any?: InputMaybe<Array<EthereumArgumentFilter>>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Ethereum Chain */
export type Ethereum_BlocksArgs = {
  any?: InputMaybe<Array<EthereumBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  options?: InputMaybe<QueryOptions>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Ethereum Chain */
export type Ethereum_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  finalAddress?: InputMaybe<EthereumAddressSelectorIn>;
  initialAddress?: InputMaybe<EthereumAddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<EthereumAddressSelector>;
  sender?: InputMaybe<EthereumAddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Ethereum Chain */
export type Ethereum_DexTradesArgs = {
  any?: InputMaybe<Array<EthereumDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  options?: InputMaybe<QueryOptions>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Ethereum Chain */
export type Ethereum_ReferencesArgs = {
  any?: InputMaybe<Array<EthereumReferencesFilter>>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Ethereum Chain */
export type Ethereum_SmartContractCallsArgs = {
  any?: InputMaybe<Array<EthereumSmartContractCallFilter>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Ethereum Chain */
export type Ethereum_SmartContractEventsArgs = {
  any?: InputMaybe<Array<EthereumSmartContractEventFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Ethereum Chain */
export type Ethereum_TransactionsArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<EthereumTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};


/** Ethereum Chain */
export type Ethereum_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<EthereumTransferFilter>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2 = {
  __typename?: 'Ethereum2';
  /** Attestations in block */
  attestations?: Maybe<Array<Ethereum2Attestation>>;
  /** Attester Slashings */
  attesterSlashings?: Maybe<Array<Ethereum2AttesterSlashing>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<Ethereum2Blocks>>;
  /** Attestations of blocks */
  deposits?: Maybe<Array<Ethereum2Deposit>>;
  /** Proposer Slashings */
  proposerSlashings?: Maybe<Array<Ethereum2ProposerSlashing>>;
  /** Validator Updates */
  validatorUpdates?: Maybe<Array<Ethereum2ValidatorUpdates>>;
  /** Voluntary Exits */
  voluntaryExits?: Maybe<Array<Ethereum2VoluntaryExit>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_AttestationsArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  committeeIndex?: InputMaybe<Array<IntegerSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_AttesterSlashingsArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_BlocksArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_DepositsArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_ProposerSlashingsArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  slashingSlot?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_ValidatorUpdatesArgs = {
  any?: InputMaybe<Array<Ethereum2ValidatorUpdatesFilter>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2_VoluntaryExitsArgs = {
  any?: InputMaybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;
};

/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation = {
  __typename?: 'Ethereum2Attestation';
  aggregationBits: Scalars['String'];
  any?: Maybe<Scalars['String']>;
  attestation: Ethereum2AttestationInfo;
  /** Attestation Index (0 based ) in block */
  attestationIndex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  /** Committee index for attestation */
  committeeIndex: Scalars['Int'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  /** Sequential index of validator in committee ( 0-based) */
  validatorInCommitteeIndex: Scalars['Int'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_AnyArgs = {
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_CountArgs = {
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  committeeIndex?: InputMaybe<Array<IntegerSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_CountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  committeeIndex?: InputMaybe<Array<IntegerSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_ExpressionArgs = {
  get: Scalars['String'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_MaximumArgs = {
  get?: InputMaybe<Ethereum2AttestationsMeasureable>;
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_MinimumArgs = {
  get?: InputMaybe<Ethereum2AttestationsMeasureable>;
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};

/** AttestationFieldInfo for Ethereum v 2.0 network */
export type Ethereum2AttestationFieldInfo = {
  __typename?: 'Ethereum2AttestationFieldInfo';
  epoch: Scalars['Int'];
  /** Root Hash */
  root: Scalars['String'];
};

/** AttestationInfo for Ethereum v 2.0 network */
export type Ethereum2AttestationInfo = {
  __typename?: 'Ethereum2AttestationInfo';
  beaconBlockRoot: Scalars['String'];
  epoch: Scalars['Int'];
  signature: Scalars['String'];
  slot: Scalars['Int'];
  source: Ethereum2AttestationFieldInfo;
  target: Ethereum2AttestationFieldInfo;
};

export type Ethereum2AttestationsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Committee Index */
  | 'committee'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type Ethereum2AttestationsUniq =
  /** Unique attestation epochs */
  | 'attestation_epochs'
  /** Unique attestation slots */
  | 'attestation_slots'
  /** Unique attestations */
  | 'attestations'
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique commitees */
  | 'committees'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing = {
  __typename?: 'Ethereum2AttesterSlashing';
  any?: Maybe<Scalars['String']>;
  attestation: Ethereum2AttestationInfo;
  /** Attestation slashing sequential number */
  attestationOrder: Scalars['Int'];
  /** Attester Slashing Index (0 based ) in block */
  attesterSlashingIndex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  /** Validator index in slashing sequential numbern */
  validatorInAttestationIndex: Scalars['Int'];
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_AnyArgs = {
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_CountArgs = {
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_CountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;
  attestationSlot?: InputMaybe<Array<IntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_MaximumArgs = {
  get?: InputMaybe<Ethereum2AttesterSlashingMeasureable>;
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_MinimumArgs = {
  get?: InputMaybe<Ethereum2AttesterSlashingMeasureable>;
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};

export type Ethereum2AttesterSlashingMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type Ethereum2AttesterSlashingsUniq =
  /** Unique slashing epochs */
  | 'attestation_epochs'
  /** Unique slashing slots */
  | 'attestation_slots'
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks = {
  __typename?: 'Ethereum2Blocks';
  any?: Maybe<Scalars['String']>;
  attestationsCount?: Maybe<Scalars['Int']>;
  attestationsCountBigInt?: Maybe<Scalars['BigInt']>;
  attesterSlashingsCount?: Maybe<Scalars['Int']>;
  attesterSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  depositsCount?: Maybe<Scalars['Int']>;
  depositsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Epoch in blockchain */
  epoch: Scalars['Int'];
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Graffiti */
  graffiti: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  proposerSlashingsCount?: Maybe<Scalars['Int']>;
  proposerSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Randao Reveal */
  randaoReveal: Scalars['String'];
  /** Block signature */
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  voluntaryExitsCount?: Maybe<Scalars['Int']>;
  voluntaryExitsCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_AnyArgs = {
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_AttestationsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_AttestationsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_AttesterSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_AttesterSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_CountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_CountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_DepositsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_DepositsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_MaximumArgs = {
  get?: InputMaybe<Ethereum2BlocksMeasureable>;
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_MinimumArgs = {
  get?: InputMaybe<Ethereum2BlocksMeasureable>;
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_ProposerSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_ProposerSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_VoluntaryExitsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks_VoluntaryExitsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type Ethereum2BlocksMeasureable =
  /** Block */
  | 'block'
  /** Block Miner */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time';

export type Ethereum2BlocksUniq =
  /** Unique proposers */
  | 'block_proposers'
  /** Unique date count */
  | 'dates';

/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit = {
  __typename?: 'Ethereum2Deposit';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Deposit Index (0 based ) in block */
  depositIndex: Scalars['Int'];
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  proof: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_AmountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  time?: InputMaybe<DateTimeSelector>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_AnyArgs = {
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_CountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_CountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_ExpressionArgs = {
  get: Scalars['String'];
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_MaximumArgs = {
  get?: InputMaybe<Ethereum2DepositsMeasureable>;
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_MinimumArgs = {
  get?: InputMaybe<Ethereum2DepositsMeasureable>;
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};

export type Ethereum2DepositsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type Ethereum2DepositsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Eth1 attributes for Ethereum v 2.0 network */
export type Ethereum2Eth1Info = {
  __typename?: 'Ethereum2Eth1Info';
  /** Block Eth1 block hash */
  blockHash: Scalars['String'];
  /** Block Eth1 deposit count */
  depositCount: Scalars['Int'];
  /** Block Eth1 deposit root hash */
  depositRootHash: Scalars['String'];
};

export type Ethereum2Filter = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type Ethereum2Network =
  /** Beacon Chain Ethereum 2.0 */
  | 'eth2'
  /** Medalla Ethereum 2.0 Beacon Testnet */
  | 'medalla';

/** Proposer attributes for Ethereum v 2.0 network */
export type Ethereum2ProposerInfo = {
  __typename?: 'Ethereum2ProposerInfo';
  /** Proposer Index as Integer */
  index: Scalars['Int'];
  /** Proposer Pub Key */
  pubkey: Scalars['String'];
};

/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing = {
  __typename?: 'Ethereum2ProposerSlashing';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Header slashing sequential numbern */
  headerOrder: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Proposer Slashing Index (0 based ) in block */
  proposerSlashingIndex: Scalars['Int'];
  slashing: Ethereum2SlashingInfo;
  /** Block state root hash */
  stateRoot: Scalars['String'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_AnyArgs = {
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_CountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  slashingSlot?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_CountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  slashingSlot?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_ExpressionArgs = {
  get: Scalars['String'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_MaximumArgs = {
  get?: InputMaybe<Ethereum2ProposerSlashingMeasureable>;
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_MinimumArgs = {
  get?: InputMaybe<Ethereum2ProposerSlashingMeasureable>;
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};

export type Ethereum2ProposerSlashingMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Slashed Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type Ethereum2ProposerSlashingsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique slashing epochs */
  | 'slashing_epochs'
  /** Unique slashing proposers */
  | 'slashing_proposers'
  /** Unique slashing slots */
  | 'slashing_slots';

/** SlashingInfo for Ethereum v 2.0 network */
export type Ethereum2SlashingInfo = {
  __typename?: 'Ethereum2SlashingInfo';
  /** Block body hash */
  bodyRoot: Scalars['String'];
  epoch: Scalars['Int'];
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  signature: Scalars['String'];
  slot: Scalars['Int'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
};

/** Validator attributes for Ethereum v 2.0 network */
export type Ethereum2ValidatorInfo = {
  __typename?: 'Ethereum2ValidatorInfo';
  /** Validator Index as Integer */
  index: Scalars['Int'];
  /** Validator Pub Key */
  pubkey: Scalars['String'];
};

/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates = {
  __typename?: 'Ethereum2ValidatorUpdates';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRootHash: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Epoch */
  epoch: Scalars['BigInt'];
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRootHash: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ProposerInfo>;
  /** Block state root hash */
  stateRootHash: Scalars['String'];
  /** Time date */
  time?: Maybe<DateTime>;
  /** Block validator */
  validator?: Maybe<Ethereum2ValidatorInfo>;
  /** Validator activation epoch */
  validatorActivationEpoch: Scalars['BigInt'];
  /** Validator balance */
  validatorBalance?: Maybe<Scalars['Float']>;
  /** Validator balance change */
  validatorBalanceChange: Scalars['Float'];
  /** Validator effective balance */
  validatorEffectiveBalance: Scalars['Float'];
  /** Validator exit epoch */
  validatorExitEpoch: Scalars['BigInt'];
  /** Validator Slashed */
  validatorSlashed: Scalars['Boolean'];
  /** Validator Status */
  validatorStatus: Scalars['String'];
  /** Validator withdrawable epoch */
  validatorWithdrawableEpoch: Scalars['BigInt'];
  /** Validator Withdrawal Credentials */
  validatorWithdrawalCredentials: Scalars['String'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_AnyArgs = {
  of: Ethereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_CountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_CountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_ExpressionArgs = {
  get: Scalars['String'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_MaximumArgs = {
  get?: InputMaybe<Ethereum2ValidatorUpdatesMeasureable>;
  of: Ethereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_MinimumArgs = {
  get?: InputMaybe<Ethereum2ValidatorUpdatesMeasureable>;
  of: Ethereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_ValidatorBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_ValidatorBalanceChangeArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type Ethereum2ValidatorUpdates_ValidatorEffectiveBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};

export type Ethereum2ValidatorUpdatesFilter = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<HashSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<Array<StringSelector>>;
  eth1BlockHash?: InputMaybe<Array<HashSelector>>;
  eth1DepositCount?: InputMaybe<Array<IntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<HashSelector>>;
  height?: InputMaybe<BlockSelector>;
  stateRootHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<StringSelector>>;
  validatorBalance?: InputMaybe<Array<AmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<AmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<AmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<StringSelector>>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<HashSelector>>;
  validatorSlashed?: InputMaybe<Array<BooleanSelector>>;
  validatorStatus?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<StringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<HashSelector>>;
};

export type Ethereum2ValidatorUpdatesMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Epoch */
  | 'epoch'
  /** Eth1 block hash */
  | 'eth1_block_hash'
  /** Eth1 deposit count */
  | 'eth1_deposit_count'
  /** Eth1 deposit root hash */
  | 'eth1_deposit_root_hash'
  /** Parent root hash */
  | 'parent_root_hash'
  /** Proposer index */
  | 'proposer_index'
  /** Proposer pubkey hash */
  | 'proposer_pubkey_hash'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Validator activation epoch */
  | 'validator_activation_epoch'
  /** Validator balance */
  | 'validator_balance'
  /** Validator balance change */
  | 'validator_balance_change'
  /** Validator effective balance */
  | 'validator_effective_balance'
  /** Validator exit epoch */
  | 'validator_exit_epoch'
  /** Validator index */
  | 'validator_index'
  /** Validator pubkey hash */
  | 'validator_pubkey_hash'
  /** Validator slashed */
  | 'validator_slashed'
  /** Validator withdrawable epoch */
  | 'validator_withdrawable_epoch';

export type Ethereum2ValidatorUpdatesUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique epochs */
  | 'epochs'
  /** Unique proposers */
  | 'proposers'
  /** Unique validators */
  | 'validators';

/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit = {
  __typename?: 'Ethereum2VoluntaryExit';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Signature */
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  voluntaryExitEpoch: Scalars['Int'];
  /** Voluntary Exit Index (0 based ) in block */
  voluntaryExitIndex: Scalars['Int'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_AnyArgs = {
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_BlockRootArgs = {
  blockRootHash?: InputMaybe<Array<HashSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_CountArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_CountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
  blockRootHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<Ethereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_ExpressionArgs = {
  get: Scalars['String'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_MaximumArgs = {
  get?: InputMaybe<Ethereum2VoluntaryExitsMeasureable>;
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_MinimumArgs = {
  get?: InputMaybe<Ethereum2VoluntaryExitsMeasureable>;
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit_ProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;
};

export type Ethereum2VoluntaryExitsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type Ethereum2VoluntaryExitsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Address that have been active in transfers */
export type EthereumActiveAddress = {
  __typename?: 'EthereumActiveAddress';
  /** Transfer address */
  address?: Maybe<EthereumAddressInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
};


/** Address that have been active in transfers */
export type EthereumActiveAddress_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq: ActiveAddress;
};


/** Address that have been active in transfers */
export type EthereumActiveAddress_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq: ActiveAddress;
};

/** Address detailed information for Ethereum network */
export type EthereumAddressInfo = {
  __typename?: 'EthereumAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EthereumSmartContractInfo>;
};

/** Blockchain address */
export type EthereumAddressInfoWithBalance = {
  __typename?: 'EthereumAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<EthereumBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EthereumSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type EthereumAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Blockchain address */
export type EthereumAddressInfoWithBalance_BalancesArgs = {
  currency?: InputMaybe<EthereumCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelectorRange>;
  time?: InputMaybe<DateTimeSelector>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type EthereumAddressStat = {
  __typename?: 'EthereumAddressStat';
  /** Address */
  address?: Maybe<Address>;
  /** Balance */
  balance?: Maybe<Scalars['BigInt']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BigInt']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BigInt']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BigInt']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BigInt']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BigInt']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BigInt']>;
  /** Amount of paid fee */
  feeAmount?: Maybe<Scalars['BigInt']>;
  /** First transfer at */
  firstTransferAt?: Maybe<DateTime>;
  /** First tx at */
  firstTxAt?: Maybe<DateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<DateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<DateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BigInt']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['BigInt']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BigInt']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BigInt']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BigInt']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['BigInt']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BigInt']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BigInt']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BigInt']>;
};

/** AddressStats */
export type EthereumAddressStats = {
  __typename?: 'EthereumAddressStats';
  /** Address With Statistics */
  address?: Maybe<EthereumAddressStat>;
};

export type EthereumArgumentFilter = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments = {
  __typename?: 'EthereumArguments';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<EthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** @deprecated DEPRECATED! Please use ethereum { references } */
  reference?: Maybe<EthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<ArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_AnyArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_ArgumentArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_CallerArgs = {
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_CountArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_CountBigIntArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_MaximumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<EthereumArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_MinimumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<EthereumArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_NumberArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_ReferenceArgs = {
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_SmartContractSignatureArgs = {
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_TransactionArgs = {
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments_ValueArgs = {
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

export type EthereumArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type EthereumArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Balance in a currency */
export type EthereumBalance = {
  __typename?: 'EthereumBalance';
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<EthereumBalanceChange>>;
  value?: Maybe<Scalars['Float']>;
};


/** Balance in a currency */
export type EthereumBalance_ValueArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type EthereumBalanceChange = {
  __typename?: 'EthereumBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']>;
  value?: Maybe<Scalars['Float']>;
};

export type EthereumBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};

/** Blocks in Ethereum blockchain */
export type EthereumBlocks = {
  __typename?: 'EthereumBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  difficulty?: Maybe<Scalars['Float']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gasLimit?: Maybe<Scalars['Float']>;
  gasUsed?: Maybe<Scalars['Float']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block miner */
  miner?: Maybe<EthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']>;
  /** Block nonce */
  nonce: Scalars['Int'];
  /** Parent block hash */
  parentHash: Scalars['String'];
  reward?: Maybe<Scalars['Float']>;
  /** Currency of reward */
  rewardCurrency?: Maybe<Currency>;
  size?: Maybe<Scalars['Int']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalDifficulty?: Maybe<Scalars['Float']>;
  transactionCount?: Maybe<Scalars['Int']>;
  transactionCountBigInt?: Maybe<Scalars['BigInt']>;
  uncleCount?: Maybe<Scalars['Int']>;
  uncleCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_AnyArgs = {
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
  uniq?: InputMaybe<EthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
  uniq?: InputMaybe<EthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_DifficultyArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_GasLimitArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_GasUsedArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_MaximumArgs = {
  get?: InputMaybe<EthereumBlocksMeasureable>;
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_MinerArgs = {
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_MinimumArgs = {
  get?: InputMaybe<EthereumBlocksMeasureable>;
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_RewardArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_SizeArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_TotalDifficultyArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_TransactionCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_TransactionCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_UncleCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocks_UncleCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockReward?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<EthereumAddressSelector>>;
  size?: InputMaybe<Array<IntegerSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<Array<IntegerSelector>>;
  uncleCount?: InputMaybe<Array<IntegerSelector>>;
};

export type EthereumBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Block Reward */
  | 'block_reward'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Time */
  | 'time';

export type EthereumBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique miner count */
  | 'miners';

export type EthereumCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Coinpath */
export type EthereumCoinpath = {
  __typename?: 'EthereumCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<EthereumCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<EthereumCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type EthereumCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type EthereumCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EthereumCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EthereumCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type EthereumCoinpathAddress = {
  __typename?: 'EthereumCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  amountIn?: Maybe<Scalars['DecimalNumber']>;
  amountOut?: Maybe<Scalars['DecimalNumber']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumber']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EthereumSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

/**
 * Currency selector in Ethereum blockchain.
 *   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
 *   Ethereum Smart contract address should start from 0x and contain 40 hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Ethereum DEX attributes */
export type EthereumDex = {
  __typename?: 'EthereumDex';
  /** Address for DEX exchange identification */
  address: Address;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']>;
};

export type EthereumDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};

/** Trades on DEX smart contracts */
export type EthereumDexTrades = {
  __typename?: 'EthereumDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  /** Base currency */
  baseCurrency?: Maybe<Currency>;
  /** Block in the blockchain */
  block?: Maybe<BlockExtended>;
  buyAmount?: Maybe<Scalars['Float']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<Currency>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<EthereumDex>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Float']>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Trade 'maker' side */
  maker?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  /** Quote currency */
  quoteCurrency?: Maybe<Currency>;
  quotePrice?: Maybe<Scalars['Float']>;
  sellAmount?: Maybe<Scalars['Float']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<Currency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<TradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<Address>;
  /** Time interval */
  timeInterval?: Maybe<TimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<EthereumTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_AddressArgs = {
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_AnyArgs = {
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_BaseAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_BaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_BuyAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_BuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_CountArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  uniq?: InputMaybe<EthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_CountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  uniq?: InputMaybe<EthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_ExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_ExpressionArgs = {
  get: Scalars['String'];
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_GasArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_GasPriceArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_MakerArgs = {
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_MaximumArgs = {
  get?: InputMaybe<EthereumDexTradesMeasureable>;
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_MinimumArgs = {
  get?: InputMaybe<EthereumDexTradesMeasureable>;
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_PriceArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  calculate?: InputMaybe<PriceAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_ProtocolArgs = {
  protocol?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_QuoteAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_QuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_QuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  blockHash?: InputMaybe<HashSelector>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  calculate?: InputMaybe<PriceAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_SellAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_SellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_TakerArgs = {
  taker?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_TradeAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in: BaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_TradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTrades_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
};

export type EthereumDexTradesMeasureable =
  /** Block */
  | 'block'
  /** Buy Amount */
  | 'buy_amount'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Date */
  | 'date'
  /** Maker */
  | 'maker'
  /** Price */
  | 'price'
  /** Quote Price */
  | 'quote_price'
  /** Sell Amount */
  | 'sell_amount'
  /** Sell Token address */
  | 'sell_currency_address'
  /** Sell Currency symbol */
  | 'sell_currency_symbol'
  /** Taker */
  | 'taker'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type EthereumDexTradesUniq =
  /** Unique makers & takers count */
  | 'address'
  /** Base currencies count */
  | 'base_currency'
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies count */
  | 'buy_currency'
  /** Unique date count */
  | 'dates'
  /** Unique makers count */
  | 'makers'
  /** Unique protocols count */
  | 'protocols'
  /** Quote currencies count */
  | 'quote_currency'
  /** Sell currencies count */
  | 'sell_currency'
  /** Unique TX senders count */
  | 'senders'
  /** Unique smart contract count */
  | 'smart_contracts'
  /** Unique makers count */
  | 'takers'
  /** Unique transactions count */
  | 'txs';

export type EthereumEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Event Signature */
  | 'signature'
  /** Smart Contract Event Signature Hash */
  | 'signature_hash'
  /** Smart Contract Event Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type EthereumNetwork =
  /** Avalanche C-chain */
  | 'avalanche'
  /** Binance Smart Chain Mainnet */
  | 'bsc'
  /** Binance Smart Chain Testnet */
  | 'bsc_testnet'
  /** Celo Alfajores Testnet */
  | 'celo_alfajores'
  /** Celo Baklava Testnet */
  | 'celo_baklava'
  /** Celo Mainnet */
  | 'celo_mainnet'
  /** DEPRECATED. Use celo_mainnet */
  | 'celo_rc1'
  /** Cronos Mainnet */
  | 'cronos'
  /** Ethereum Classic */
  | 'ethclassic'
  /** Ethereum Classic ( no reorg from block 10904146) */
  | 'ethclassic_reorg'
  /** Ethereum Mainnet */
  | 'ethereum'
  /** Ethereum PoW */
  | 'ethpow'
  /** Fantom Mainnet */
  | 'fantom'
  /** Goerli Ethereum Testnet */
  | 'goerli'
  /** Klaytn Mainnet */
  | 'klaytn'
  /** Matic (Polygon) Mainnet */
  | 'matic'
  /** Moonbeam Mainnet */
  | 'moonbeam'
  /** Velas Mainnet */
  | 'velas'
  /** Velas Testnet */
  | 'velas_testnet';

export type EthereumReferencesFilter = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Address value of method or event argument */
export type EthereumReferencess = {
  __typename?: 'EthereumReferencess';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<EthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** Address value of method or event argument */
  reference?: Maybe<EthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type EthereumReferencess_AnyArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumReferencessMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_ArgumentArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']>;
};


/** Address value of method or event argument */
export type EthereumReferencess_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Address value of method or event argument */
export type EthereumReferencess_CallerArgs = {
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_CountArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_CountBigIntArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractArgumentsUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_ExpressionArgs = {
  get: Scalars['String'];
};


/** Address value of method or event argument */
export type EthereumReferencess_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Address value of method or event argument */
export type EthereumReferencess_MaximumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<EthereumReferencessMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumReferencessMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_MinimumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  as?: InputMaybe<EthereumReferencessConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<EthereumReferencessMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: EthereumReferencessMeasureable;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_NumberArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_ReferenceArgs = {
  reference?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_SmartContractSignatureArgs = {
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Address value of method or event argument */
export type EthereumReferencess_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Address value of method or event argument */
export type EthereumReferencess_TransactionArgs = {
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type EthereumReferencessConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type EthereumReferencessMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Ethereum smart contract */
export type EthereumSmartContract = {
  __typename?: 'EthereumSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EthereumSmartContractCallFilter = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Smart Contract Calls */
export type EthereumSmartContractCalls = {
  __typename?: 'EthereumSmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Call arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<EthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_AmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_AnyArgs = {
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_CallerArgs = {
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_CountArgs = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_CountBigIntArgs = {
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  caller?: InputMaybe<Array<EthereumAddressSelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_MaximumArgs = {
  get?: InputMaybe<EthereumCallsMeasureable>;
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_MinimumArgs = {
  get?: InputMaybe<EthereumCallsMeasureable>;
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCalls_TransactionArgs = {
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

/** Smart Contract Events */
export type EthereumSmartContractEvent = {
  __typename?: 'EthereumSmartContractEvent';
  any?: Maybe<Scalars['String']>;
  /** Event arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<Event>;
  /** Transaction where event happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_AnyArgs = {
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_MaximumArgs = {
  get?: InputMaybe<EthereumEventsMeasureable>;
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_MinimumArgs = {
  get?: InputMaybe<EthereumEventsMeasureable>;
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_SmartContractEventArgs = {
  smartContractEvent?: InputMaybe<EventSelector>;
};


/** Smart Contract Events */
export type EthereumSmartContractEvent_TransactionArgs = {
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type EthereumSmartContractEventFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractType?: InputMaybe<SmartContractTypeSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Blockchain smart contract */
export type EthereumSmartContractInfo = {
  __typename?: 'EthereumSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

/** Blockchain smart contract */
export type EthereumSmartContractInfoWithAttributes = {
  __typename?: 'EthereumSmartContractInfoWithAttributes';
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<SmartContractReadonlyAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EthereumTransactionFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};

/** Blockchain transaction info */
export type EthereumTransactionInfo = {
  __typename?: 'EthereumTransactionInfo';
  /** Gas consumed */
  gas: Scalars['Int'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  /** Gas value cost */
  gasValue: Scalars['Float'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction from address */
  txFrom: EthereumAddressInfo;
};

/** Blockchain Transaction Extended info */
export type EthereumTransactionInfoExtended = {
  __typename?: 'EthereumTransactionInfoExtended';
  /** Gas consumed */
  gas: Scalars['Int'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  /** Gas value cost */
  gasValue: Scalars['Float'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
  /** Transaction from address */
  txFrom: EthereumAddressInfo;
};

/** Transactions in Ethereum blockchain */
export type EthereumTransactions = {
  __typename?: 'EthereumTransactions';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Created smart contract */
  creates?: Maybe<EthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error message if any */
  error?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Fee payer */
  feePayer?: Maybe<Scalars['String']>;
  /** Fee ratio */
  feeRatio?: Maybe<Scalars['Int']>;
  gas?: Maybe<Scalars['Float']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
  /** Transaction type */
  txType?: Maybe<Scalars['String']>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_AnyArgs = {
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
  uniq?: InputMaybe<EthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
  uniq?: InputMaybe<EthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_CreatesArgs = {
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_GasArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_GasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_GasPriceArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_GasValueArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePayer?: InputMaybe<Array<StringSelector>>;
  feeRatio?: InputMaybe<TxIndexSelector>;
  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<AmountSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
  txType?: InputMaybe<Array<StringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_IndexArgs = {
  txIndex?: InputMaybe<Array<TxIndexSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_MaximumArgs = {
  get?: InputMaybe<EthereumTransactionsMeasureable>;
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_MinimumArgs = {
  get?: InputMaybe<EthereumTransactionsMeasureable>;
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_SenderArgs = {
  txSender?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactions_ToArgs = {
  txTo?: InputMaybe<Array<EthereumAddressSelector>>;
};

export type EthereumTransactionsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee payer */
  | 'fee_payer'
  /** Fee ratio */
  | 'fee_ratio'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type EthereumTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique fee payers count */
  | 'fee_payers'
  /** Unique fee ratios count */
  | 'fee_ratios'
  /** Unique TX receivers count */
  | 'receivers'
  /** Unique TX senders count */
  | 'senders'
  /** Unique TX types count */
  | 'tx_types';

export type EthereumTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers = {
  __typename?: 'EthereumTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<EthereumAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_AnyArgs = {
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_CurrencyArgs = {
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_EntityIdArgs = {
  entityId?: InputMaybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_GasValueArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<EthereumCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_MaximumArgs = {
  get?: InputMaybe<EthereumTransfersMeasureable>;
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_MinimumArgs = {
  get?: InputMaybe<EthereumTransfersMeasureable>;
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_ReceiverArgs = {
  receiver?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_SenderArgs = {
  sender?: InputMaybe<Array<EthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers_TransactionArgs = {
  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type EthereumTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Smart contract event */
export type Event = {
  __typename?: 'Event';
  /** Name */
  name?: Maybe<Scalars['String']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature Hash */
  signatureHash: Scalars['String'];
};

/** Smart contract event. In selector you can use the name, signature or hex hash */
export type EventSelector = {
  /** Event signature in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Event signature is */
  is?: InputMaybe<Scalars['String']>;
  /** Event signature not */
  not?: InputMaybe<Scalars['String']>;
  /** Event signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type EventType =
  /** Call Result */
  | 'call_result'
  /** Transaction */
  | 'transaction';

/** Select by event type */
export type EventTypeSelector = {
  /** Eventy type in the list */
  in?: InputMaybe<Array<EventType>>;
  /** Eventy type is */
  is?: InputMaybe<EventType>;
  /** Eventy type not */
  not?: InputMaybe<EventType>;
  /** Eventy type not in the list */
  notIn?: InputMaybe<Array<EventType>>;
};

/** Everscale Chain */
export type Everscale = {
  __typename?: 'Everscale';
  /** Information about address */
  address: Array<EverscaleAddressInfo>;
  /** Everscale Arguments */
  arguments?: Maybe<Array<EverscaleArgument>>;
  /** Everscale Blocks */
  blocks?: Maybe<Array<EverscaleBlock>>;
  /** Everscale Calls */
  calls?: Maybe<Array<EverscaleCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EverscaleCoinpath>>;
  /** Everscale Events */
  events?: Maybe<Array<EverscaleEvent>>;
  /** Everscale Messages */
  messages?: Maybe<Array<EverscaleMessage>>;
  /** Everscale Phases */
  phases?: Maybe<Array<EverscalePhase>>;
  /** Everscale Transactions */
  transactions?: Maybe<Array<EverscaleTransaction>>;
  /** Everscale Transfers */
  transfers?: Maybe<Array<EverscaleTransfer>>;
};


/** Everscale Chain */
export type Everscale_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Everscale Chain */
export type Everscale_ArgumentsArgs = {
  any?: InputMaybe<Array<EverscaleArgumentFilter>>;
  argumentField?: InputMaybe<StringSelector>;
  argumentIndex?: InputMaybe<IntegerSelector>;
  argumentType?: InputMaybe<EverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_BlocksArgs = {
  afterMerge?: InputMaybe<BooleanSelector>;
  afterSplit?: InputMaybe<BooleanSelector>;
  any?: InputMaybe<Array<EverscaleBlockFilter>>;
  beforeSplit?: InputMaybe<BooleanSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  catchainSeqno?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  globalId?: InputMaybe<IntegerSelector>;
  logicalTimeEnd?: InputMaybe<BigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BigIntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  softwareCapabilities?: InputMaybe<StringSelector>;
  softwareVersion?: InputMaybe<IntegerSelector>;
  status?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  validatorListHastShort?: InputMaybe<IntegerSelector>;
  valueFlowCreated?: InputMaybe<BigIntegerSelector>;
  valueFlowExported?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BigIntegerSelector>;
  valueFlowImported?: InputMaybe<BigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BigIntegerSelector>;
  version?: InputMaybe<BigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BigIntegerSelector>;
  wantMerge?: InputMaybe<BooleanSelector>;
  wantSplit?: InputMaybe<BooleanSelector>;
};


/** Everscale Chain */
export type Everscale_CallsArgs = {
  any?: InputMaybe<Array<EverscaleCallFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Everscale Chain */
export type Everscale_EventsArgs = {
  any?: InputMaybe<Array<EverscaleEventFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_MessagesArgs = {
  any?: InputMaybe<Array<EverscaleMessageFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageBoc?: InputMaybe<StringSelector>;
  messageBody?: InputMaybe<StringSelector>;
  messageBodyHash?: InputMaybe<StringSelector>;
  messageBounce?: InputMaybe<BooleanSelector>;
  messageBounced?: InputMaybe<BooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BigIntegerSelector>;
  messageData?: InputMaybe<StringSelector>;
  messageDataHash?: InputMaybe<StringSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<FloatSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageIhrDisabled?: InputMaybe<BooleanSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageIrbFee?: InputMaybe<FloatSelector>;
  messageReceiver?: InputMaybe<StringSelector>;
  messageSender?: InputMaybe<StringSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_PhasesArgs = {
  any?: InputMaybe<Array<EverscalePhaseFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  options?: InputMaybe<QueryOptions>;
  phaseData?: InputMaybe<StringSelector>;
  phaseFee?: InputMaybe<FloatSelector>;
  phaseType?: InputMaybe<StringSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_TransactionsArgs = {
  any?: InputMaybe<Array<EverscaleTransactionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  previousTxHash?: InputMaybe<StringSelector>;
  previousTxLogicalTime?: InputMaybe<BigIntegerSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<BooleanSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txAccountFees?: InputMaybe<FloatSelector>;
  txCreditFirst?: InputMaybe<BooleanSelector>;
  txDestroyed?: InputMaybe<BooleanSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<FloatSelector>;
  txHash?: InputMaybe<StringSelector>;
  txInMessageBounceFlag?: InputMaybe<BooleanSelector>;
  txLogicalTime?: InputMaybe<IntegerSelector>;
  txNewHash?: InputMaybe<StringSelector>;
  txOldHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<IntegerSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Everscale Chain */
export type Everscale_TransfersArgs = {
  any?: InputMaybe<Array<EverscaleTransferFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  options?: InputMaybe<QueryOptions>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleAccountStateEnum =
  /** The account`s code and data have been initialized as well. */
  | 'Active'
  /** The account`s code and data have been replaced by a hash, but the balance is still stored explicitly. The balance of a frozen account. */
  | 'Frozen'
  /** Initialized account. */
  | 'NonExist'
  /** The account only has a balance; its code and data have not yet been initialized. */
  | 'Uninit';

/** Select by account state */
export type EverscaleAccountStateSelector = {
  /** Account state in the list */
  in?: InputMaybe<Array<EverscaleAccountStateEnum>>;
  /** Account state is */
  is?: InputMaybe<EverscaleAccountStateEnum>;
  /** Account state not */
  not?: InputMaybe<EverscaleAccountStateEnum>;
  /** Account state not in the list */
  notIn?: InputMaybe<Array<EverscaleAccountStateEnum>>;
};

/** Address balance information for Everscale network */
export type EverscaleAddressBalance = {
  __typename?: 'EverscaleAddressBalance';
  /** Currency */
  currency?: Maybe<Currency>;
  value?: Maybe<Scalars['Float']>;
};


/** Address balance information for Everscale network */
export type EverscaleAddressBalance_ValueArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Address detailed information for Everscale network */
export type EverscaleAddressInfo = {
  __typename?: 'EverscaleAddressInfo';
  /** Address */
  address?: Maybe<Address>;
  /** Current address balances */
  balance?: Maybe<Array<EverscaleAddressBalance>>;
};

/** Argument in Everscale blockchain */
export type EverscaleArgument = {
  __typename?: 'EverscaleArgument';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Argument Field */
  field?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Argument Index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** messages */
  messages?: Maybe<EverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
  /** Argument Type */
  type?: Maybe<Scalars['String']>;
  /** Argument Vlaue */
  value?: Maybe<Scalars['String']>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_AnyArgs = {
  of: EverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_CountArgs = {
  argumentField?: InputMaybe<StringSelector>;
  argumentIndex?: InputMaybe<IntegerSelector>;
  argumentType?: InputMaybe<EverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_CountBigIntArgs = {
  argumentField?: InputMaybe<StringSelector>;
  argumentIndex?: InputMaybe<IntegerSelector>;
  argumentType?: InputMaybe<EverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_ExpressionArgs = {
  get: Scalars['String'];
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_MaximumArgs = {
  get?: InputMaybe<EverscaleArgumentMeasurable>;
  of: EverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_MessagesArgs = {
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_MinimumArgs = {
  get?: InputMaybe<EverscaleArgumentMeasurable>;
  of: EverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Argument in Everscale blockchain */
export type EverscaleArgument_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};

export type EverscaleArgumentFilter = {
  argumentField?: InputMaybe<StringSelector>;
  argumentIndex?: InputMaybe<IntegerSelector>;
  argumentType?: InputMaybe<EverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleArgumentMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleArgumentTypeEnum =
  /** Argument of call */
  | 'call'
  /** Argument of event */
  | 'event';

/** Select by argument type */
export type EverscaleArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<EverscaleArgumentTypeEnum>>;
  /** Argument type is */
  is?: InputMaybe<EverscaleArgumentTypeEnum>;
  /** Argument type not */
  not?: InputMaybe<EverscaleArgumentTypeEnum>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<EverscaleArgumentTypeEnum>>;
};

export type EverscaleArgumentUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Block in Everscale blockchain */
export type EverscaleBlock = {
  __typename?: 'EverscaleBlock';
  /** After Merge */
  afterMerge?: Maybe<Scalars['Boolean']>;
  /** After Split */
  afterSplit?: Maybe<Scalars['Boolean']>;
  any?: Maybe<Scalars['String']>;
  /** Before Split */
  beforeSplit?: Maybe<Scalars['Boolean']>;
  /** Boc */
  boc?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Information about block general */
  general?: Maybe<EverscaleGeneralDimension>;
  /** Global Id */
  globalId?: Maybe<Scalars['Int']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Logical Time end */
  logicalTimeEnd?: Maybe<Scalars['BigInt']>;
  /** Logical Time Start */
  logicalTimeStart?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** Minimal Reference Masterchain Block */
  minimalReferenceMasterchainBlock?: Maybe<Scalars['BigInt']>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Random Seed */
  randomSeed?: Maybe<Scalars['String']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** Status */
  status?: Maybe<Scalars['Int']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Tx Count */
  txCount?: Maybe<Scalars['BigInt']>;
  value?: Maybe<EverscaleValueDimension>;
  /** Version */
  version?: Maybe<Scalars['BigInt']>;
  /** Vertical Sequence */
  verticalSeqNo?: Maybe<Scalars['BigInt']>;
  /** Want Merge */
  wantMerge?: Maybe<Scalars['Boolean']>;
  /** Want Split */
  wantSplit?: Maybe<Scalars['Boolean']>;
  /** Proposer block hash */
  workchain?: Maybe<Scalars['BigInt']>;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_AnyArgs = {
  of: EverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_CountArgs = {
  afterMerge?: InputMaybe<BooleanSelector>;
  afterSplit?: InputMaybe<BooleanSelector>;
  beforeSplit?: InputMaybe<BooleanSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  catchainSeqno?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  globalId?: InputMaybe<IntegerSelector>;
  logicalTimeEnd?: InputMaybe<BigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BigIntegerSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  softwareCapabilities?: InputMaybe<StringSelector>;
  softwareVersion?: InputMaybe<IntegerSelector>;
  status?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<IntegerSelector>;
  valueFlowCreated?: InputMaybe<BigIntegerSelector>;
  valueFlowExported?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BigIntegerSelector>;
  valueFlowImported?: InputMaybe<BigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BigIntegerSelector>;
  version?: InputMaybe<BigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BigIntegerSelector>;
  wantMerge?: InputMaybe<BooleanSelector>;
  wantSplit?: InputMaybe<BooleanSelector>;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_CountBigIntArgs = {
  afterMerge?: InputMaybe<BooleanSelector>;
  afterSplit?: InputMaybe<BooleanSelector>;
  beforeSplit?: InputMaybe<BooleanSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  catchainSeqno?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  globalId?: InputMaybe<IntegerSelector>;
  logicalTimeEnd?: InputMaybe<BigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BigIntegerSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  softwareCapabilities?: InputMaybe<StringSelector>;
  softwareVersion?: InputMaybe<IntegerSelector>;
  status?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<IntegerSelector>;
  valueFlowCreated?: InputMaybe<BigIntegerSelector>;
  valueFlowExported?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BigIntegerSelector>;
  valueFlowImported?: InputMaybe<BigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BigIntegerSelector>;
  version?: InputMaybe<BigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BigIntegerSelector>;
  wantMerge?: InputMaybe<BooleanSelector>;
  wantSplit?: InputMaybe<BooleanSelector>;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Everscale blockchain */
export type EverscaleBlock_GeneralArgs = {
  catchainSeqno?: InputMaybe<IntegerSelector>;
  softwareCapabilities?: InputMaybe<StringSelector>;
  softwareVersion?: InputMaybe<IntegerSelector>;
  validatorListHastShort?: InputMaybe<IntegerSelector>;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_MaximumArgs = {
  get?: InputMaybe<EverscaleBlockMeasurable>;
  of: EverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_MinimumArgs = {
  get?: InputMaybe<EverscaleBlockMeasurable>;
  of: EverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Block in Everscale blockchain */
export type EverscaleBlock_ValueArgs = {
  valueFlowCreated?: InputMaybe<BigIntegerSelector>;
  valueFlowExported?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BigIntegerSelector>;
  valueFlowImported?: InputMaybe<BigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BigIntegerSelector>;
};

export type EverscaleBlockFilter = {
  afterMerge?: InputMaybe<BooleanSelector>;
  afterSplit?: InputMaybe<BooleanSelector>;
  beforeSplit?: InputMaybe<BooleanSelector>;
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  catchainSeqno?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  globalId?: InputMaybe<IntegerSelector>;
  logicalTimeEnd?: InputMaybe<BigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BigIntegerSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  softwareCapabilities?: InputMaybe<StringSelector>;
  softwareVersion?: InputMaybe<IntegerSelector>;
  status?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txCount?: InputMaybe<IntegerSelector>;
  validatorListHastShort?: InputMaybe<IntegerSelector>;
  valueFlowCreated?: InputMaybe<BigIntegerSelector>;
  valueFlowExported?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BigIntegerSelector>;
  valueFlowImported?: InputMaybe<BigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BigIntegerSelector>;
  version?: InputMaybe<BigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BigIntegerSelector>;
  wantMerge?: InputMaybe<BooleanSelector>;
  wantSplit?: InputMaybe<BooleanSelector>;
};

export type EverscaleBlockMeasurable =
  /** After Merge */
  | 'after_merge'
  /** After Split */
  | 'after_split'
  /** Before Split */
  | 'before_split'
  /** Date */
  | 'date'
  /** Global ID */
  | 'global_id'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Logical Time End */
  | 'logical_time_end'
  /** Logical Time Start */
  | 'logical_time_start'
  /** Minimal Reference Masterchain Block */
  | 'minimal_reference_masterchain_block'
  /** Previous Block */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Status */
  | 'status'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'tx_count'
  /** Value created */
  | 'value_flow_created'
  /** Value Exported */
  | 'value_flow_exported'
  /** Value Fees collected */
  | 'value_flow_fees_collected'
  /** Value Fees imported */
  | 'value_flow_fees_imported'
  /** Value From Previous Block */
  | 'value_flow_from_previous_block'
  /** Value Imported */
  | 'value_flow_imported'
  /** Value minted */
  | 'value_flow_minted'
  /** Value To Previous Block */
  | 'value_flow_to_previous_block'
  /** Version */
  | 'version'
  /** Vertical Sequence */
  | 'vertical_seq_no'
  /** Want Merge */
  | 'want_merge'
  /** Want Split */
  | 'want_split'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleBlockUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times';

/** Call in Everscale blockchain */
export type EverscaleCall = {
  __typename?: 'EverscaleCall';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** messages */
  messages?: Maybe<EverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_AnyArgs = {
  of: EverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type EverscaleCall_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_ExpressionArgs = {
  get: Scalars['String'];
};


/** Call in Everscale blockchain */
export type EverscaleCall_MaximumArgs = {
  get?: InputMaybe<EverscaleCallMeasurable>;
  of: EverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type EverscaleCall_MessagesArgs = {
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_MinimumArgs = {
  get?: InputMaybe<EverscaleCallMeasurable>;
  of: EverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type EverscaleCall_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Call in Everscale blockchain */
export type EverscaleCall_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};

export type EverscaleCallFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleCallMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleCallUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Everscale Coinpath */
export type EverscaleCoinpath = {
  __typename?: 'EverscaleCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
};


/** Everscale Coinpath */
export type EverscaleCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Everscale Coinpath */
export type EverscaleCoinpath_AnyArgs = {
  of: EverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type EverscaleCoinpath_MaximumArgs = {
  get?: InputMaybe<EverscaleCoinpathMeasureable>;
  of: EverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type EverscaleCoinpath_MinimumArgs = {
  get?: InputMaybe<EverscaleCoinpathMeasureable>;
  of: EverscaleCoinpathMeasureable;
};

export type EverscaleCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Event in Everscale blockchain */
export type EverscaleEvent = {
  __typename?: 'EverscaleEvent';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** messages */
  messages?: Maybe<EverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_AnyArgs = {
  of: EverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_ExpressionArgs = {
  get: Scalars['String'];
};


/** Event in Everscale blockchain */
export type EverscaleEvent_MaximumArgs = {
  get?: InputMaybe<EverscaleEventMeasurable>;
  of: EverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_MessagesArgs = {
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_MinimumArgs = {
  get?: InputMaybe<EverscaleEventMeasurable>;
  of: EverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Event in Everscale blockchain */
export type EverscaleEvent_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};

export type EverscaleEventFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleEventMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleEventUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** General Block information */
export type EverscaleGeneralDimension = {
  __typename?: 'EverscaleGeneralDimension';
  /** Catchain Sequence */
  catchainSeqno?: Maybe<Scalars['BigInt']>;
  /** Software capabilities */
  softwareCapabilities?: Maybe<Scalars['String']>;
  /** Software version */
  softwareVersion?: Maybe<Scalars['BigInt']>;
  /** Validator List Hast Short */
  validatorListHashShort?: Maybe<Scalars['BigInt']>;
};

/** Message in Everscale blockchain */
export type EverscaleMessage = {
  __typename?: 'EverscaleMessage';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  /** Message boc */
  boc?: Maybe<Scalars['String']>;
  /** Message body */
  body?: Maybe<Scalars['String']>;
  /** Message body hash */
  bodyHash?: Maybe<Scalars['String']>;
  /** Message Bounce */
  bounce?: Maybe<Scalars['Boolean']>;
  /** Message bounced */
  bounced?: Maybe<Scalars['Boolean']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Message created logical time */
  createdLogicalTime?: Maybe<Scalars['BigInt']>;
  /** Message data */
  data?: Maybe<Scalars['String']>;
  /** Message data hash */
  dataHash?: Maybe<Scalars['String']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Message Direction */
  direction?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Message fwd fee */
  fwdFee?: Maybe<Scalars['Float']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Message ihr disabled */
  ihrDisabled?: Maybe<Scalars['Boolean']>;
  /** Message ihr fee */
  ihrFee?: Maybe<Scalars['Float']>;
  /** Message index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Message receiver */
  receiver?: Maybe<Address>;
  /** Message sender */
  sender?: Maybe<Address>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
  /** Message Type Name */
  typeName?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_AnyArgs = {
  of: EverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageBoc?: InputMaybe<StringSelector>;
  messageBody?: InputMaybe<StringSelector>;
  messageBodyHash?: InputMaybe<StringSelector>;
  messageBounce?: InputMaybe<BooleanSelector>;
  messageBounced?: InputMaybe<BooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BigIntegerSelector>;
  messageData?: InputMaybe<StringSelector>;
  messageDataHash?: InputMaybe<StringSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<FloatSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageIhrDisabled?: InputMaybe<BooleanSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageIrbFee?: InputMaybe<FloatSelector>;
  messageReceiver?: InputMaybe<StringSelector>;
  messageSender?: InputMaybe<StringSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageBoc?: InputMaybe<StringSelector>;
  messageBody?: InputMaybe<StringSelector>;
  messageBodyHash?: InputMaybe<StringSelector>;
  messageBounce?: InputMaybe<BooleanSelector>;
  messageBounced?: InputMaybe<BooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BigIntegerSelector>;
  messageData?: InputMaybe<StringSelector>;
  messageDataHash?: InputMaybe<StringSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<FloatSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageIhrDisabled?: InputMaybe<BooleanSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageIrbFee?: InputMaybe<FloatSelector>;
  messageReceiver?: InputMaybe<StringSelector>;
  messageSender?: InputMaybe<StringSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_ExpressionArgs = {
  get: Scalars['String'];
};


/** Message in Everscale blockchain */
export type EverscaleMessage_MaximumArgs = {
  get?: InputMaybe<EverscaleMessageMeasurable>;
  of: EverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_MinimumArgs = {
  get?: InputMaybe<EverscaleMessageMeasurable>;
  of: EverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};


/** Message in Everscale blockchain */
export type EverscaleMessage_ValueArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  messageBoc?: InputMaybe<StringSelector>;
  messageBody?: InputMaybe<StringSelector>;
  messageBodyHash?: InputMaybe<StringSelector>;
  messageBounce?: InputMaybe<BooleanSelector>;
  messageBounced?: InputMaybe<BooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BigIntegerSelector>;
  messageData?: InputMaybe<StringSelector>;
  messageDataHash?: InputMaybe<StringSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<FloatSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageIhrDisabled?: InputMaybe<BooleanSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageIrbFee?: InputMaybe<FloatSelector>;
  messageReceiver?: InputMaybe<StringSelector>;
  messageSender?: InputMaybe<StringSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

/** Information about message */
export type EverscaleMessageDimension = {
  __typename?: 'EverscaleMessageDimension';
  /** Message Direction */
  direction?: Maybe<Scalars['String']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']>;
  /** Message Receiver */
  receiver?: Maybe<Address>;
  /** Message Sender */
  sender?: Maybe<Address>;
  /** Message Type */
  typeName?: Maybe<Scalars['String']>;
  /** Message value */
  value?: Maybe<Scalars['Float']>;
};

export type EverscaleMessageDirectionEnum =
  /** Inbound message */
  | 'in'
  /** Outbound Message */
  | 'out';

/** Select by message direction */
export type EverscaleMessageDirectionSelector = {
  /** Message Direction in the list */
  in?: InputMaybe<Array<EverscaleMessageDirectionEnum>>;
  /** Message Direction is */
  is?: InputMaybe<EverscaleMessageDirectionEnum>;
  /** Message Direction not */
  not?: InputMaybe<EverscaleMessageDirectionEnum>;
  /** Message Direction not in the list */
  notIn?: InputMaybe<Array<EverscaleMessageDirectionEnum>>;
};

export type EverscaleMessageFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  messageBoc?: InputMaybe<StringSelector>;
  messageBody?: InputMaybe<StringSelector>;
  messageBodyHash?: InputMaybe<StringSelector>;
  messageBounce?: InputMaybe<BooleanSelector>;
  messageBounced?: InputMaybe<BooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BigIntegerSelector>;
  messageData?: InputMaybe<StringSelector>;
  messageDataHash?: InputMaybe<StringSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<FloatSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageIhrDisabled?: InputMaybe<BooleanSelector>;
  messageIndex?: InputMaybe<IntegerSelector>;
  messageIrbFee?: InputMaybe<FloatSelector>;
  messageReceiver?: InputMaybe<StringSelector>;
  messageSender?: InputMaybe<StringSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleMessageMeasurable =
  /** Message boc */
  | 'boc'
  /** Message body */
  | 'body'
  /** Message body hash */
  | 'body_hash'
  /** Message bounce */
  | 'bounce'
  /** Message bounced */
  | 'bounced'
  /** Message created logical time */
  | 'created_logical_time'
  /** Message data */
  | 'data'
  /** Message data hash */
  | 'data_hash'
  /** Date */
  | 'date'
  /** Message fwd fee */
  | 'fwd_fee'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message Ihr Disabled */
  | 'ihr_disabled'
  /** Message ihr fee */
  | 'ihr_fee'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message Index */
  | 'message_index'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message Type Name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleMessageTypeNameEnum =
  /** ExtInt Message */
  | 'ExtInt'
  /** ExtOut Message */
  | 'ExtOut'
  /** Internal Message */
  | 'Internal';

/** Select by message type name */
export type EverscaleMessageTypeNameSelector = {
  /** Message type name in the list */
  in?: InputMaybe<Array<EverscaleMessageTypeNameEnum>>;
  /** Message type name is */
  is?: InputMaybe<EverscaleMessageTypeNameEnum>;
  /** Message type name not */
  not?: InputMaybe<EverscaleMessageTypeNameEnum>;
  /** Message type name not in the list */
  notIn?: InputMaybe<Array<EverscaleMessageTypeNameEnum>>;
};

export type EverscaleMessageUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of Message Receivers */
  | 'message_receiver'
  /** Unique Number of Message Senders */
  | 'message_sender'
  /** Unique Number of Messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

export type EverscaleNetwork =
  /** Everscale */
  | 'everscale';

/** Phase in Everscale blockchain */
export type EverscalePhase = {
  __typename?: 'EverscalePhase';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Phase data */
  data?: Maybe<Scalars['String']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
  /** Phase Type */
  type?: Maybe<Scalars['String']>;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_AnyArgs = {
  of: EverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  phaseData?: InputMaybe<StringSelector>;
  phaseFee?: InputMaybe<FloatSelector>;
  phaseType?: InputMaybe<StringSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  phaseData?: InputMaybe<StringSelector>;
  phaseFee?: InputMaybe<FloatSelector>;
  phaseType?: InputMaybe<StringSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_ExpressionArgs = {
  get: Scalars['String'];
};


/** Phase in Everscale blockchain */
export type EverscalePhase_FeeArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  phaseData?: InputMaybe<StringSelector>;
  phaseFee?: InputMaybe<FloatSelector>;
  phaseType?: InputMaybe<StringSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_MaximumArgs = {
  get?: InputMaybe<EverscalePhaseMeasurable>;
  of: EverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_MinimumArgs = {
  get?: InputMaybe<EverscalePhaseMeasurable>;
  of: EverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Phase in Everscale blockchain */
export type EverscalePhase_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};

export type EverscalePhaseFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  phaseData?: InputMaybe<StringSelector>;
  phaseFee?: InputMaybe<FloatSelector>;
  phaseType?: InputMaybe<StringSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscalePhaseMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Phase data */
  | 'phase_data'
  /** Phase fee */
  | 'phase_fee'
  /** Phase type */
  | 'phase_type'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscalePhaseUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of phases */
  | 'phases'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Information about sharded block */
export type EverscaleShardedBlockDimension = {
  __typename?: 'EverscaleShardedBlockDimension';
  /** Hash of the the master block */
  hash?: Maybe<Scalars['String']>;
  /** Number of master block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Shard master number of block */
  shard?: Maybe<Scalars['String']>;
  /** Workchain master block hash */
  workchain?: Maybe<Scalars['BigInt']>;
};

/** Transaction in Everscale blockchain */
export type EverscaleTransaction = {
  __typename?: 'EverscaleTransaction';
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']>;
  accountFees?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  /** Transaction Boc */
  boc?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction Credit First */
  creditFirst?: Maybe<Scalars['Int']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction Destroyed */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Tx Ext In And Ihr In Fees */
  extInAndIhrInFees?: Maybe<Scalars['Float']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Internal Message bounce flag */
  inMessageBounceFlag?: Maybe<Scalars['Boolean']>;
  /** Transaction Logical Time */
  logicalTime?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction New Hash */
  newHash?: Maybe<Scalars['String']>;
  /** Transaction Old Hash */
  oldHash?: Maybe<Scalars['String']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']>;
  /** Transaction Out Messages count */
  outMessagesCount?: Maybe<Scalars['Int']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Transaction Out Messages count */
  previousTxHash?: Maybe<Scalars['String']>;
  /** Transaction Previous Tx Logical Time */
  previousTxLogicalTime?: Maybe<Scalars['BigInt']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']>;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_AccountFeesArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  previousBlock?: InputMaybe<BlockSelector>;
  previousTxHash?: InputMaybe<StringSelector>;
  previousTxLogicalTime?: InputMaybe<BigIntegerSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<BooleanSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txAccountFees?: InputMaybe<FloatSelector>;
  txCreditFirst?: InputMaybe<BooleanSelector>;
  txDestroyed?: InputMaybe<BooleanSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<FloatSelector>;
  txHash?: InputMaybe<StringSelector>;
  txInMessageBounceFlag?: InputMaybe<BooleanSelector>;
  txLogicalTime?: InputMaybe<IntegerSelector>;
  txNewHash?: InputMaybe<StringSelector>;
  txOldHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<IntegerSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_AnyArgs = {
  of: EverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  previousTxHash?: InputMaybe<StringSelector>;
  previousTxLogicalTime?: InputMaybe<BigIntegerSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<BooleanSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txAccountFees?: InputMaybe<FloatSelector>;
  txCreditFirst?: InputMaybe<BooleanSelector>;
  txDestroyed?: InputMaybe<BooleanSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<FloatSelector>;
  txHash?: InputMaybe<StringSelector>;
  txInMessageBounceFlag?: InputMaybe<BooleanSelector>;
  txLogicalTime?: InputMaybe<IntegerSelector>;
  txNewHash?: InputMaybe<StringSelector>;
  txOldHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<IntegerSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  previousTxHash?: InputMaybe<StringSelector>;
  previousTxLogicalTime?: InputMaybe<BigIntegerSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<BooleanSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txAccountFees?: InputMaybe<FloatSelector>;
  txCreditFirst?: InputMaybe<BooleanSelector>;
  txDestroyed?: InputMaybe<BooleanSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<FloatSelector>;
  txHash?: InputMaybe<StringSelector>;
  txInMessageBounceFlag?: InputMaybe<BooleanSelector>;
  txLogicalTime?: InputMaybe<IntegerSelector>;
  txNewHash?: InputMaybe<StringSelector>;
  txOldHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<IntegerSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_MaximumArgs = {
  get?: InputMaybe<EverscaleTransactionMeasurable>;
  of: EverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_MinimumArgs = {
  get?: InputMaybe<EverscaleTransactionMeasurable>;
  of: EverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type EverscaleTransaction_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};

/** Information about transaction */
export type EverscaleTransactionDimension = {
  __typename?: 'EverscaleTransactionDimension';
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']>;
};

export type EverscaleTransactionFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  previousTxHash?: InputMaybe<StringSelector>;
  previousTxLogicalTime?: InputMaybe<BigIntegerSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txAborted?: InputMaybe<BooleanSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txAccountFees?: InputMaybe<FloatSelector>;
  txCreditFirst?: InputMaybe<BooleanSelector>;
  txDestroyed?: InputMaybe<BooleanSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<FloatSelector>;
  txHash?: InputMaybe<StringSelector>;
  txInMessageBounceFlag?: InputMaybe<BooleanSelector>;
  txLogicalTime?: InputMaybe<IntegerSelector>;
  txNewHash?: InputMaybe<StringSelector>;
  txOldHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<IntegerSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleTransactionMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Previous Transaction */
  | 'previous_block'
  /** Previous Tx Hash */
  | 'previous_tx_hash'
  /** Previous Tx Logical Time */
  | 'previous_tx_logical_time'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx New Hash */
  | 'tx_new_hash'
  /** Tx Old hash */
  | 'tx_old_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleTransactionUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of Transactions */
  | 'txs';

/** Transfer in Everscale blockchain */
export type EverscaleTransfer = {
  __typename?: 'EverscaleTransfer';
  amount?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** NFT Id */
  entityId: Scalars['BigInt'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** messages */
  messages?: Maybe<EverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BigInt']>;
  /** Transfer To */
  receiver: Address;
  /** Transfer From */
  sender: Address;
  /** Sharded Block Information */
  shardedBlock?: Maybe<EverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transactions */
  transactions?: Maybe<EverscaleTransactionDimension>;
  /** Transfer type */
  transferType: Scalars['String'];
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_AmountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_AmountDecimalArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_AnyArgs = {
  of: EverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<EverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_MaximumArgs = {
  get?: InputMaybe<EverscaleTransferMeasurable>;
  of: EverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_MessagesArgs = {
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_MinimumArgs = {
  get?: InputMaybe<EverscaleTransferMeasurable>;
  of: EverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_ShardedBlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  shard?: InputMaybe<StringIdSelector>;
  workchain?: InputMaybe<BigIntIdSelector>;
};


/** Transfer in Everscale blockchain */
export type EverscaleTransfer_TransactionsArgs = {
  txAborted?: InputMaybe<BigIntIdSelector>;
  txAccount?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txType?: InputMaybe<StringSelector>;
};

export type EverscaleTransferFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockHeight?: InputMaybe<BlockSelector>;
  blockShard?: InputMaybe<BigIntIdSelector>;
  blockWorkchain?: InputMaybe<BigIntIdSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  messageDirection?: InputMaybe<EverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<HashSelector>;
  messageReceiver?: InputMaybe<AddressSelector>;
  messageSender?: InputMaybe<AddressSelector>;
  messageTypeName?: InputMaybe<EverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<FloatSelector>;
  previousBlock?: InputMaybe<BlockSelector>;
  shardedBlockHash?: InputMaybe<HashSelector>;
  shardedBlockShard?: InputMaybe<BigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BigIntIdSelector>;
  shardedHeight?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferReceiver?: InputMaybe<StringSelector>;
  transferSender?: InputMaybe<StringSelector>;
  transferType?: InputMaybe<EverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<StringSelector>;
  txAccount?: InputMaybe<StringSelector>;
  txEndStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txHash?: InputMaybe<StringSelector>;
  txOriginalStatus?: InputMaybe<EverscaleAccountStateSelector>;
  txType?: InputMaybe<IntegerSelector>;
};

export type EverscaleTransferMeasurable =
  /** Currency Address */
  | 'currency_address'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Value */
  | 'value'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type EverscaleTransferTypeEnum =
  /** Token Burn */
  | 'token_burn'
  /** Token Mint */
  | 'token_mint'
  /** Token Transfers */
  | 'token_transfer'
  /** Transaction transfer */
  | 'transaction';

/** Select by message type name */
export type EverscaleTransferTypeSelector = {
  /** Transfer type name in the list */
  in?: InputMaybe<Array<EverscaleTransferTypeEnum>>;
  /** Transfer type name is */
  is?: InputMaybe<EverscaleTransferTypeEnum>;
  /** Transfer type name not */
  not?: InputMaybe<EverscaleTransferTypeEnum>;
  /** Transfer type name not in the list */
  notIn?: InputMaybe<Array<EverscaleTransferTypeEnum>>;
};

export type EverscaleTransferUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Unique Number of currencies */
  | 'currencies'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of receivers */
  | 'receivers'
  /** Unique Number of senders */
  | 'senders'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Value Block information */
export type EverscaleValueDimension = {
  __typename?: 'EverscaleValueDimension';
  /** Created */
  created?: Maybe<Scalars['BigInt']>;
  /** Exported */
  exported?: Maybe<Scalars['BigInt']>;
  /** Fees Collected */
  feesCollected?: Maybe<Scalars['BigInt']>;
  /** Fees imported */
  feesImported?: Maybe<Scalars['BigInt']>;
  /** From Previous Block */
  fromPreviousBlock?: Maybe<Scalars['BigInt']>;
  /** Imported */
  imported?: Maybe<Scalars['BigInt']>;
  /** Minted */
  minted?: Maybe<Scalars['BigInt']>;
  /** Value Flow To Next Block */
  toNextBlock?: Maybe<Scalars['BigInt']>;
};

/** Filecoin */
export type Filecoin = {
  __typename?: 'Filecoin';
  /** Basic information about address */
  address: Array<FilecoinAddressInfoWithBalance>;
  /** Filecoin Network Blocks */
  blocks?: Maybe<Array<FilecoinBlock>>;
  /** Filecoin Network Calls */
  calls?: Maybe<Array<FilecoinCalls>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<FilecoinCoinpath>>;
  /** Filecoin Network Messages ( blocks, transfers, ... ) */
  messages?: Maybe<Array<FilecoinMessages>>;
  /** Filecoin Network Currency Transfers */
  transfers?: Maybe<Array<FilecoinTransfers>>;
};


/** Filecoin */
export type Filecoin_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Filecoin */
export type Filecoin_BlocksArgs = {
  any?: InputMaybe<Array<FilecoinBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Filecoin */
export type Filecoin_CallsArgs = {
  amount?: InputMaybe<AmountSelector>;
  any?: InputMaybe<Array<FilecoinCallFilter>>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Filecoin */
export type Filecoin_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Filecoin */
export type Filecoin_MessagesArgs = {
  amount?: InputMaybe<AmountSelector>;
  any?: InputMaybe<Array<FilecoinMessageFilter>>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Filecoin */
export type Filecoin_TransfersArgs = {
  amount?: InputMaybe<AmountSelector>;
  any?: InputMaybe<Array<FilecoinTransferFilter>>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
};

/** Blockchain address */
export type FilecoinAddressInfoWithBalance = {
  __typename?: 'FilecoinAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Wallet balance */
  balance?: Maybe<Scalars['Float']>;
};


/** Blockchain address */
export type FilecoinAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Block */
export type FilecoinBlock = {
  __typename?: 'FilecoinBlock';
  any?: Maybe<Scalars['String']>;
  blockSig?: Maybe<NameWithId>;
  blsAggregate?: Maybe<NameWithId>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  electionProof?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  forkSignalling?: Maybe<Scalars['BigInt']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block round in blockchain */
  height: Scalars['Int'];
  /** Block index on height */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  messageCount?: Maybe<Scalars['Int']>;
  messageCountBigInt?: Maybe<Scalars['BigInt']>;
  messages?: Maybe<Scalars['String']>;
  /** Miner */
  miner?: Maybe<Address>;
  minerTips?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['String']>;
  parentMessageReceipts?: Maybe<Scalars['String']>;
  parentStateRoot?: Maybe<Scalars['String']>;
  parentWeight?: Maybe<Scalars['BigInt']>;
  reward?: Maybe<Scalars['Float']>;
  ticket?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalReward?: Maybe<Scalars['Float']>;
  winCount?: Maybe<Scalars['Int']>;
  winCountBigInt?: Maybe<Scalars['BigInt']>;
  wincount?: Maybe<Scalars['Int']>;
};


/** Block */
export type FilecoinBlock_AnyArgs = {
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlock_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinBlockUniq>;
};


/** Block */
export type FilecoinBlock_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinBlockUniq>;
};


/** Block */
export type FilecoinBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type FilecoinBlock_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Block */
export type FilecoinBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block */
export type FilecoinBlock_IndexArgs = {
  blockIndex?: InputMaybe<IntegerSelector>;
};


/** Block */
export type FilecoinBlock_MaximumArgs = {
  get?: InputMaybe<FilecoinBlocksMeasureable>;
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlock_MessageCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_MessageCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_MinerArgs = {
  miner?: InputMaybe<AddressSelector>;
};


/** Block */
export type FilecoinBlock_MinerTipsArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_MinimumArgs = {
  get?: InputMaybe<FilecoinBlocksMeasureable>;
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlock_RewardArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_TotalRewardArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_WinCountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlock_WinCountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};

export type FilecoinBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  blockIndex?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
};

export type FilecoinBlockUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique block height count */
  | 'heights'
  /** Miner */
  | 'miners';

export type FilecoinBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Time */
  | 'time';

export type FilecoinCallFilter = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

/** Calls in Filecoin blockchain */
export type FilecoinCalls = {
  __typename?: 'FilecoinCalls';
  amount?: Maybe<Scalars['Float']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer Message is included */
  block?: Maybe<Block>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  exitCode?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Int']>;
  gasFeeCap?: Maybe<Scalars['BigInt']>;
  gasLimit?: Maybe<Scalars['BigInt']>;
  gasPremium?: Maybe<Scalars['Float']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message Method */
  messageMethod?: Maybe<NameWithId>;
  /** Method */
  method?: Maybe<NameWithId>;
  minedBlock?: Maybe<FilecoinMinedBlock>;
  minimum?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['BigInt']>;
  /** Message receiver */
  receiver?: Maybe<AddressWithAccount>;
  returnValue?: Maybe<Scalars['String']>;
  /** Message sender */
  sender?: Maybe<AddressWithAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_AmountArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_AmountDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_AnyArgs = {
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_CountArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_CountBigIntArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_GasArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_HashArgs = {
  hash?: InputMaybe<HashSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_MaximumArgs = {
  get?: InputMaybe<FilecoinCallsMeasureable>;
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_MessageMethodArgs = {
  messageMethod?: InputMaybe<IntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_MethodArgs = {
  method?: InputMaybe<IntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_MinimumArgs = {
  get?: InputMaybe<FilecoinCallsMeasureable>;
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCalls_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};

export type FilecoinCallsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas limit */
  | 'gas_limit'
  /** Gas value */
  | 'gas_value'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time';

/** Coinpath */
export type FilecoinCoinpath = {
  __typename?: 'FilecoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message of transfer happened */
  message?: Maybe<TransactionHashValue>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
};


/** Coinpath */
export type FilecoinCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type FilecoinCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type FilecoinCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type FilecoinCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export type FilecoinMessageFilter = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};

/** Messages in Filecoin blockchain */
export type FilecoinMessages = {
  __typename?: 'FilecoinMessages';
  amount?: Maybe<Scalars['Float']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  baseFeeBurn?: Maybe<Scalars['Float']>;
  baseFeeBurnDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Block where transfer Message is included */
  block?: Maybe<Block>;
  burned?: Maybe<Scalars['Float']>;
  burnedDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  exitCode?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Int']>;
  gasBigInt?: Maybe<Scalars['BigInt']>;
  gasFeeCap?: Maybe<Scalars['BigInt']>;
  gasLimit?: Maybe<Scalars['BigInt']>;
  gasPremium?: Maybe<Scalars['Float']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Method */
  method?: Maybe<NameWithId>;
  minedBlock?: Maybe<FilecoinMinedBlock>;
  minerPenalty?: Maybe<Scalars['Float']>;
  minerPenaltyDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  minerTip?: Maybe<Scalars['Float']>;
  minerTipDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  minimum?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['BigInt']>;
  overEstimationBurn?: Maybe<Scalars['Float']>;
  overEstimationBurnDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Message receiver */
  receiver?: Maybe<AddressWithAccount>;
  refund?: Maybe<Scalars['Float']>;
  refundDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  returnValue?: Maybe<Scalars['String']>;
  /** Message sender */
  sender?: Maybe<AddressWithAccount>;
  signature?: Maybe<Scalars['String']>;
  signatureType?: Maybe<Scalars['String']>;
  /** Signed Message hash */
  signedHash?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  totalCost?: Maybe<Scalars['Float']>;
  totalCostDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_AmountArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_AmountDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_AnyArgs = {
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_BaseFeeBurnArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_BaseFeeBurnDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_BurnedArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_BurnedDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_CountArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_CountBigIntArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_ExpressionArgs = {
  get: Scalars['String'];
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_GasArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_GasBigIntArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_HashArgs = {
  hash?: InputMaybe<HashSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MaximumArgs = {
  get?: InputMaybe<FilecoinMessagesMeasureable>;
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MethodArgs = {
  method?: InputMaybe<IntegerSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MinerPenaltyArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MinerPenaltyDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MinerTipArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MinerTipDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_MinimumArgs = {
  get?: InputMaybe<FilecoinMessagesMeasureable>;
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_OverEstimationBurnArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_OverEstimationBurnDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_RefundArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_RefundDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_TotalCostArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessages_TotalCostDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type FilecoinMessagesMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas limit */
  | 'gas_limit'
  /** Gas value */
  | 'gas_value'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time';

export type FilecoinMessagesUniq =
  /** Unique block heights */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique Message receivers */
  | 'receivers'
  /** Unique Message senders */
  | 'senders';

/** Filecoin Mined Block */
export type FilecoinMinedBlock = {
  __typename?: 'FilecoinMinedBlock';
  /** Hash */
  hash?: Maybe<Scalars['String']>;
  /** Index on height */
  index?: Maybe<Scalars['Int']>;
  /** Miner */
  miner?: Maybe<Address>;
};

export type FilecoinNetwork =
  /** Filecoin Mainnet */
  | 'filecoin';

export type FilecoinTransferFilter = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
};

export type FilecoinTransferType =
  /** Burn */
  | 'burn'
  /** Genesis */
  | 'genesis'
  /** Miner Tip */
  | 'miner'
  /** Rebalance */
  | 'rebalance'
  /** Reward */
  | 'reward'
  /** Send (transfer) */
  | 'send';

/** Transfers in Filecoin blockchain */
export type FilecoinTransfers = {
  __typename?: 'FilecoinTransfers';
  amount?: Maybe<Scalars['Float']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer Transfer is included */
  block?: Maybe<BlockExtended>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message Method */
  messageMethod?: Maybe<NameWithId>;
  /** Method */
  method?: Maybe<NameWithId>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer timestamp */
  timestamp?: Maybe<DateTime>;
  /** Type of transfer */
  transferType?: Maybe<FilecoinTransferType>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_AmountArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_AmountDecimalArgs = {
  amount?: InputMaybe<AmountSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_AnyArgs = {
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_CountArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_CountBigIntArgs = {
  amount?: InputMaybe<AmountSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  messageMethod?: InputMaybe<IntegerSelector>;
  method?: InputMaybe<IntegerSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transferType?: InputMaybe<TransferTypeSelector>;
  uniq?: InputMaybe<FilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_HashArgs = {
  hash?: InputMaybe<HashSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_MaximumArgs = {
  get?: InputMaybe<FilecoinTransfersMeasureable>;
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_MessageMethodArgs = {
  messageMethod?: InputMaybe<IntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_MethodArgs = {
  method?: InputMaybe<IntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_MinimumArgs = {
  get?: InputMaybe<FilecoinTransfersMeasureable>;
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfers_TransferTypeArgs = {
  transferType?: InputMaybe<TransferTypeSelector>;
};

export type FilecoinTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type';

/** Select by number */
export type FloatSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Float']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Float']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Float']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Float']>>;
  /** is */
  is?: InputMaybe<Scalars['Float']>;
  /** less than */
  lt?: InputMaybe<Scalars['Float']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Float']>;
  /** not */
  not?: InputMaybe<Scalars['Float']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

/** Flow Chain */
export type Flow = {
  __typename?: 'Flow';
  /** Basic information about address */
  address: Array<FlowAddressInfoWithBalance>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  arguments?: Maybe<Array<FlowArgument>>;
  /**
   * A block seal is an attestation that the execution result of a specific block has
   *                    been verified and approved by a quorum of verification nodes.
   */
  blockSeals?: Maybe<Array<FlowBlockSeal>>;
  /** Full block information. */
  blocks?: Maybe<Array<FlowBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<FlowCoinpath>>;
  /** A collection is a batch of transactions that have been includes in a block. */
  collections?: Maybe<Array<FlowCollection>>;
  /** Event fields */
  eventFields?: Maybe<Array<FlowEventField>>;
  /**
   * An event is emitted as the result of a transaction execution.
   *         Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.
   */
  events?: Maybe<Array<FlowEvent>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<FlowInput>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<FlowOutput>>;
  /** List of transaction authorizers */
  transactionAuthorizers?: Maybe<Array<FlowTransactionAuthorizer>>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  transactionEnvelopeSignatures?: Maybe<Array<FlowTransactionEnvelopeSignature>>;
  /**
   * The transaction authorization envelope contains both the
   *                    transaction payload and the payload signatures.
   */
  transactionPayloadSignatures?: Maybe<Array<FlowTransactionPayloadSignature>>;
  /** A transaction represents a unit of computation that is submitted to the Flow network. */
  transactions?: Maybe<Array<FlowTransaction>>;
};


/** Flow Chain */
export type Flow_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Flow Chain */
export type Flow_ArgumentsArgs = {
  any?: InputMaybe<Array<FlowArgumentFilter>>;
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
  value?: InputMaybe<StringSelector>;
  valueAsFix?: InputMaybe<IntegerSelector>;
  valueAsInt?: InputMaybe<IntegerSelector>;
};


/** Flow Chain */
export type Flow_BlockSealsArgs = {
  any?: InputMaybe<Array<FlowBlockSealFilter>>;
  blockId?: InputMaybe<HashSelector>;
  blockSealId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  executionReceiptId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Flow Chain */
export type Flow_BlocksArgs = {
  any?: InputMaybe<Array<FlowBlockFilter>>;
  collectionsCount?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  id?: InputMaybe<HashSelector>;
  options?: InputMaybe<QueryOptions>;
  parentBlockId?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionsCount?: InputMaybe<IntegerSelector>;
};


/** Flow Chain */
export type Flow_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Flow Chain */
export type Flow_CollectionsArgs = {
  any?: InputMaybe<Array<FlowCollectionFilter>>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  transactionsCount?: InputMaybe<IntegerSelector>;
};


/** Flow Chain */
export type Flow_EventFieldsArgs = {
  any?: InputMaybe<Array<FlowEventFieldFilter>>;
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  fieldAsFix?: InputMaybe<IntegerSelector>;
  fieldAsInt?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Flow Chain */
export type Flow_EventsArgs = {
  any?: InputMaybe<Array<FlowEventFilter>>;
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Flow Chain */
export type Flow_InputsArgs = {
  address?: InputMaybe<StringSelector>;
  any?: InputMaybe<Array<FlowInputFilter>>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Flow Chain */
export type Flow_OutputsArgs = {
  address?: InputMaybe<StringSelector>;
  any?: InputMaybe<Array<FlowOutputFilter>>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Flow Chain */
export type Flow_TransactionAuthorizersArgs = {
  any?: InputMaybe<Array<FlowTransactionAuthorizerFilter>>;
  authorizer?: InputMaybe<AddressSelector>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};


/** Flow Chain */
export type Flow_TransactionEnvelopeSignaturesArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<FlowTransactionEnvelopeSignatureFilter>>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  keyId?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};


/** Flow Chain */
export type Flow_TransactionPayloadSignaturesArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<FlowTransactionPayloadSignatureFilter>>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  keyId?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};


/** Flow Chain */
export type Flow_TransactionsArgs = {
  any?: InputMaybe<Array<FlowTransactionFilter>>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

/** Blockchain address */
export type FlowAddressInfoWithBalance = {
  __typename?: 'FlowAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** FLOW currency balance */
  balance?: Maybe<Scalars['Float']>;
};


/** Blockchain address */
export type FlowAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Arguments in Flow blockchain */
export type FlowArgument = {
  __typename?: 'FlowArgument';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Index of the argument inside transaction */
  index: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction information */
  transaction: FlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String'];
  /** Value */
  value: Scalars['String'];
  valueAsFix?: Maybe<Scalars['Float']>;
  /** Value converted to integer */
  valueAsInt: Scalars['Int'];
};


/** Arguments in Flow blockchain */
export type FlowArgument_AnyArgs = {
  of: FlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type FlowArgument_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Arguments in Flow blockchain */
export type FlowArgument_CountArgs = {
  uniq?: InputMaybe<FlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type FlowArgument_CountBigIntArgs = {
  uniq?: InputMaybe<FlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type FlowArgument_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments in Flow blockchain */
export type FlowArgument_MaximumArgs = {
  get?: InputMaybe<FlowArgumentMeasureable>;
  of: FlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type FlowArgument_MinimumArgs = {
  get?: InputMaybe<FlowArgumentMeasureable>;
  of: FlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type FlowArgument_TransactionArgs = {
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
};


/** Arguments in Flow blockchain */
export type FlowArgument_ValueAsFixArgs = {
  blockId?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
  value?: InputMaybe<StringSelector>;
  valueAsFix?: InputMaybe<IntegerSelector>;
  valueAsInt?: InputMaybe<IntegerSelector>;
};

export type FlowArgumentFilter = {
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
  value?: InputMaybe<StringSelector>;
  valueAsFix?: InputMaybe<IntegerSelector>;
  valueAsInt?: InputMaybe<IntegerSelector>;
};

export type FlowArgumentMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'transaction_id'
  /** Type */
  | 'type'
  /** Value */
  | 'value'
  /** Value with UFix64 type and converted to integer */
  | 'value_as_fix';

export type FlowArgumentUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

/** Block in Flow blockchain */
export type FlowBlock = {
  __typename?: 'FlowBlock';
  any?: Maybe<Scalars['String']>;
  /** 	BLS signatures of consensus nodes */
  blockSignatures?: Maybe<Array<Scalars['String']>>;
  /** Count of collections */
  collectionsCount?: Maybe<Scalars['Int']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BigInt']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** ID of the previous block in the chain */
  parentBlockId?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions */
  transactionsCount?: Maybe<Scalars['Int']>;
};


/** Block in Flow blockchain */
export type FlowBlock_AnyArgs = {
  of: FlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type FlowBlock_CountArgs = {
  uniq?: InputMaybe<FlowBlockUniq>;
};


/** Block in Flow blockchain */
export type FlowBlock_CountBigIntArgs = {
  uniq?: InputMaybe<FlowBlockUniq>;
};


/** Block in Flow blockchain */
export type FlowBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Flow blockchain */
export type FlowBlock_MaximumArgs = {
  get?: InputMaybe<FlowBlockMeasureable>;
  of: FlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type FlowBlock_MinimumArgs = {
  get?: InputMaybe<FlowBlockMeasureable>;
  of: FlowBlockMeasureable;
};

export type FlowBlockDimension = {
  __typename?: 'FlowBlockDimension';
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BigInt']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']>;
};

export type FlowBlockFilter = {
  collectionsCount?: InputMaybe<IntegerSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  id?: InputMaybe<HashSelector>;
  parentBlockId?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionsCount?: InputMaybe<IntegerSelector>;
};

export type FlowBlockMeasureable =
  /** Count of collections */
  | 'collections_count'
  /** Date */
  | 'date'
  /** Height of the block in the chain */
  | 'height'
  /** SHA3-256 hash of the entire block payload */
  | 'id'
  /** ID of the previous block in the chain */
  | 'parent_block_id'
  /** Time */
  | 'time'
  /** Count of transactions */
  | 'transactions_count';

/** Block seals in Flow blockchain */
export type FlowBlockSeal = {
  __typename?: 'FlowBlockSeal';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** ID execution receipt being sealed */
  executionReceiptId?: Maybe<Scalars['String']>;
  /** BLS signatures of verification nodes on the execution receipt contents */
  executionReceiptSignatures?: Maybe<Array<Scalars['String']>>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Index inside block */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** BLS signatures of verification nodes on the result approval contents */
  resultApprovalSignatures?: Maybe<Array<Scalars['String']>>;
  /** ID of the block being sealed */
  sealId?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_AnyArgs = {
  of: FlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_CountArgs = {
  uniq?: InputMaybe<FlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_CountBigIntArgs = {
  uniq?: InputMaybe<FlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_MaximumArgs = {
  get?: InputMaybe<FlowBlockSealsMeasureable>;
  of: FlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type FlowBlockSeal_MinimumArgs = {
  get?: InputMaybe<FlowBlockSealsMeasureable>;
  of: FlowBlockSealsMeasureable;
};

export type FlowBlockSealFilter = {
  blockId?: InputMaybe<HashSelector>;
  blockSealId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  executionReceiptId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type FlowBlockSealUniq =
  /** Unique number of sealed blocks */
  | 'block_seal_id'
  /** Unique date count */
  | 'dates'
  /** ID execution receipt being sealed */
  | 'execution_receipt_id'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type FlowBlockSealsMeasureable =
  /** SHA3-256 hash of the entire block payload */
  | 'block_id'
  /** ID of the block being sealed */
  | 'block_seal_id'
  /** Date */
  | 'date'
  /** ID execution receipt being sealed */
  | 'execution_receipt_id'
  /** Height of the block in the chain */
  | 'height'
  /** Time */
  | 'time';

export type FlowBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** FlowCoinpath */
export type FlowCoinpath = {
  __typename?: 'FlowCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<FlowTransactionHashIndexValues>;
};


/** FlowCoinpath */
export type FlowCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** FlowCoinpath */
export type FlowCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** FlowCoinpath */
export type FlowCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** FlowCoinpath */
export type FlowCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Collections in Flow blockchain */
export type FlowCollection = {
  __typename?: 'FlowCollection';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** SHA3-256 hash of the collection contents */
  id?: Maybe<Scalars['String']>;
  /** Index of collection inside block */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** BLS signatures of the collection nodes guaranteeing the collection */
  signatures?: Maybe<Array<Scalars['String']>>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions inside collection */
  transactionsCount?: Maybe<Scalars['Int']>;
};


/** Collections in Flow blockchain */
export type FlowCollection_AnyArgs = {
  of: FlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type FlowCollection_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Collections in Flow blockchain */
export type FlowCollection_CountArgs = {
  uniq?: InputMaybe<FlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type FlowCollection_CountBigIntArgs = {
  uniq?: InputMaybe<FlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type FlowCollection_ExpressionArgs = {
  get: Scalars['String'];
};


/** Collections in Flow blockchain */
export type FlowCollection_MaximumArgs = {
  get?: InputMaybe<FlowCollectionsMeasureable>;
  of: FlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type FlowCollection_MinimumArgs = {
  get?: InputMaybe<FlowCollectionsMeasureable>;
  of: FlowCollectionsMeasureable;
};

export type FlowCollectionFilter = {
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionsCount?: InputMaybe<IntegerSelector>;
};

export type FlowCollectionUniq =
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Index of collection inside block */
  | 'collection_index'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type FlowCollectionsMeasureable =
  /** SHA3-256 hash of the entire block payload */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Index of collection inside block */
  | 'collection_index'
  /** Date */
  | 'date'
  /** Height of the block in the chain */
  | 'height'
  /** Time */
  | 'time'
  /** Count of transactions inside collection */
  | 'transactions_count';

export type FlowDirection =
  /** Inbound transfers */
  | 'inbound'
  /** Outbound transfers */
  | 'outbound';

/** Events in Flow blockchain */
export type FlowEvent = {
  __typename?: 'FlowEvent';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  index: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction information */
  transaction: FlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String'];
};


/** Events in Flow blockchain */
export type FlowEvent_AnyArgs = {
  of: FlowEventMeasureable;
};


/** Events in Flow blockchain */
export type FlowEvent_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Events in Flow blockchain */
export type FlowEvent_CountArgs = {
  uniq?: InputMaybe<FlowEventUniq>;
};


/** Events in Flow blockchain */
export type FlowEvent_CountBigIntArgs = {
  uniq?: InputMaybe<FlowEventUniq>;
};


/** Events in Flow blockchain */
export type FlowEvent_ExpressionArgs = {
  get: Scalars['String'];
};


/** Events in Flow blockchain */
export type FlowEvent_MaximumArgs = {
  get?: InputMaybe<FlowEventMeasureable>;
  of: FlowEventMeasureable;
};


/** Events in Flow blockchain */
export type FlowEvent_MinimumArgs = {
  get?: InputMaybe<FlowEventMeasureable>;
  of: FlowEventMeasureable;
};


/** Events in Flow blockchain */
export type FlowEvent_TransactionArgs = {
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
};

/** EventFields in Flow blockchain */
export type FlowEventField = {
  __typename?: 'FlowEventField';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Index of event inside transaction */
  eventIndex: Scalars['Int'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Field */
  field: Scalars['String'];
  /** Field as fix */
  fieldAsFix: Scalars['String'];
  /** Field as fix */
  fieldAsInt: Scalars['String'];
  /** Index of field inside event */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction information */
  transaction: FlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String'];
};


/** EventFields in Flow blockchain */
export type FlowEventField_AnyArgs = {
  of: FlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type FlowEventField_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** EventFields in Flow blockchain */
export type FlowEventField_CountArgs = {
  uniq?: InputMaybe<FlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type FlowEventField_CountBigIntArgs = {
  uniq?: InputMaybe<FlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type FlowEventField_ExpressionArgs = {
  get: Scalars['String'];
};


/** EventFields in Flow blockchain */
export type FlowEventField_MaximumArgs = {
  get?: InputMaybe<FlowEventFieldMeasureable>;
  of: FlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type FlowEventField_MinimumArgs = {
  get?: InputMaybe<FlowEventFieldMeasureable>;
  of: FlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type FlowEventField_TransactionArgs = {
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
};

export type FlowEventFieldFilter = {
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  fieldAsFix?: InputMaybe<IntegerSelector>;
  fieldAsInt?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};

export type FlowEventFieldMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code';

export type FlowEventFieldUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

export type FlowEventFilter = {
  blockId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  type?: InputMaybe<StringSelector>;
};

export type FlowEventMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code';

export type FlowEventUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

export type FlowFullTransactionDimension = {
  __typename?: 'FlowFullTransactionDimension';
  /** Error message */
  errorMessage?: Maybe<Scalars['String']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<Scalars['String']>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<Scalars['String']>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']>;
};

/** Inputs in Flow blockchain */
export type FlowInput = {
  __typename?: 'FlowInput';
  /** Address */
  address: Address;
  amount?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** NFT Id */
  entityId: Scalars['BigInt'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction information */
  transaction: FlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String'];
};


/** Inputs in Flow blockchain */
export type FlowInput_AmountArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Inputs in Flow blockchain */
export type FlowInput_AmountDecimalArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Inputs in Flow blockchain */
export type FlowInput_AnyArgs = {
  of: FlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type FlowInput_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Inputs in Flow blockchain */
export type FlowInput_CountArgs = {
  uniq?: InputMaybe<FlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type FlowInput_CountBigIntArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<FlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type FlowInput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Inputs in Flow blockchain */
export type FlowInput_MaximumArgs = {
  get?: InputMaybe<FlowInputMeasureable>;
  of: FlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type FlowInput_MinimumArgs = {
  get?: InputMaybe<FlowInputMeasureable>;
  of: FlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type FlowInput_TransactionArgs = {
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
};

export type FlowInputFilter = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};

export type FlowInputMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_id'
  /** Currency address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Index of event inside transaction */
  | 'event_index'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code'
  /** Type */
  | 'type';

export type FlowInputUniq =
  /** Unique Number of symbol currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions'
  /** Unique Number of types */
  | 'types';

export type FlowMinorTransactionDimension = {
  __typename?: 'FlowMinorTransactionDimension';
  /** ID of the transaction */
  id?: Maybe<Scalars['String']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']>;
};

export type FlowNetwork =
  /** Flow mainnet */
  | 'flow';

/** Outputs in Flow blockchain */
export type FlowOutput = {
  __typename?: 'FlowOutput';
  /** Address */
  address: Address;
  amount?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** NFT Id */
  entityId: Scalars['BigInt'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction information */
  transaction: FlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String'];
};


/** Outputs in Flow blockchain */
export type FlowOutput_AmountArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Outputs in Flow blockchain */
export type FlowOutput_AmountDecimalArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Outputs in Flow blockchain */
export type FlowOutput_AnyArgs = {
  of: FlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type FlowOutput_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Outputs in Flow blockchain */
export type FlowOutput_CountArgs = {
  uniq?: InputMaybe<FlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type FlowOutput_CountBigIntArgs = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<FlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type FlowOutput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Outputs in Flow blockchain */
export type FlowOutput_MaximumArgs = {
  get?: InputMaybe<FlowOutputMeasureable>;
  of: FlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type FlowOutput_MinimumArgs = {
  get?: InputMaybe<FlowOutputMeasureable>;
  of: FlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type FlowOutput_TransactionArgs = {
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
};

export type FlowOutputFilter = {
  address?: InputMaybe<StringSelector>;
  blockId?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<BigIntIdSelector>;
  eventIndex?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  index?: InputMaybe<IntegerSelector>;
  smartContractAddress?: InputMaybe<StringSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
  transactionIndexInCollection?: InputMaybe<IntegerSelector>;
  transactionStatusCode?: InputMaybe<IntegerSelector>;
  transferReason?: InputMaybe<FlowTransferReasonSelector>;
  type?: InputMaybe<StringSelector>;
};

export type FlowOutputMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_id'
  /** Currency address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Index of event inside transaction */
  | 'event_index'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code'
  /** Type */
  | 'type';

export type FlowOutputUniq =
  /** Unique Number of symbol currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions'
  /** Unique Number of types */
  | 'types';

/** Transactions in Flow  blockchain */
export type FlowTransaction = {
  __typename?: 'FlowTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Error message */
  errorMessage?: Maybe<Scalars['String']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<Address>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<Address>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']>;
  /** Raw source code for a Cadence script, encoded as UTF-8 bytes */
  script?: Maybe<Scalars['String']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_AnyArgs = {
  of: FlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_CountArgs = {
  uniq?: InputMaybe<FlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_CountBigIntArgs = {
  uniq?: InputMaybe<FlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_MaximumArgs = {
  get?: InputMaybe<FlowTransactionMeasureable>;
  of: FlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type FlowTransaction_MinimumArgs = {
  get?: InputMaybe<FlowTransactionMeasureable>;
  of: FlowTransactionMeasureable;
};

/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer = {
  __typename?: 'FlowTransactionAuthorizer';
  any?: Maybe<Scalars['String']>;
  /** Account authorizing the transaction to mutate their state. */
  authorizer?: Maybe<Address>;
  /** Block information */
  block: FlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about transaction */
  transaction: FlowFullTransactionDimension;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_AnyArgs = {
  of: FlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_CountArgs = {
  uniq?: InputMaybe<FlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_CountBigIntArgs = {
  uniq?: InputMaybe<FlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_ExpressionArgs = {
  get: Scalars['String'];
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_MaximumArgs = {
  get?: InputMaybe<FlowTransactionAuthorizerMeasureable>;
  of: FlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_MinimumArgs = {
  get?: InputMaybe<FlowTransactionAuthorizerMeasureable>;
  of: FlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type FlowTransactionAuthorizer_TransactionArgs = {
  errorMessage?: InputMaybe<StringSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<HashSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<HashSelector>;
  referenceBlockId?: InputMaybe<HashSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionAuthorizerFilter = {
  authorizer?: InputMaybe<AddressSelector>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionAuthorizerMeasureable =
  /** Account authorizing the transaction to mutate their state. */
  | 'authorizer'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransactionAuthorizerUniq =
  /** Unique Number of authorizers */
  | 'authorizers'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature = {
  __typename?: 'FlowTransactionEnvelopeSignature';
  /** Address of the account for this signature */
  address: Address;
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** ID of the account key */
  keyId: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Raw signature data */
  signature: Scalars['String'];
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about transaction */
  transaction: FlowFullTransactionDimension;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_AnyArgs = {
  of: FlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_CountArgs = {
  uniq?: InputMaybe<FlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_CountBigIntArgs = {
  uniq?: InputMaybe<FlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_ExpressionArgs = {
  get: Scalars['String'];
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_MaximumArgs = {
  get?: InputMaybe<FlowTransactionEnvelopeSignatureMeasureable>;
  of: FlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_MinimumArgs = {
  get?: InputMaybe<FlowTransactionEnvelopeSignatureMeasureable>;
  of: FlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type FlowTransactionEnvelopeSignature_TransactionArgs = {
  errorMessage?: InputMaybe<StringSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<HashSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<HashSelector>;
  referenceBlockId?: InputMaybe<HashSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionEnvelopeSignatureFilter = {
  address?: InputMaybe<AddressSelector>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  keyId?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionEnvelopeSignatureMeasureable =
  /** Address of the account for this signature */
  | 'address'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** ID of account key */
  | 'key_id'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Raw signature data */
  | 'signature'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransactionEnvelopeSignatureUniq =
  /** The address and key ID fields declare the account key that generated the signature */
  | 'addresses'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransactionFilter = {
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

/** Blockchain transaction */
export type FlowTransactionHashIndexValues = {
  __typename?: 'FlowTransactionHashIndexValues';
  /** Hash hex representation */
  id: Scalars['String'];
  /** Transaction value in input */
  valueIn: Scalars['Float'];
  /** Transaction value in input */
  valueInDecimal: Scalars['DecimalNumber'];
  /** Transaction value in output */
  valueOut: Scalars['Float'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['DecimalNumber'];
};

export type FlowTransactionMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature = {
  __typename?: 'FlowTransactionPayloadSignature';
  /** Address of the account for this signature */
  address: Address;
  any?: Maybe<Scalars['String']>;
  /** Block information */
  block: FlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** ID of the account key */
  keyId: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Raw signature data */
  signature: Scalars['String'];
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about transaction */
  transaction: FlowFullTransactionDimension;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_AnyArgs = {
  of: FlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_BlockArgs = {
  blockId?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_CountArgs = {
  uniq?: InputMaybe<FlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_CountBigIntArgs = {
  uniq?: InputMaybe<FlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_ExpressionArgs = {
  get: Scalars['String'];
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_MaximumArgs = {
  get?: InputMaybe<FlowTransactionPayloadSignatureMeasureable>;
  of: FlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_MinimumArgs = {
  get?: InputMaybe<FlowTransactionPayloadSignatureMeasureable>;
  of: FlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type FlowTransactionPayloadSignature_TransactionArgs = {
  errorMessage?: InputMaybe<StringSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<HashSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<HashSelector>;
  referenceBlockId?: InputMaybe<HashSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionPayloadSignatureFilter = {
  address?: InputMaybe<AddressSelector>;
  blockId?: InputMaybe<HashSelector>;
  collectionId?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  eventsCount?: InputMaybe<IntegerSelector>;
  gasLimit?: InputMaybe<IntegerSelector>;
  height?: InputMaybe<BlockSelector>;
  indexInCollection?: InputMaybe<IntegerSelector>;
  keyId?: InputMaybe<IntegerSelector>;
  payer?: InputMaybe<AddressSelector>;
  proposalKeyId?: InputMaybe<IntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<IntegerSelector>;
  proposer?: InputMaybe<AddressSelector>;
  referenceBlockId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  statusCode?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionId?: InputMaybe<HashSelector>;
};

export type FlowTransactionPayloadSignatureMeasureable =
  /** Address of the account for this signature */
  | 'address'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** ID of account key */
  | 'key_id'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Raw signature data */
  | 'signature'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransactionPayloadSignatureUniq =
  /** The address and key ID fields declare the account key that generated the signature */
  | 'addresses'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransactionUniq =
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type FlowTransferReasonEnum =
  /** Fee paid */
  | 'fee'
  /** Currency transfer */
  | 'fungible_token_transfer'
  /** NFT Transfer */
  | 'nft_transfer';

/** Select by transfer reason */
export type FlowTransferReasonSelector = {
  /** Reason in the list */
  in?: InputMaybe<Array<FlowTransferReasonEnum>>;
  /** Reason is */
  is?: InputMaybe<FlowTransferReasonEnum>;
  /** Reason not */
  not?: InputMaybe<FlowTransferReasonEnum>;
  /** Reason not in the list */
  notIn?: InputMaybe<Array<FlowTransferReasonEnum>>;
};

/** Select transactions by group */
export type GroupSelector = {
  /** Transaction group in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Transaction group is */
  is?: InputMaybe<Scalars['String']>;
  /** Transaction group not */
  not?: InputMaybe<Scalars['String']>;
  /** Transaction group not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Harmony Chain */
export type Harmony = {
  __typename?: 'Harmony';
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<HarmonyArguments>>;
  /** Harmony Blocks */
  blocks?: Maybe<Array<HarmonyBlocks>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<HarmonySmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<HarmonySmartContractEvents>>;
  /** Harmony Staking Transactions */
  stakingTransactions?: Maybe<Array<HarmonyStakingTransactions>>;
  /** Harmony Transactions */
  transactions?: Maybe<Array<HarmonyTransactions>>;
  /** Harmony Transfers */
  transfers?: Maybe<Array<HarmonyTransfers>>;
};


/** Harmony Chain */
export type Harmony_ArgumentsArgs = {
  any?: InputMaybe<Array<HarmonyArgumentsFilter>>;
  argument?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  ledger?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<HashSelector>;
  smartContractId?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
};


/** Harmony Chain */
export type Harmony_BlocksArgs = {
  any?: InputMaybe<Array<HarmonyBlocksFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<HashSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<HashSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  parentHash?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  size?: InputMaybe<BigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<HashSelector>;
  unclesCount?: InputMaybe<HashSelector>;
  viewId?: InputMaybe<HashSelector>;
};


/** Harmony Chain */
export type Harmony_SmartContractCallsArgs = {
  any?: InputMaybe<Array<HarmonySmartContractCallsFilter>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Harmony Chain */
export type Harmony_SmartContractEventsArgs = {
  any?: InputMaybe<Array<HarmonySmartContractEventsFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Harmony Chain */
export type Harmony_StakingTransactionsArgs = {
  any?: InputMaybe<Array<HarmonyStakingTransactionsFilter>>;
  date?: InputMaybe<DateSelector>;
  delegatorAddress?: InputMaybe<HashSelector>;
  ledger?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  shardId?: InputMaybe<BigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<HashSelector>;
};


/** Harmony Chain */
export type Harmony_TransactionsArgs = {
  any?: InputMaybe<Array<HarmonyTransactionsFilter>>;
  creates?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  transactionHash?: InputMaybe<StringSelector>;
  transactionIndex?: InputMaybe<HashSelector>;
};


/** Harmony Chain */
export type Harmony_TransfersArgs = {
  any?: InputMaybe<Array<HarmonyTransfersFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<IntIdSelector>;
  ledger?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  sender?: InputMaybe<HashSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferFrom?: InputMaybe<AddressSelector>;
  transferTo?: InputMaybe<AddressSelector>;
};

/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments = {
  __typename?: 'HarmonyArguments';
  /** Address */
  address?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** Argument Index */
  argIndex?: Maybe<Scalars['String']>;
  /** Argument Type */
  argType?: Maybe<Scalars['String']>;
  /** Argument */
  argument?: Maybe<Scalars['String']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Value */
  external?: Maybe<Scalars['Int']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Number */
  number?: Maybe<Scalars['String']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Signature ID */
  signatureId?: Maybe<Scalars['BigInt']>;
  /** Address of the smart contract */
  smartContractAddress?: Maybe<Scalars['String']>;
  /** Id of the smart contract */
  smartContractId?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** To Shard ID */
  toShardId?: Maybe<Scalars['BigInt']>;
  /** Value */
  value?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_AnyArgs = {
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_ArgumentArgs = {
  argument?: InputMaybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_CountArgs = {
  uniq?: InputMaybe<HarmonyArgumentsUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_LedgerArgs = {
  ledger?: InputMaybe<BlockSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_MaximumArgs = {
  get?: InputMaybe<HarmonyArgumentsMeasureable>;
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_MinimumArgs = {
  get?: InputMaybe<HarmonyArgumentsMeasureable>;
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_ReceiverArgs = {
  receiver?: InputMaybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_SenderArgs = {
  sender?: InputMaybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_SmartContractAddressArgs = {
  smartContractAddress?: InputMaybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments_SmartContractIdArgs = {
  smartContractAddress?: InputMaybe<IntegerSelector>;
};

export type HarmonyArgumentsFilter = {
  argument?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  ledger?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<HashSelector>;
  smartContractId?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
};

export type HarmonyArgumentsMeasureable =
  /** Address */
  | 'address'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Epoch */
  | 'epoch'
  /** Nonce */
  | 'nonce'
  /** Address of  the receive */
  | 'receiver'
  /** Address of the sender */
  | 'sender'
  /** Shard ID */
  | 'shard_id'
  /** Signature */
  | 'signature'
  /** Hash of the signature */
  | 'signature_hash'
  /** Name of the signature */
  | 'signature_name'
  /** Address of the smart contract */
  | 'smart_contract_address'
  /** Id of the smart contract */
  | 'smart_contract_id'
  /** Time */
  | 'time'
  /** TO Shard ID */
  | 'to_shard_id'
  /** TX Index */
  | 'tx_index'
  /** Value */
  | 'value';

export type HarmonyArgumentsUniq =
  /** Unique addresses */
  | 'address'
  /** Unique block hash count */
  | 'block_hash'
  /** Unique date count */
  | 'dates'
  /** Unique ledger count */
  | 'ledger'
  /** Unique address of the receiver */
  | 'receiver'
  /** Unique address of the sender */
  | 'sender'
  /** Unique smart contract address */
  | 'smart_contract_address'
  /** Unique time */
  | 'times';

/** Blocks in Harmony blockchain */
export type HarmonyBlocks = {
  __typename?: 'HarmonyBlocks';
  any?: Maybe<Scalars['String']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['String']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** The “extra data” field of this block */
  extraData?: Maybe<Scalars['String']>;
  gasLimit?: Maybe<Scalars['Float']>;
  gasUsed?: Maybe<Scalars['Float']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  /** The bloom filter for the logs of the block. null when its pending block */
  logsBloom?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction hash */
  miner?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Mix Hash */
  mixHash?: Maybe<Scalars['String']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Parent hash */
  parentHash?: Maybe<Scalars['String']>;
  /** Receipts Root */
  receiptsRoot?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Integer the size of this block in bytes */
  size?: Maybe<Scalars['BigInt']>;
  /** Staking Transaction Count */
  stakingTransactionsCount?: Maybe<Scalars['BigInt']>;
  /** The root of the final state trie of the block */
  stateRoot?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction Count */
  transactionCount?: Maybe<Scalars['BigInt']>;
  /** The root of the transaction trie of the block */
  transactionsRoot?: Maybe<Scalars['String']>;
  /** Count of ucles hashes */
  unclesCount?: Maybe<Scalars['BigInt']>;
  /** View ID */
  viewId?: Maybe<Scalars['String']>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_AnyArgs = {
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_CountArgs = {
  uniq?: InputMaybe<HarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_CountBigIntArgs = {
  uniq?: InputMaybe<HarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_GasLimitArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<HashSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<HashSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  parentHash?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  size?: InputMaybe<BigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<HashSelector>;
  unclesCount?: InputMaybe<HashSelector>;
  viewId?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_GasUsedArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<HashSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<HashSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  parentHash?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  size?: InputMaybe<BigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<HashSelector>;
  unclesCount?: InputMaybe<HashSelector>;
  viewId?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_LedgerArgs = {
  ledger?: InputMaybe<BlockSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_MaximumArgs = {
  get?: InputMaybe<HarmonyBlocksMeasureable>;
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_MinerArgs = {
  miner?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_MinimumArgs = {
  get?: InputMaybe<HarmonyBlocksMeasureable>;
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_ParentHashArgs = {
  parentHash?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_SizeArgs = {
  size?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_StakingTransactionsCountArgs = {
  stakingTransactionsCount?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_TransactionCountArgs = {
  transactionCount?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_UnclesCountArgs = {
  unclesCount?: InputMaybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocks_ViewIdArgs = {
  viewId?: InputMaybe<HashSelector>;
};

export type HarmonyBlocksFilter = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  difficulty?: InputMaybe<HashSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BlockSelector>;
  miner?: InputMaybe<HashSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  parentHash?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  size?: InputMaybe<BigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionCount?: InputMaybe<HashSelector>;
  unclesCount?: InputMaybe<HashSelector>;
  viewId?: InputMaybe<HashSelector>;
};

export type HarmonyBlocksMeasureable =
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Gas limit */
  | 'gas_limit'
  /** Gas Used */
  | 'gas_used'
  /** Parent hash */
  | 'paret_hash'
  /** Time */
  | 'time'
  /** Transaction Count */
  | 'transaction_count';

export type HarmonyBlocksUniq =
  /** Unique block hash count */
  | 'block_hash'
  /** Unique date count */
  | 'dates'
  /** Unique ledger count */
  | 'ledger'
  /** Unique miner count */
  | 'miner'
  /** Unique mix hash count */
  | 'mix_hash'
  /** Unique parent hash count */
  | 'parent_hash'
  /** Unique receipts root count */
  | 'receipts_root'
  /** Unique state root count */
  | 'state_root'
  /** Unique time */
  | 'times'
  /** Unique transactions root count */
  | 'transactions_root';

export type HarmonyEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Nonce */
  | 'nonce'
  /** Shard ID */
  | 'shard_id'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'to_shard_id'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index'
  /** Action To */
  | 'tx_to';

export type HarmonyNetwork =
  /** Harmony Mainnat */
  | 'harmony'
  /** Harmony Testnet */
  | 'harmony_testnet';

/** Smart Contract Calls */
export type HarmonySmartContractCalls = {
  __typename?: 'HarmonySmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callPath?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  gas?: Maybe<Scalars['Int']>;
  /** Gas unit price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BigInt']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BigInt']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BigInt']>;
  /** Transaction Sender */
  txSender?: Maybe<Address>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_AmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_AnyArgs = {
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_CountArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<HarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<HarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_GasArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_GasPriceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_MaximumArgs = {
  get?: InputMaybe<HarmonySmartContractCallsMeasureable>;
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_MinimumArgs = {
  get?: InputMaybe<HarmonySmartContractCallsMeasureable>;
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_NonceArgs = {
  nonce?: InputMaybe<IntegerSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_TxSenderArgs = {
  txSender?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCalls_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

export type HarmonySmartContractCallsFilter = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

export type HarmonySmartContractCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_path'
  /** Date */
  | 'date'
  /** External */
  | 'external'
  /** Nonce */
  | 'nonce'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Shard ID */
  | 'shard_id'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'to_shard_id'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index';

export type HarmonySmartContractCallsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transaction senders */
  | 'tx_from'
  /** Unique transactions senders */
  | 'tx_sender'
  /** Unique callers count */
  | 'tx_to'
  /** Unique transactions count */
  | 'txs';

/** Smart Contract Events */
export type HarmonySmartContractEvents = {
  __typename?: 'HarmonySmartContractEvents';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction hash where transfer happened */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BigInt']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<Event>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BigInt']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BigInt']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_AnyArgs = {
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_CountArgs = {
  uniq?: InputMaybe<SmartContractEventsUniq>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_CountBigIntArgs = {
  uniq?: InputMaybe<SmartContractEventsUniq>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_EpochArgs = {
  epoch?: InputMaybe<IntegerSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_MaximumArgs = {
  get?: InputMaybe<HarmonyEventsMeasureable>;
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_MinimumArgs = {
  get?: InputMaybe<HarmonyEventsMeasureable>;
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_NonceArgs = {
  nonce?: InputMaybe<IntegerSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_SmartContractEventArgs = {
  smartContractEvent?: InputMaybe<EventSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEvents_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

export type HarmonySmartContractEventsFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<BigIntegerSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions = {
  __typename?: 'HarmonyStakingTransactions';
  any?: Maybe<Scalars['String']>;
  /** Hash of block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Delegator Address */
  delegatorAddress?: Maybe<Scalars['String']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BigInt']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']>;
  /** Validator Address */
  validatorAddress?: Maybe<Scalars['String']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_AnyArgs = {
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_CountArgs = {
  uniq?: InputMaybe<HarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_CountBigIntArgs = {
  uniq?: InputMaybe<HarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_DelegatorAddressArgs = {
  delegatorAddress?: InputMaybe<HashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  delegatorAddress?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  ledger?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<HashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_LedgerArgs = {
  ledger?: InputMaybe<BlockSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_MaximumArgs = {
  get?: InputMaybe<HarmonyStakingTransactionsMeasureable>;
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_MinimumArgs = {
  get?: InputMaybe<HarmonyStakingTransactionsMeasureable>;
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_StatusArgs = {
  status?: InputMaybe<Scalars['Boolean']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_TransactionTypeArgs = {
  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions_ValidatorAddressArgs = {
  validatorAddress?: InputMaybe<HashSelector>;
};

export type HarmonyStakingTransactionsFilter = {
  date?: InputMaybe<DateSelector>;
  delegatorAddress?: InputMaybe<HashSelector>;
  ledger?: InputMaybe<BlockSelector>;
  nonce?: InputMaybe<BigIntIdSelector>;
  shardId?: InputMaybe<BigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<HashSelector>;
};

export type HarmonyStakingTransactionsMeasureable =
  /** Date */
  | 'date'
  /** Deligator Address */
  | 'deligator_address'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gasPrice'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Time */
  | 'time'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Validator Address */
  | 'validator_address'
  /** Value transferred in ATTO */
  | 'value';

export type HarmonyStakingTransactionsUniq =
  /** Unique date count */
  | 'dates'
  /** Unique delegator validator */
  | 'delegator_address'
  /** Unique block */
  | 'ledger'
  /** Unique smart contract addresses */
  | 'smart_contract_address'
  /** Unique time */
  | 'times'
  /** Unique address validator */
  | 'validator_address';

/** Transactions in Harmony blockchain */
export type HarmonyTransactions = {
  __typename?: 'HarmonyTransactions';
  any?: Maybe<Scalars['String']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction creates */
  creates?: Maybe<Scalars['String']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Float']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BigInt']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_AnyArgs = {
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_CountArgs = {
  uniq?: InputMaybe<HarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_CountBigIntArgs = {
  uniq?: InputMaybe<HarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_CreatesArgs = {
  creates?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_GasArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  creates?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  transactionHash?: InputMaybe<StringSelector>;
  transactionIndex?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  creates?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  transactionHash?: InputMaybe<StringSelector>;
  transactionIndex?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_LedgerArgs = {
  ledger?: InputMaybe<BlockSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_MaximumArgs = {
  get?: InputMaybe<HarmonyTransactionsMeasureable>;
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_MinimumArgs = {
  get?: InputMaybe<HarmonyTransactionsMeasureable>;
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_ReceiverArgs = {
  receiver?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_SenderArgs = {
  sender?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_StatusArgs = {
  status?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactions_TransactionIndexArgs = {
  transactionIndex?: InputMaybe<HashSelector>;
};

export type HarmonyTransactionsFilter = {
  creates?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  epoch?: InputMaybe<BigIntegerSelector>;
  ledger?: InputMaybe<BigIntIdSelector>;
  nonce?: InputMaybe<BigIntegerSelector>;
  receiver?: InputMaybe<HashSelector>;
  sender?: InputMaybe<HashSelector>;
  shardId?: InputMaybe<BigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  toShardId?: InputMaybe<BigIntegerSelector>;
  transactionHash?: InputMaybe<StringSelector>;
  transactionIndex?: InputMaybe<HashSelector>;
};

export type HarmonyTransactionsMeasureable =
  /** Date */
  | 'date'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gasPrice'
  /** Gas value provided by the sender */
  | 'gasValue'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Deligator Address */
  | 'receiver'
  /** Validator Address */
  | 'sender'
  /** Shard ID */
  | 'shardId'
  /** Status */
  | 'status'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'toShardId'
  /** Transaction Hash */
  | 'transactionHash'
  /** Transaction Index */
  | 'transactionIndex'
  /** Value transferred in ATTO */
  | 'value';

export type HarmonyTransactionsUniq =
  /** Unique date count */
  | 'dates'
  /** Unique block */
  | 'ledger'
  /** Unique receiver */
  | 'receiver'
  /** Unique sender */
  | 'sender'
  /** Unique time */
  | 'times';

/** Transfers in Harmony blockchain */
export type HarmonyTransfers = {
  __typename?: 'HarmonyTransfers';
  any?: Maybe<Scalars['String']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Entity */
  entityId?: Maybe<Scalars['Int']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External */
  external?: Maybe<Scalars['Boolean']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BigInt']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Staking Tx Type */
  stakingTxType?: Maybe<Scalars['String']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** TO Shard ID */
  toShardId?: Maybe<Scalars['BigInt']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']>;
  /** Address of the payer */
  transferFrom?: Maybe<Address>;
  /** Address of the receiver */
  transferTo?: Maybe<Address>;
  /** Address of transaction sender */
  txSender?: Maybe<Scalars['String']>;
  /** Address of transaction receiver */
  txTo?: Maybe<Scalars['String']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_AnyArgs = {
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_CountArgs = {
  uniq?: InputMaybe<HarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_CountBigIntArgs = {
  uniq?: InputMaybe<HarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_CurrencyArgs = {
  currency?: InputMaybe<CurrencySelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_GasValueArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<IntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  ledger?: InputMaybe<BlockSelector>;
  sender?: InputMaybe<HashSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferFrom?: InputMaybe<AddressSelector>;
  transferTo?: InputMaybe<AddressSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_LedgerArgs = {
  ledger?: InputMaybe<BlockSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_MaximumArgs = {
  get?: InputMaybe<HarmonyTransfersMeasureable>;
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_MinimumArgs = {
  get?: InputMaybe<HarmonyTransfersMeasureable>;
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_StatusArgs = {
  status?: InputMaybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_TransactionIndexArgs = {
  transactionIndex?: InputMaybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_TransferFromArgs = {
  transferFrom?: InputMaybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfers_TransferToArgs = {
  transferTo?: InputMaybe<HashSelector>;
};

export type HarmonyTransfersFilter = {
  blockHash?: InputMaybe<HashSelector>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<IntIdSelector>;
  ledger?: InputMaybe<BlockSelector>;
  sender?: InputMaybe<HashSelector>;
  status?: InputMaybe<Scalars['Boolean']>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferFrom?: InputMaybe<AddressSelector>;
  transferTo?: InputMaybe<AddressSelector>;
};

export type HarmonyTransfersMeasureable =
  /** Block Hash */
  | 'block_hash'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Tx To */
  | 'entity_id'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Gas value provided by the sender */
  | 'gas_value'
  /** Block */
  | 'ledger'
  /** Validator Address */
  | 'sender'
  /** Staking Tx Type */
  | 'staking_tx_type'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Token From */
  | 'transfer_from'
  /** Token To */
  | 'transfer_to'
  /** Tx Sender */
  | 'tx_sender'
  /** Tx To */
  | 'tx_to'
  /** Value transferred in ATTO */
  | 'value';

export type HarmonyTransfersUniq =
  /** Unique date count */
  | 'dates'
  /** Unique block */
  | 'ledger'
  /** Unique sender */
  | 'sender'
  /** Unique time */
  | 'times'
  /** Unique transfer from */
  | 'transfer_from'
  /** Unique transfer to */
  | 'transfer_to';

/** Select by hash */
export type HashSelector = {
  /** Hash in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Hash is */
  is?: InputMaybe<Scalars['String']>;
  /** Hash not */
  not?: InputMaybe<Scalars['String']>;
  /** Hash not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Hedera Chain */
export type Hedera = {
  __typename?: 'Hedera';
  /** Basic information about address */
  address: Array<HederaAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<HederaArgument>>;
  /** Blockhain Calls */
  calls?: Maybe<Array<HederaCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<HederaCoinpath>>;
  /** Blockhain Inputs */
  inputs?: Maybe<Array<HederaInput>>;
  /** Blockhain Messages */
  messages?: Maybe<Array<HederaMessage>>;
  /** Blockchain Outputs */
  outputs?: Maybe<Array<HederaOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<HederaTransaction>>;
};


/** Hedera Chain */
export type Hedera_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Hedera Chain */
export type Hedera_ArgumentsArgs = {
  any?: InputMaybe<Array<HederaArgumentFilter>>;
  date?: InputMaybe<DateSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Hedera Chain */
export type Hedera_CallsArgs = {
  any?: InputMaybe<Array<HederaCallFilter>>;
  callInput?: InputMaybe<HashSelector>;
  callResult?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Hedera Chain */
export type Hedera_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Hedera Chain */
export type Hedera_InputsArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<HederaInputFilter>>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Hedera Chain */
export type Hedera_MessagesArgs = {
  any?: InputMaybe<Array<HederaMessageFilter>>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionRunningHash?: InputMaybe<HashSelector>;
};


/** Hedera Chain */
export type Hedera_OutputsArgs = {
  any?: InputMaybe<Array<HederaOutputFilter>>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Hedera Chain */
export type Hedera_TransactionsArgs = {
  any?: InputMaybe<Array<HederaTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};

/** Address detailed information for Hedera network */
export type HederaAddressInfoWithBalance = {
  __typename?: 'HederaAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']>;
  /** Token balances */
  tokenBalances?: Maybe<Array<HederaBalance>>;
};


/** Address detailed information for Hedera network */
export type HederaAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Arguments in Hedera blockchain */
export type HederaArgument = {
  __typename?: 'HederaArgument';
  any?: Maybe<Scalars['String']>;
  /** Argument type */
  argtype?: Maybe<Scalars['String']>;
  /** Argument */
  argument?: Maybe<Scalars['String']>;
  chargedTxFee?: Maybe<Scalars['BigInt']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<Account>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
  /** Value */
  value?: Maybe<Scalars['String']>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_AnyArgs = {
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_CountArgs = {
  uniq?: InputMaybe<HederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_CountBigIntArgs = {
  uniq?: InputMaybe<HederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments in Hedera blockchain */
export type HederaArgument_InitialBalanceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_MaxFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_MaximumArgs = {
  get?: InputMaybe<HederaArgumentsMeasureable>;
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_MinimumArgs = {
  get?: InputMaybe<HederaArgumentsMeasureable>;
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_TransactionFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgument_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaArgumentFilter = {
  date?: InputMaybe<DateSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};

export type HederaArgumentsMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaArgumentsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique node account */
  | 'smart_contract_entity'
  /** Unique time */
  | 'times';

/** Token Balance */
export type HederaBalance = {
  __typename?: 'HederaBalance';
  /** Staking Balance */
  balance?: Maybe<Scalars['Float']>;
  /** Token ID */
  tokenId?: Maybe<Scalars['String']>;
};

/** Calls in Hedera blockchain */
export type HederaCall = {
  __typename?: 'HederaCall';
  any?: Maybe<Scalars['String']>;
  /** Call input */
  callInput?: Maybe<Scalars['String']>;
  /** Call input */
  callResult?: Maybe<Scalars['String']>;
  chargedTxFee?: Maybe<Scalars['BigInt']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  gas?: Maybe<Scalars['Int']>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<Account>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Calls in Hedera blockchain */
export type HederaCall_AnyArgs = {
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCall_CallInputArgs = {
  callInput?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_CallResultArgs = {
  callResult?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_CountArgs = {
  uniq?: InputMaybe<HederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type HederaCall_CountBigIntArgs = {
  uniq?: InputMaybe<HederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type HederaCall_ExpressionArgs = {
  get: Scalars['String'];
};


/** Calls in Hedera blockchain */
export type HederaCall_GasArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  callInput?: InputMaybe<HashSelector>;
  callResult?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_InitialBalanceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_MaxFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_MaximumArgs = {
  get?: InputMaybe<HederaCallsMeasureable>;
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCall_MinimumArgs = {
  get?: InputMaybe<HederaCallsMeasureable>;
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCall_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Calls in Hedera blockchain */
export type HederaCall_TransactionFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCall_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaCallFilter = {
  callInput?: InputMaybe<HashSelector>;
  callResult?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  smartContractEntity?: InputMaybe<StringSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};

export type HederaCallsMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaCallsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique node account */
  | 'smart_contract_entity'
  /** Unique time */
  | 'times';

/** Coinpath */
export type HederaCoinpath = {
  __typename?: 'HederaCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type HederaCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type HederaCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type HederaCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type HederaCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Currency selector in Hedera blockchain. */
export type HederaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Inputs in Hedera blockchain */
export type HederaInput = {
  __typename?: 'HederaInput';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  /** Transfer Account */
  transferEntity?: Maybe<Account>;
  validStart?: Maybe<Timestamp>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_AnyArgs = {
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInput_CountArgs = {
  uniq?: InputMaybe<HederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_CountBigIntArgs = {
  uniq?: InputMaybe<HederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_CurrencyArgs = {
  currency?: InputMaybe<HederaCurrencySelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_EntityArgs = {
  entityType?: InputMaybe<EntityTypeSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Inputs in Hedera blockchain */
export type HederaInput_InitialBalanceArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_MaxFeeArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_MaximumArgs = {
  get?: InputMaybe<HederaInputMeasureable>;
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInput_MinimumArgs = {
  get?: InputMaybe<HederaInputMeasureable>;
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInput_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_TransactionFeeArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInput_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaInputFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};

export type HederaInputMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaInputsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times';

/** Messages in Hedera blockchain */
export type HederaMessage = {
  __typename?: 'HederaMessage';
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar date time */
  time?: Maybe<DateTime>;
  /** Transaction running hash */
  topicRunningHash?: Maybe<Scalars['String']>;
  /** Transaction running hash */
  topicSequenceNumber?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_AnyArgs = {
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessage_CountArgs = {
  uniq?: InputMaybe<HederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_CountBigIntArgs = {
  uniq?: InputMaybe<HederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_EntityArgs = {
  entityType?: InputMaybe<EntityTypeSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_ExpressionArgs = {
  get: Scalars['String'];
};


/** Messages in Hedera blockchain */
export type HederaMessage_InitialBalanceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionRunningHash?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_MaxFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionRunningHash?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_MaximumArgs = {
  get?: InputMaybe<HederaMessageMeasureable>;
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessage_MinimumArgs = {
  get?: InputMaybe<HederaMessageMeasureable>;
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessage_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_TopicRunningHashArgs = {
  topicRunningHash?: InputMaybe<StringSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_TopicSequenceNumberArgs = {
  topicSequenceNumber?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_TransactionFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionRunningHash?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessage_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaMessageFilter = {
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionRunningHash?: InputMaybe<HashSelector>;
};

export type HederaMessageMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaMessagesUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times';

export type HederaNetwork =
  /** The Hedera mainnet */
  | 'hedera'
  /** The Hedera testnets */
  | 'hedera_testnets';

/** Outputs in Hedera blockchain */
export type HederaOutput = {
  __typename?: 'HederaOutput';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  /** Transfer Account */
  transferEntity?: Maybe<Account>;
  validStart?: Maybe<Timestamp>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_AnyArgs = {
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_CountArgs = {
  uniq?: InputMaybe<HederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_CountBigIntArgs = {
  uniq?: InputMaybe<HederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_CurrencyArgs = {
  currency?: InputMaybe<HederaCurrencySelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_EntityArgs = {
  entityType?: InputMaybe<EntityTypeSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_ExpressionArgs = {
  get: Scalars['String'];
};


/** Outputs in Hedera blockchain */
export type HederaOutput_InitialBalanceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_MaxFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_MaximumArgs = {
  get?: InputMaybe<HederaOutputMeasureable>;
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_MinimumArgs = {
  get?: InputMaybe<HederaOutputMeasureable>;
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_TransactionFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutput_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaOutputFilter = {
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
  transferEntity?: InputMaybe<StringSelector>;
};

export type HederaOutputMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaOutputUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique Transfer entity */
  | 'transfer_entity';

/** Transactions in Hedera blockchain */
export type HederaTransaction = {
  __typename?: 'HederaTransaction';
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction Type */
  transactionType?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_AnyArgs = {
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_CountArgs = {
  uniq?: InputMaybe<HederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_CountBigIntArgs = {
  uniq?: InputMaybe<HederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_EntityArgs = {
  entityType?: InputMaybe<EntityTypeSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_InitialBalanceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_MaxFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_MaximumArgs = {
  get?: InputMaybe<HederaTransactionMeasureable>;
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_MinimumArgs = {
  get?: InputMaybe<HederaTransactionMeasureable>;
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_ResultArgs = {
  result?: InputMaybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_TransactionFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_TransactionHashArgs = {
  transactionHash?: InputMaybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransaction_ValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<DateTimeSelector>;
};

export type HederaTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  entityType?: InputMaybe<EntityTypeSelector>;
  nodeAccount?: InputMaybe<StringSelector>;
  payerAccount?: InputMaybe<StringSelector>;
  result?: InputMaybe<HashSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  transactionHash?: InputMaybe<HashSelector>;
};

export type HederaTransactionMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type HederaTransactionsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique transaction type */
  | 'transaction_type';

/** Input Script Type of UTXO transaction input */
export type InputScript = {
  __typename?: 'InputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']>;
  /** Long script pattern */
  pattern: Scalars['String'];
  /** Short script pattern */
  shortPattern: Scalars['String'];
  /** Simple script pattern */
  simplePattern: Scalars['String'];
  /** Script type */
  type?: Maybe<Scalars['String']>;
};

/** Solana Instruction */
export type Instruction = {
  __typename?: 'Instruction';
  action?: Maybe<Action>;
  callPath?: Maybe<Scalars['String']>;
  external?: Maybe<Scalars['Boolean']>;
  program?: Maybe<Program>;
};

/** Solana Instruction */
export type InstructionWithExternals = {
  __typename?: 'InstructionWithExternals';
  action?: Maybe<Action>;
  callPath?: Maybe<Scalars['String']>;
  external?: Maybe<Scalars['Boolean']>;
  externalAction?: Maybe<Action>;
  externalProgram?: Maybe<Program>;
  program?: Maybe<Program>;
};

/** Select by ID */
export type IntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['Int']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['Int']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** ID is */
  is?: InputMaybe<Scalars['Int']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
  /** ID not */
  not?: InputMaybe<Scalars['Int']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Select limited upper number */
export type IntegerLimitedSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
};

/** Select by number */
export type IntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Int']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Int']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
  /** not */
  not?: InputMaybe<Scalars['Int']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Libra */
export type Libra = {
  __typename?: 'Libra';
  /** Libra Network Blocks */
  blocks?: Maybe<Array<LibraBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<LibraCoinpath>>;
  /** Libra Network Currency Minting */
  mints?: Maybe<Array<LibraMints>>;
  /** Libra Network Transactions */
  transactions?: Maybe<Array<LibraTransactions>>;
  /** Libra Network Currency Transfers */
  transfers?: Maybe<Array<LibraTransfers>>;
};


/** Libra */
export type Libra_BlocksArgs = {
  any?: InputMaybe<Array<LibraBlockFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  metadata?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Libra */
export type Libra_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Libra */
export type Libra_MintsArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<LibraMintFilter>>;
  block?: InputMaybe<BlockSelector>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  minter?: InputMaybe<AddressSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Libra */
export type Libra_TransactionsArgs = {
  any?: InputMaybe<Array<LibraTransactionFilter>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Libra */
export type Libra_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<LibraTransferFilter>>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};

/** Block */
export type LibraBlock = {
  __typename?: 'LibraBlock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gasUsed?: Maybe<Scalars['Float']>;
  /** Block round in blockchain */
  height: Scalars['Int'];
  /** Key */
  key?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proposer */
  proposer?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of transaction for this block */
  version: Scalars['Int'];
  /** Version hash of transaction for this block */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Block */
export type LibraBlock_AnyArgs = {
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlock_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  metadata?: InputMaybe<StringSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<LibraBlockUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Block */
export type LibraBlock_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  metadata?: InputMaybe<StringSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<LibraBlockUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Block */
export type LibraBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block */
export type LibraBlock_GasUsedArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  metadata?: InputMaybe<StringSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Block */
export type LibraBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block */
export type LibraBlock_MaximumArgs = {
  get?: InputMaybe<LibraBlocksMeasureable>;
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlock_MetadataArgs = {
  metadata?: InputMaybe<StringSelector>;
};


/** Block */
export type LibraBlock_MinimumArgs = {
  get?: InputMaybe<LibraBlocksMeasureable>;
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlock_ProposerArgs = {
  proposer?: InputMaybe<AddressSelector>;
};


/** Block */
export type LibraBlock_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Block */
export type LibraBlock_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};

export type LibraBlockFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  metadata?: InputMaybe<StringSelector>;
  proposer?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};

export type LibraBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Proposer */
  | 'proposer';

export type LibraBlocksMeasureable =
  /** Block round */
  | 'block'
  /** Date */
  | 'date'
  /** Gas Used */
  | 'gas_used'
  /** Proposer */
  | 'proposer'
  /** Time */
  | 'time'
  /** Version */
  | 'version';

/** Coinpath */
export type LibraCoinpath = {
  __typename?: 'LibraCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<LibraTransactionValue>;
};


/** Coinpath */
export type LibraCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type LibraCoinpath_AnyArgs = {
  of: LibraCoinpathMeasureable;
};


/** Coinpath */
export type LibraCoinpath_MaximumArgs = {
  get?: InputMaybe<LibraCoinpathMeasureable>;
  of: LibraCoinpathMeasureable;
};


/** Coinpath */
export type LibraCoinpath_MinimumArgs = {
  get?: InputMaybe<LibraCoinpathMeasureable>;
  of: LibraCoinpathMeasureable;
};

export type LibraCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'version';

/**
 * Currency selector in Libra blockchain.
 * Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
 * Use name of currency for selection
 */
export type LibraCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type LibraMintFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  block?: InputMaybe<BlockSelector>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  minter?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};

/** Mints in Libra blockchain */
export type LibraMints = {
  __typename?: 'LibraMints';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Minter */
  minter?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Mint timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Mints in Libra blockchain */
export type LibraMints_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  minter?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_AnyArgs = {
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMints_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  block?: InputMaybe<BlockSelector>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  minter?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<LibraMintsUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  block?: InputMaybe<BlockSelector>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  minter?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<LibraMintsUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_CurrencyArgs = {
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
};


/** Mints in Libra blockchain */
export type LibraMints_ExpressionArgs = {
  get: Scalars['String'];
};


/** Mints in Libra blockchain */
export type LibraMints_MaximumArgs = {
  get?: InputMaybe<LibraMintsMeasureable>;
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMints_MinimumArgs = {
  get?: InputMaybe<LibraMintsMeasureable>;
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMints_MinterArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Mints in Libra blockchain */
export type LibraMints_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Mints in Libra blockchain */
export type LibraMints_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};

export type LibraMintsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Minter */
  | 'minter'
  /** Time */
  | 'time'
  /** Version */
  | 'version'
  /** Mint version hash */
  | 'version_hash';

export type LibraMintsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique minters */
  | 'minters'
  /** Unique versions */
  | 'versions';

export type LibraTransactionFilter = {
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};

/** Blockchain transaction with value */
export type LibraTransactionValue = {
  __typename?: 'LibraTransactionValue';
  /** Transaction value */
  value: Scalars['Float'];
  /** Transaction version */
  version: Scalars['Int'];
};

/** Transactions in Libra blockchain */
export type LibraTransactions = {
  __typename?: 'LibraTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Expiration Time */
  expirationTime?: Maybe<DateTime>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas unit price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']>;
  /** Script Type */
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  /** Transaction sender */
  sender?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_AnyArgs = {
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_CountArgs = {
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<LibraTransactionsUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<LibraTransactionsUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Libra blockchain */
export type LibraTransactions_GasArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_GasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_GasPriceArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_GasValueArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_MaximumArgs = {
  get?: InputMaybe<LibraTransactionsMeasureable>;
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_MinimumArgs = {
  get?: InputMaybe<LibraTransactionsMeasureable>;
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_ScriptHashArgs = {
  scriptHash?: InputMaybe<StringSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_SenderArgs = {
  txSender?: InputMaybe<AddressSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactions_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};

export type LibraTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Script Hash */
  | 'script_hash'
  /** Time */
  | 'time'
  /** Transaction Sender */
  | 'tx_sender'
  /** Version */
  | 'version';

export type LibraTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction script hashes */
  | 'scripts'
  /** Unique transaction senders */
  | 'senders'
  /** Unique versions */
  | 'versions';

export type LibraTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};

/** Transfers in Libra blockchain */
export type LibraTransfers = {
  __typename?: 'LibraTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Expiration Time */
  expirationTime?: Maybe<DateTime>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']>;
  /** Script Type */
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transfer timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_AnyArgs = {
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_CurrencyArgs = {
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfers in Libra blockchain */
export type LibraTransfers_GasArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_GasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_GasValueArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currency?: InputMaybe<Array<LibraCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  scriptHash?: InputMaybe<StringSelector>;
  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txSender?: InputMaybe<AddressSelector>;
  version?: InputMaybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_MaximumArgs = {
  get?: InputMaybe<LibraTransfersMeasureable>;
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_MinimumArgs = {
  get?: InputMaybe<LibraTransfersMeasureable>;
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_ScriptHashArgs = {
  scriptHash?: InputMaybe<StringSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_TxSenderArgs = {
  txSender?: InputMaybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfers_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};

export type LibraTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Block */
  | 'height'
  /** Receiver */
  | 'receiver'
  /** Script Hash */
  | 'script_hash'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transfer Sender */
  | 'tx_sender'
  /** Version */
  | 'version'
  /** Version hash */
  | 'version_hash';

/** Limit by definition */
export type LimitByOption = {
  /** Take limit for each combination of the field */
  each: Scalars['String'];
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']>;
};

/** Solana Log */
export type Log = {
  __typename?: 'Log';
  consumed: Scalars['BigInt'];
  instruction: Scalars['String'];
  logs: Scalars['String'];
  result: Scalars['String'];
  totalGas: Scalars['BigInt'];
};

/** Blockchain message */
export type MessageHash = {
  __typename?: 'MessageHash';
  /** Message hash hex representation */
  messageHash: Scalars['String'];
};

/** Smart contract method */
export type Method = {
  __typename?: 'Method';
  /** Name */
  name?: Maybe<Scalars['String']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature Hash */
  signatureHash: Scalars['String'];
};

/** Smart contract method. In selector you can use the name, signature or hex hash */
export type MethodSelector = {
  /** Method signature in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Method signature is */
  is?: InputMaybe<Scalars['String']>;
  /** Method signature not */
  not?: InputMaybe<Scalars['String']>;
  /** Method signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Query metric object */
export type Metric = {
  __typename?: 'Metric';
  /** Metric cost */
  cost: Scalars['Float'];
  /** Metric divider */
  divider: Scalars['BigInt'];
  /** Metric maximum */
  max: Scalars['BigInt'];
  /** Metric maximum unit */
  maxUnit: Scalars['Float'];
  /** Metric minimum */
  min: Scalars['BigInt'];
  /** Metric minimum unit */
  minUnit: Scalars['Float'];
  /** Metric name */
  name: Scalars['String'];
  /** Metric price */
  price: Scalars['Float'];
  /** Metric value */
  value: Scalars['BigInt'];
  /** Metric value unit */
  valueUnit: Scalars['Float'];
};

/** Query metrics */
export type Metrics = {
  __typename?: 'Metrics';
  /** Graphql query ID */
  id: Scalars['String'];
  /** Metrics */
  list: Array<Metric>;
  /** Points */
  points: Scalars['Float'];
  /** SQL requests count */
  sqlRequestsCount: Scalars['Int'];
};

/** Information about miniblock */
export type MiniblockElrond = {
  __typename?: 'MiniblockElrond';
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']>;
};

/** Name with an identifier */
export type NameWithId = {
  __typename?: 'NameWithId';
  /** ID */
  id?: Maybe<Scalars['Int']>;
  /** Name */
  name?: Maybe<Scalars['String']>;
};

export type Network =
  /** Algorand Mainnet (ALGO) */
  | 'algorand'
  /** Algorand Betanet */
  | 'algorand_betanet'
  /** Algorand Testnet */
  | 'algorand_testnet'
  /** Avalanche C-chain */
  | 'avalanche'
  /** Binance DEX */
  | 'binance'
  /** Bitcoin Cash ( BCH ) */
  | 'bitcash'
  /** Bitcoin ( BTC ) */
  | 'bitcoin'
  /** Bitcoin SV ( BSV ) */
  | 'bitcoinsv'
  /** Binance Smart Chain Mainnet */
  | 'bsc'
  /** Binance Smart Chain Testnet */
  | 'bsc_testnet'
  /** Cardano ( ADA ) */
  | 'cardano'
  /** Celo Alfajores Testnet */
  | 'celo_alfajores'
  /** Celo Baklava Testnet */
  | 'celo_baklava'
  /** Celo Mainnet */
  | 'celo_mainnet'
  /** DEPRECATED. Use celo_mainnet */
  | 'celo_rc1'
  /** Conflux Hydra */
  | 'conflux_hydra'
  /** Conflux Oceanus */
  | 'conflux_oceanus'
  /** Conflux Tethys */
  | 'conflux_tethys'
  /** Cosmos Hub */
  | 'cosmoshub'
  /** Cronos Mainnet */
  | 'cronos'
  /** Crypto.org Mainnet */
  | 'crypto_mainnet'
  /** Crypto.org Croeseid Testnet */
  | 'crypto_testnet'
  /** Dash ( DASH ) */
  | 'dash'
  /** Diem Testnet */
  | 'diem_testnet'
  /** Dogecoin ( DOGE ) */
  | 'dogecoin'
  /** Elrond Mainnet */
  | 'elrond'
  /** EOS Mainnet */
  | 'eos'
  /** Beacon Chain Ethereum 2.0 */
  | 'eth2'
  /** Ethereum Classic */
  | 'ethclassic'
  /** Ethereum Classic ( no reorg from block 10904146) */
  | 'ethclassic_reorg'
  /** Ethereum Mainnet */
  | 'ethereum'
  /** Ethereum PoW */
  | 'ethpow'
  /** Everscale */
  | 'everscale'
  /** Fantom Mainnet */
  | 'fantom'
  /** Filecoin Mainnet */
  | 'filecoin'
  /** Flow Mainnet */
  | 'flow'
  /** Goerli Ethereum Testnet */
  | 'goerli'
  /** Harmony Mainnet */
  | 'harmony'
  /** Harmony Testnet */
  | 'harmony_testnet'
  /** Hedera Hashgraph */
  | 'hedera'
  /** Heimdall (Matic Verification Network) */
  | 'heimdall'
  /** Klaytn Mainnet */
  | 'klaytn'
  /** Libra Testnet */
  | 'libra_testnet'
  /** Litecoin ( LTC ) */
  | 'litecoin'
  /** Matic (Polygon) Mainnet */
  | 'matic'
  /** Medalla Ethereum 2.0 Beacon Testnet */
  | 'medalla'
  /** Moonbeam Mainnet */
  | 'moonbeam'
  /** Ripple XRP Ledger */
  | 'ripple'
  /** Solana Mainnet */
  | 'solana'
  /** Stellar Ledger */
  | 'stellar'
  /** Terra Mainnet */
  | 'terra'
  /** Tezos */
  | 'tezos'
  /** TRON Mainnet */
  | 'tron'
  /** Velas Mainnet */
  | 'velas'
  /** Velas Testnet */
  | 'velas_testnet'
  /** Zcash ( ZEC ) */
  | 'zcash';

/** Blockchain operation */
export type OperationIndexed = {
  __typename?: 'OperationIndexed';
  /** Operation index */
  index: Scalars['Int'];
  /** Operation name */
  name: Scalars['String'];
};

/** Blockchain operation */
export type OperationIndexedWithAccount = {
  __typename?: 'OperationIndexedWithAccount';
  /** Operation index */
  index: Scalars['Int'];
  /** Operation name */
  name: Scalars['String'];
  /** Operation account */
  sourceAccount: Address;
};

/** Select order by ID */
export type OrderIdSelector = {
  /** Order ID in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Order ID is */
  is?: InputMaybe<Scalars['String']>;
  /** Order ID not */
  not?: InputMaybe<Scalars['String']>;
  /** Order ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Select by order side */
export type OrderSideSelector = {
  /** Order Side in the list */
  in?: InputMaybe<Array<BinanceOrderSide>>;
  /** Order Side is */
  is?: InputMaybe<BinanceOrderSide>;
  /** Order Side not */
  not?: InputMaybe<BinanceOrderSide>;
  /** Order Side not in the list */
  notIn?: InputMaybe<Array<BinanceOrderSide>>;
};

/** Select by order status */
export type OrderStatusSelector = {
  /** Order Status in the list */
  in?: InputMaybe<Array<BinanceOrderStatus>>;
  /** Order Status is */
  is?: InputMaybe<BinanceOrderStatus>;
  /** Order Status not */
  not?: InputMaybe<BinanceOrderStatus>;
  /** Order Status not in the list */
  notIn?: InputMaybe<Array<BinanceOrderStatus>>;
};

/** Select by order time in force */
export type OrderTimeInForceSelector = {
  /** Order TimeInForce in the list */
  in?: InputMaybe<Array<BinanceOrderTimeInForce>>;
  /** Order TimeInForce is */
  is?: InputMaybe<BinanceOrderTimeInForce>;
  /** Order TimeInForce not */
  not?: InputMaybe<BinanceOrderTimeInForce>;
  /** Order TimeInForce not in the list */
  notIn?: InputMaybe<Array<BinanceOrderTimeInForce>>;
};

/** Select by order type */
export type OrderTypeSelector = {
  /** Order Type in the list */
  in?: InputMaybe<Array<BinanceOrderType>>;
  /** Order Type is */
  is?: InputMaybe<BinanceOrderType>;
  /** Order Type not */
  not?: InputMaybe<BinanceOrderType>;
  /** Order Type not in the list */
  notIn?: InputMaybe<Array<BinanceOrderType>>;
};

/** Select by output index ( o based ) */
export type OutputIndexSelector = {
  /** Output index in range */
  between?: InputMaybe<Array<Scalars['Int']>>;
  /** Output index greater than */
  gt?: InputMaybe<Scalars['Int']>;
  /** Output index greater or equal than */
  gteq?: InputMaybe<Scalars['Int']>;
  /** Output index in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Output index is */
  is?: InputMaybe<Scalars['Int']>;
  /** Output index less than */
  lt?: InputMaybe<Scalars['Int']>;
  /** Output index less or equal than */
  lteq?: InputMaybe<Scalars['Int']>;
  /** Output index not */
  not?: InputMaybe<Scalars['Int']>;
  /** Output index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Output Script Type of UTXO transaction output */
export type OutputScript = {
  __typename?: 'OutputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']>;
  /** Long script pattern */
  pattern: Scalars['String'];
  /** Short script pattern */
  short: Scalars['String'];
  /** Simple script pattern */
  simplePattern: Scalars['String'];
  /** Script type */
  type?: Maybe<Scalars['String']>;
};

export type PriceAggregateFunction =
  /** Any value */
  | 'any'
  /** Last value */
  | 'anyLast'
  /** Average */
  | 'average'
  /** Maximum */
  | 'maximum'
  /** Median */
  | 'median'
  /** Minimum */
  | 'minimum'
  /** Aggregated over interval */
  | 'sum';

/** Solana Program */
export type Program = {
  __typename?: 'Program';
  id: Scalars['String'];
  name: Scalars['String'];
  parsed: Scalars['Boolean'];
  parsedName: Scalars['String'];
};

export type Protocol =
  /** Algorand */
  | 'algorand'
  /** Binance DEX */
  | 'binance'
  /** Bitcoin */
  | 'bitcoin'
  /** Cardano */
  | 'cardano'
  /** Conflux */
  | 'conflux'
  /** Cosmos */
  | 'cosmos'
  /** Elrond */
  | 'elrond'
  /** EOS */
  | 'eos'
  /** Ethereum */
  | 'ethereum'
  /** Everscale */
  | 'everscale'
  /** Filecoin */
  | 'filecoin'
  /** Flow */
  | 'flow'
  /** Harmony */
  | 'harmony'
  /** Hedera Hashgraph */
  | 'hedera'
  /** Libra */
  | 'libra'
  /** Ripple XRP Ledger */
  | 'ripple'
  /** Solana */
  | 'solana'
  /** Stellar Ledger */
  | 'stellar'
  /** Tezos */
  | 'tezos'
  /** Tron */
  | 'tron';

/** Blockchain Unified GraphQL API */
export type Query = {
  __typename?: 'Query';
  /** Algorand Chains Dataset */
  algorand?: Maybe<Algorand>;
  /** Binance DEX Chain Dataset */
  binance?: Maybe<Binance>;
  /** Bitcoin and other UTXO Chains Dataset */
  bitcoin?: Maybe<Bitcoin>;
  /** Cardano Chain Dataset */
  cardano?: Maybe<Cardano>;
  /** Conflux Chains Dataset */
  conflux?: Maybe<Conflux>;
  /** Cosmos Dataset */
  cosmos?: Maybe<Cosmos>;
  /** Diem ( former Libra ) Testnet Dataset */
  diem?: Maybe<Libra>;
  /** Elrond Dataset */
  elrond?: Maybe<Elrond>;
  /** EOS Mainnet Dataset */
  eos?: Maybe<Eos>;
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<Ethereum>;
  /** Ethereum v2.0 Beacon Chain Datasets */
  ethereum2?: Maybe<Ethereum2>;
  /** Everscale Dataset */
  everscale?: Maybe<Everscale>;
  /** Filecoin Dataset */
  filecoin?: Maybe<Filecoin>;
  /** Flow Dataset */
  flow?: Maybe<Flow>;
  /** Harmony Dataset */
  harmony?: Maybe<Harmony>;
  /** Hedera Dataset */
  hedera?: Maybe<Hedera>;
  /**
   * Query metrics
   * @deprecated DEPRECATED! Please use utilities { metrics }
   */
  metrics?: Maybe<Metrics>;
  /** Ripple Dataset */
  ripple?: Maybe<Ripple>;
  /** Search by query string */
  search?: Maybe<Array<Result>>;
  /** Solana Dataset */
  solana?: Maybe<Solana>;
  /** Stellar Dataset */
  stellar?: Maybe<Stellar>;
  /** Tezos Dataset */
  tezos?: Maybe<Tezos>;
  /** Tron Mainnet Dataset */
  tron?: Maybe<Tron>;
  /** Utilities */
  utilities?: Maybe<Utilities>;
};


/** Blockchain Unified GraphQL API */
export type Query_AlgorandArgs = {
  network?: InputMaybe<AlgorandNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_BitcoinArgs = {
  network?: InputMaybe<BitcoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_CardanoArgs = {
  network?: InputMaybe<CardanoNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_ConfluxArgs = {
  network?: InputMaybe<ConfluxNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_CosmosArgs = {
  network?: InputMaybe<CosmosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_DiemArgs = {
  network?: InputMaybe<DiemNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_ElrondArgs = {
  network?: InputMaybe<ElrondNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_EosArgs = {
  network?: InputMaybe<EosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_EthereumArgs = {
  network?: InputMaybe<EthereumNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_Ethereum2Args = {
  network?: InputMaybe<Ethereum2Network>;
};


/** Blockchain Unified GraphQL API */
export type Query_EverscaleArgs = {
  network?: InputMaybe<EverscaleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_FilecoinArgs = {
  network?: InputMaybe<FilecoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_FlowArgs = {
  network?: InputMaybe<FlowNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_HarmonyArgs = {
  network?: InputMaybe<HarmonyNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_HederaArgs = {
  network?: InputMaybe<HederaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_MetricsArgs = {
  options?: InputMaybe<SeedOptions>;
  queryId: Scalars['String'];
};


/** Blockchain Unified GraphQL API */
export type Query_RippleArgs = {
  network?: InputMaybe<RippleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_SearchArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  network?: InputMaybe<Network>;
  offset?: InputMaybe<Scalars['Int']>;
  string: Scalars['String'];
};


/** Blockchain Unified GraphQL API */
export type Query_SolanaArgs = {
  network?: InputMaybe<SolanaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_StellarArgs = {
  network?: InputMaybe<StellarNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_TezosArgs = {
  network?: InputMaybe<TezosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type Query_TronArgs = {
  network?: InputMaybe<TronNetwork>;
};

/** Limits, Ordering, Constraints */
export type QueryOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']>>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<LimitByOption>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']>;
};

/** Solana Receiver */
export type Receiver = {
  __typename?: 'Receiver';
  address: Scalars['String'];
  mintAccount: Scalars['String'];
  type: Scalars['String'];
};

/** Search result item */
export type Result = {
  __typename?: 'Result';
  /** Blockchain where result is found */
  network: BlockchainNetwork;
  /** Subject in blockchain */
  subject: Subject;
};

/** Select by reward type */
export type RewardTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<SolanaRewardType>>;
  /** Type is */
  is?: InputMaybe<SolanaRewardType>;
  /** Type not */
  not?: InputMaybe<SolanaRewardType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<SolanaRewardType>>;
};

/** Ripple Chain */
export type Ripple = {
  __typename?: 'Ripple';
  /** Ripple Account Roots */
  accountRoots?: Maybe<Array<RippleAccountRoot>>;
  /** Basic information about address */
  address: Array<RippleAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<RippleAddressStats>>;
  /** Ripple Balances */
  balances?: Maybe<Array<RippleBalance>>;
  /** Ripple Blocks */
  blocks?: Maybe<Array<RippleBlock>>;
  /** Ripple Checks */
  checks?: Maybe<Array<RippleCheck>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<RippleCoinpath>>;
  /** Ripple Escrows */
  escrows?: Maybe<Array<RippleEscrow>>;
  /** Ripple NFTokenOffers */
  nftokenOffers?: Maybe<Array<RippleNfTokenOffer>>;
  /** Ripple Offers */
  offers?: Maybe<Array<RippleOffer>>;
  /** Ripple Payments */
  payments?: Maybe<Array<RipplePayment>>;
  /** Ripple Ripple States */
  rippleStates?: Maybe<Array<RippleRippleState>>;
  /** Ripple Transactions */
  transactions?: Maybe<Array<RippleTransaction>>;
  /** Ripple Transfers */
  transfers?: Maybe<Array<RippleTransfer>>;
};


/** Ripple Chain */
export type Ripple_AccountRootsArgs = {
  account?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RippleAccountRootFilter>>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};


/** Ripple Chain */
export type Ripple_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Ripple Chain */
export type Ripple_AddressStatsArgs = {
  address: AddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** Ripple Chain */
export type Ripple_BalancesArgs = {
  account?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RippleBalanceFilter>>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_BlocksArgs = {
  accountHash?: InputMaybe<HashSelector>;
  any?: InputMaybe<Array<RippleBlockFilter>>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BigIntIdSelector>;
  options?: InputMaybe<QueryOptions>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  transactionHash?: InputMaybe<HashSelector>;
};


/** Ripple Chain */
export type Ripple_ChecksArgs = {
  account?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RippleCheckFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoiceId?: InputMaybe<StringSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sendMax?: InputMaybe<FloatSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currencyFrom?: InputMaybe<CurrencySelector>;
  currencyTo?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Ripple Chain */
export type Ripple_EscrowsArgs = {
  account?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<RippleEscrowFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  cancelAfter?: InputMaybe<BigIntIdSelector>;
  condition?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  finishAfter?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_NftokenOffersArgs = {
  any?: InputMaybe<Array<RippleNftokenOfferFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destinationAccount?: InputMaybe<AddressSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  fromAccount?: InputMaybe<AddressSelector>;
  mount?: InputMaybe<FloatSelector>;
  nftokenAmount?: InputMaybe<FloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<CurrencySelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_OffersArgs = {
  account?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RippleOfferFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_PaymentsArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RipplePaymentFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoice?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Ripple Chain */
export type Ripple_RippleStatesArgs = {
  any?: InputMaybe<Array<RippleRippleStateFilter>>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_TransactionsArgs = {
  accountTxnId?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<RippleTransactionFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  lastLedgerSequence?: InputMaybe<BigIntIdSelector>;
  memos?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  result?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Ripple Chain */
export type Ripple_TransfersArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<RippleTransferFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

/** Account root in Ripple blockchain */
export type RippleAccountRoot = {
  __typename?: 'RippleAccountRoot';
  /** Account */
  account?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Domain */
  domain?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  ownerCount?: Maybe<Scalars['BigInt']>;
  prevBalance?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
  transferRate?: Maybe<Scalars['BigInt']>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_AnyArgs = {
  of: RippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_BalanceArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
  uniq?: InputMaybe<RippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
  uniq?: InputMaybe<RippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_ExpressionArgs = {
  get: Scalars['String'];
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_MaximumArgs = {
  get?: InputMaybe<RippleAccountRootMeasurable>;
  of: RippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_MinimumArgs = {
  get?: InputMaybe<RippleAccountRootMeasurable>;
  of: RippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_OwnerCountArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_PrevBalanceArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type RippleAccountRoot_TransferRateArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};

export type RippleAccountRootFilter = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  domain?: InputMaybe<StringSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  ownerCount?: InputMaybe<BigIntIdSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  transferRate?: InputMaybe<BigIntIdSelector>;
};

export type RippleAccountRootMeasurable =
  /** Account */
  | 'account'
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Domain */
  | 'domain'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Owner count */
  | 'ownerCount'
  /** Prev balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Sequence */
  | 'sequence'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType'
  /** Transfer rate */
  | 'transferRate';

export type RippleAccountRootUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq domains count */
  | 'domains'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Address detailed information for Ripple network */
export type RippleAddressInfo = {
  __typename?: 'RippleAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** XRP balance */
  balance?: Maybe<Scalars['Float']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<RippleTokenBalances>>;
};


/** Address detailed information for Ripple network */
export type RippleAddressInfo_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type RippleAddressStat = {
  __typename?: 'RippleAddressStat';
  /** Address */
  address?: Maybe<Address>;
  /** Balance */
  balance?: Maybe<Scalars['BigInt']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BigInt']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BigInt']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BigInt']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BigInt']>;
  /** First transfer at */
  firstTransferAt?: Maybe<DateTime>;
  /** First tx at */
  firstTxAt?: Maybe<DateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<DateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<DateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['BigInt']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BigInt']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BigInt']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BigInt']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['BigInt']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BigInt']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BigInt']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BigInt']>;
};

/** AddressStat */
export type RippleAddressStats = {
  __typename?: 'RippleAddressStats';
  /** Address With Statistics */
  address?: Maybe<RippleAddressStat>;
};

/** Balance in Ripple blockchain */
export type RippleBalance = {
  __typename?: 'RippleBalance';
  /** Account */
  account?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['Float']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Issuer */
  issuer?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  prevBalance?: Maybe<Scalars['Float']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Balance in Ripple blockchain */
export type RippleBalance_AnyArgs = {
  of: RippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type RippleBalance_BalanceArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Balance in Ripple blockchain */
export type RippleBalance_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type RippleBalance_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type RippleBalance_ExpressionArgs = {
  get: Scalars['String'];
};


/** Balance in Ripple blockchain */
export type RippleBalance_MaximumArgs = {
  get?: InputMaybe<RippleBalanceMeasurable>;
  of: RippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type RippleBalance_MinimumArgs = {
  get?: InputMaybe<RippleBalanceMeasurable>;
  of: RippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type RippleBalance_PrevBalanceArgs = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleBalanceFilter = {
  account?: InputMaybe<AddressSelector>;
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  issuer?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleBalanceMeasurable =
  /** Account */
  | 'account'
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Flags */
  | 'flags'
  /** Issuer */
  | 'issuer'
  /** Operation */
  | 'operation'
  /** Prev balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleBalanceUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Block in Ripple blockchain */
export type RippleBlock = {
  __typename?: 'RippleBlock';
  /** Account hash */
  accountHash?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block hash */
  hash?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  totalCoins?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
};


/** Block in Ripple blockchain */
export type RippleBlock_AnyArgs = {
  of: RippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type RippleBlock_CountArgs = {
  accountHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<RippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type RippleBlock_CountBigIntArgs = {
  accountHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<RippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type RippleBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Ripple blockchain */
export type RippleBlock_MaximumArgs = {
  get?: InputMaybe<RippleBlockMeasurable>;
  of: RippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type RippleBlock_MinimumArgs = {
  get?: InputMaybe<RippleBlockMeasurable>;
  of: RippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type RippleBlock_TotalCoinsArgs = {
  accountHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  transactionHash?: InputMaybe<HashSelector>;
};

export type RippleBlockFilter = {
  accountHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  transactionHash?: InputMaybe<HashSelector>;
};

export type RippleBlockMeasurable =
  /** Account hash */
  | 'accountHash'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Hash */
  | 'hash'
  /** Time */
  | 'time'
  /** Total coins */
  | 'totalCoins'
  /** Transaction hash */
  | 'transactionHash';

export type RippleBlockUniq =
  /** Uniq account hashes count */
  | 'accountHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq transaction hashes count */
  | 'transactionHashes';

/** Check in Ripple blockchain */
export type RippleCheck = {
  __typename?: 'RippleCheck';
  /** Account */
  account?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Destination */
  destination?: Maybe<Address>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BigInt']>;
  /** Expiration */
  expiration?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Invoice */
  invoiceId?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  sendMax?: Maybe<Scalars['Float']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Check in Ripple blockchain */
export type RippleCheck_AnyArgs = {
  of: RippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type RippleCheck_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoiceId?: InputMaybe<StringSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sendMax?: InputMaybe<FloatSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type RippleCheck_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoiceId?: InputMaybe<StringSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sendMax?: InputMaybe<FloatSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type RippleCheck_ExpressionArgs = {
  get: Scalars['String'];
};


/** Check in Ripple blockchain */
export type RippleCheck_MaximumArgs = {
  get?: InputMaybe<RippleCheckMeasurable>;
  of: RippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type RippleCheck_MinimumArgs = {
  get?: InputMaybe<RippleCheckMeasurable>;
  of: RippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type RippleCheck_SendMaxArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invoiceId?: InputMaybe<StringSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sendMax?: InputMaybe<FloatSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleCheckFilter = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoiceId?: InputMaybe<StringSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sendMax?: InputMaybe<FloatSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleCheckMeasurable =
  /** Account */
  | 'account'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination */
  | 'destination'
  /** Destination tag */
  | 'destinationTag'
  /** Expiration */
  | 'expiration'
  /** Flags */
  | 'flags'
  /** Invoice */
  | 'invoiceId'
  /** Operation */
  | 'operation'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Send max */
  | 'sendMax'
  /** Sequence */
  | 'sequence'
  /** Source tag */
  | 'sourceTag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleCheckUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination tags count */
  | 'destinationTags'
  /** Uniq destinations count */
  | 'destinations'
  /** Uniq expirations count */
  | 'expirations'
  /** Uniq flags count */
  | 'flags'
  /** Uniq invoice ids count */
  | 'invoiceIds'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Ripple Coinpath */
export type RippleCoinpath = {
  __typename?: 'RippleCoinpath';
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<Currency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<StellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<StellarCoinpathAddress>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['String']>;
  /** Transaction of transfer happened */
  transaction?: Maybe<StellarTransactionCoinpathDimension>;
};


/** Ripple Coinpath */
export type RippleCoinpath_AmountFromArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type RippleCoinpath_AmountToArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type RippleCoinpath_AnyArgs = {
  of: RippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type RippleCoinpath_MaximumArgs = {
  get?: InputMaybe<RippleCoinpathMeasureable>;
  of: RippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type RippleCoinpath_MinimumArgs = {
  get?: InputMaybe<RippleCoinpathMeasureable>;
  of: RippleCoinpathMeasureable;
};

export type RippleCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Escrow in Ripple blockchain */
export type RippleEscrow = {
  __typename?: 'RippleEscrow';
  /** Account */
  account?: Maybe<Address>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  /** Cancel after */
  cancelAfter?: Maybe<Scalars['BigInt']>;
  /** Condition */
  condition?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Destination */
  destination?: Maybe<Address>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Finish after */
  finishAfter?: Maybe<Scalars['BigInt']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_AmountArgs = {
  account?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  cancelAfter?: InputMaybe<BigIntIdSelector>;
  condition?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  finishAfter?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_AnyArgs = {
  of: RippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  cancelAfter?: InputMaybe<BigIntIdSelector>;
  condition?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  finishAfter?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  cancelAfter?: InputMaybe<BigIntIdSelector>;
  condition?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  finishAfter?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_ExpressionArgs = {
  get: Scalars['String'];
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_MaximumArgs = {
  get?: InputMaybe<RippleEscrowMeasurable>;
  of: RippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type RippleEscrow_MinimumArgs = {
  get?: InputMaybe<RippleEscrowMeasurable>;
  of: RippleEscrowMeasurable;
};

export type RippleEscrowFilter = {
  account?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  cancelAfter?: InputMaybe<BigIntIdSelector>;
  condition?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destination?: InputMaybe<StringSelector>;
  destinationTag?: InputMaybe<BigIntIdSelector>;
  finishAfter?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleEscrowMeasurable =
  /** Account */
  | 'account'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Cancel after */
  | 'cancelAfter'
  /** Condition */
  | 'condition'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination */
  | 'destination'
  /** Destination tag */
  | 'destinationTag'
  /** Finish after */
  | 'finishAfter'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Source tag */
  | 'sourceTag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleEscrowUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq cancel afters count */
  | 'cancelAfters'
  /** Uniq conditions count */
  | 'conditions'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination tags count */
  | 'destinationTags'
  /** Uniq destinations count */
  | 'destinations'
  /** Uniq finish afters count */
  | 'finishAfters'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer = {
  __typename?: 'RippleNFTokenOffer';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Taker pays currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Destination Account */
  destinationAccount?: Maybe<Address>;
  /** Expiration */
  expiration?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** From Account */
  fromAccount?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  nftokenAmount?: Maybe<Scalars['Float']>;
  /** NFToken Buy Offer */
  nftokenBuyOffer?: Maybe<Scalars['String']>;
  /** Taker gets currency */
  nftokenCurrency?: Maybe<Currency>;
  /** NFToken Sell Offer */
  nftokenSellOffer?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_AmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_AnyArgs = {
  of: RippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_ExpressionArgs = {
  get: Scalars['String'];
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_MaximumArgs = {
  get?: InputMaybe<RippleOfferMeasurable>;
  of: RippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_MinimumArgs = {
  get?: InputMaybe<RippleOfferMeasurable>;
  of: RippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type RippleNfTokenOffer_NftokenAmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleNetwork =
  /** Ripple XRP Ledger */
  | 'ripple';

export type RippleNftokenOfferFilter = {
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  destinationAccount?: InputMaybe<AddressSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  fromAccount?: InputMaybe<AddressSelector>;
  mount?: InputMaybe<FloatSelector>;
  nftokenAmount?: InputMaybe<FloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<CurrencySelector>;
  operation?: InputMaybe<StringSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

/** Offer in Ripple blockchain */
export type RippleOffer = {
  __typename?: 'RippleOffer';
  /** Account */
  account?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Expiration */
  expiration?: Maybe<Scalars['BigInt']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  preTakerGetsAmount?: Maybe<Scalars['Float']>;
  preTakerPaysAmount?: Maybe<Scalars['Float']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  takerGetsAmount?: Maybe<Scalars['Float']>;
  /** Taker gets currency */
  takerGetsCurrency?: Maybe<Currency>;
  takerPaysAmount?: Maybe<Scalars['Float']>;
  /** Taker pays currency */
  takerPaysCurrency?: Maybe<Currency>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_AnyArgs = {
  of: RippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type RippleOffer_CountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_CountBigIntArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Offer in Ripple blockchain */
export type RippleOffer_MaximumArgs = {
  get?: InputMaybe<RippleOfferMeasurable>;
  of: RippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type RippleOffer_MinimumArgs = {
  get?: InputMaybe<RippleOfferMeasurable>;
  of: RippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type RippleOffer_PreTakerGetsAmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_PreTakerPaysAmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_TakerGetsAmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Offer in Ripple blockchain */
export type RippleOffer_TakerPaysAmountArgs = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleOfferFilter = {
  account?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  bookDirectory?: InputMaybe<StringSelector>;
  bookNode?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  expiration?: InputMaybe<BigIntIdSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  operation?: InputMaybe<StringSelector>;
  preTakerGetsAmount?: InputMaybe<FloatSelector>;
  preTakerPaysAmount?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<BigIntIdSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  takerGetsAmount?: InputMaybe<FloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<CurrencySelector>;
  takerPaysAmount?: InputMaybe<FloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<CurrencySelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleOfferMeasurable =
  /** Account */
  | 'account'
  /** Block */
  | 'block'
  /** Book directory */
  | 'bookDirectory'
  /** Book node */
  | 'bookNode'
  /** Date */
  | 'date'
  /** Expiration */
  | 'expiration'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Pre taker gets amount */
  | 'preTakerGetsAmount'
  /** Pre taker pays amount */
  | 'preTakerPaysAmount'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Sequence */
  | 'sequence'
  /** Taker gets amount */
  | 'takerGetsAmount'
  /** Taker gets currency name */
  | 'takerGetsCurrencyName'
  /** Taker gets currency symbol */
  | 'takerGetsCurrencySymbol'
  /** Taker pays amount */
  | 'takerPaysAmount'
  /** Taker pays currency name */
  | 'takerPaysCurrencyName'
  /** Taker pays currency symbol */
  | 'takerPaysCurrencySymbol'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleOfferUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq book directories count */
  | 'bookDirectories'
  /** Uniq book nodes count */
  | 'bookNodes'
  /** Uniq dates count */
  | 'dates'
  /** Uniq expirations count */
  | 'expirations'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq taker gets currency names count */
  | 'takerGetsCurrencyNames'
  /** Uniq taker gets currency symbols count */
  | 'takerGetsCurrencySymbols'
  /** Uniq taker pays currency names count */
  | 'takerPaysCurrencyNames'
  /** Uniq taker pays currency symbols count */
  | 'takerPaysCurrencySymbols'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Payment in Ripple blockchain */
export type RipplePayment = {
  __typename?: 'RipplePayment';
  amount?: Maybe<Scalars['Float']>;
  /** Amount currency */
  amountCurrency?: Maybe<Currency>;
  /** Amount issuer */
  amountIssuer?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  deliverMinAmount?: Maybe<Scalars['Float']>;
  /** Deliver min currency */
  deliverMinCurrency?: Maybe<Currency>;
  /** Deliver min issuer */
  deliverMinIssuer?: Maybe<Address>;
  deliveredAmount?: Maybe<Scalars['Float']>;
  /** Delivered currency */
  deliveredCurrency?: Maybe<Currency>;
  /** Delivered issuer */
  deliveredIssuer?: Maybe<Address>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Invoice */
  invoice?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Partial */
  partial?: Maybe<Scalars['Boolean']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  sendMaxAmount?: Maybe<Scalars['Float']>;
  /** Send max currency */
  sendMaxCurrency?: Maybe<Currency>;
  /** Send max issuer */
  sendMaxIssuer?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Tag */
  tag?: Maybe<Scalars['BigInt']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionHashIndexDimension>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_AmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_AnyArgs = {
  of: RipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type RipplePayment_CountArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<RipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_CountBigIntArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<RipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_DeliverMinAmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_DeliveredAmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Payment in Ripple blockchain */
export type RipplePayment_ExpressionArgs = {
  get: Scalars['String'];
};


/** Payment in Ripple blockchain */
export type RipplePayment_MaximumArgs = {
  get?: InputMaybe<RipplePaymentMeasurable>;
  of: RipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type RipplePayment_MinimumArgs = {
  get?: InputMaybe<RipplePaymentMeasurable>;
  of: RipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type RipplePayment_SendMaxAmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type RipplePaymentFilter = {
  amount?: InputMaybe<FloatSelector>;
  amountCurrency?: InputMaybe<CurrencySelector>;
  amountIssuer?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  deliverMinAmount?: InputMaybe<FloatSelector>;
  deliverMinCurrency?: InputMaybe<CurrencySelector>;
  deliverMinIssuer?: InputMaybe<AddressSelector>;
  deliveredAmount?: InputMaybe<FloatSelector>;
  deliveredCurrency?: InputMaybe<CurrencySelector>;
  deliveredIssuer?: InputMaybe<AddressSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  invoice?: InputMaybe<StringSelector>;
  partial?: InputMaybe<BooleanSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sendMaxAmount?: InputMaybe<FloatSelector>;
  sendMaxCurrency?: InputMaybe<CurrencySelector>;
  sendMaxIssuer?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  tag?: InputMaybe<BigIntIdSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type RipplePaymentMeasurable =
  /** Amount */
  | 'amount'
  /** Amount currency name */
  | 'amountCurrencyName'
  /** Amount currency symbol */
  | 'amountCurrencySymbol'
  /** Amount issuer */
  | 'amountIssuer'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Deliver min amount */
  | 'deliverMinAmount'
  /** Deliver min currency name */
  | 'deliverMinCurrencyName'
  /** Deliver min currency symbol */
  | 'deliverMinCurrencySymbol'
  /** Deliver min issuer */
  | 'deliverMinIssuer'
  /** Delivered amount */
  | 'deliveredAmount'
  /** Delivered currency name */
  | 'deliveredCurrencyName'
  /** Delivered currency symbol */
  | 'deliveredCurrencySymbol'
  /** Delivered issuer */
  | 'deliveredIssuer'
  /** Flags */
  | 'flags'
  /** Invoice */
  | 'invoice'
  /** Partial */
  | 'partial'
  /** Receiver */
  | 'receiver'
  /** Send max amount */
  | 'sendMaxAmount'
  /** Send max currency name */
  | 'sendMaxCurrencyName'
  /** Send max currency symbol */
  | 'sendMaxCurrencySymbol'
  /** Send max issuer */
  | 'sendMaxIssuer'
  /** Sender */
  | 'sender'
  /** Tag */
  | 'tag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex';

export type RipplePaymentUniq =
  /** Uniq amount currency names count */
  | 'amountCurrencyNames'
  /** Uniq amount currency symbols count */
  | 'amountCurrencySymbols'
  /** Uniq amount issuers count */
  | 'amountIssuers'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq deliver min currency names count */
  | 'deliverMinCurrencyNames'
  /** Uniq deliver min currency symbols count */
  | 'deliverMinCurrencySymbols'
  /** Uniq deliver min issuers count */
  | 'deliverMinIssuers'
  /** Uniq delivered currency names count */
  | 'deliveredCurrencyNames'
  /** Uniq delivered currency symbols count */
  | 'deliveredCurrencySymbols'
  /** Uniq delivered issuers count */
  | 'deliveredIssuers'
  /** Uniq flags count */
  | 'flags'
  /** Uniq invoices count */
  | 'invoices'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq send max currency names count */
  | 'sendMaxCurrencyNames'
  /** Uniq send max currency symbols count */
  | 'sendMaxCurrencySymbols'
  /** Uniq send max issuers count */
  | 'sendMaxIssuers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq tags count */
  | 'tags'
  /** Uniq time count */
  | 'time'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices';

/** Ripple state in Ripple blockchain */
export type RippleRippleState = {
  __typename?: 'RippleRippleState';
  any?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['Float']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** High account */
  highAccount?: Maybe<Address>;
  /** Low account */
  lowAccount?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  prevBalance?: Maybe<Scalars['Float']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BigInt']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_AnyArgs = {
  of: RippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_BalanceArgs = {
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_CountArgs = {
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_CountBigIntArgs = {
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_ExpressionArgs = {
  get: Scalars['String'];
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_MaximumArgs = {
  get?: InputMaybe<RippleRippleStateMeasurable>;
  of: RippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_MinimumArgs = {
  get?: InputMaybe<RippleRippleStateMeasurable>;
  of: RippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type RippleRippleState_PrevBalanceArgs = {
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleRippleStateFilter = {
  balance?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencySymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  highAccount?: InputMaybe<AddressSelector>;
  lowAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  prevBalance?: InputMaybe<FloatSelector>;
  prevLedgerSequence?: InputMaybe<BigIntIdSelector>;
  prevTxnId?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleRippleStateMeasurable =
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Flags */
  | 'flags'
  /** High account */
  | 'highAccount'
  /** Low account */
  | 'lowAccount'
  /** Operation */
  | 'operation'
  /** Pre balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleRippleStateUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq high accounts count */
  | 'highAccounts'
  /** Uniq low accounts count */
  | 'lowAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Token Balance */
export type RippleTokenBalances = {
  __typename?: 'RippleTokenBalances';
  /** The unique Address of the counterparty to this trust line. */
  account?: Maybe<Scalars['String']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']>;
  /** Currency */
  currency?: Maybe<Scalars['String']>;
};

/** Transaction in Ripple blockchain */
export type RippleTransaction = {
  __typename?: 'RippleTransaction';
  /** Account txn id */
  accountTxnId?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Hash */
  hash?: Maybe<Scalars['String']>;
  /** Index */
  index?: Maybe<Scalars['Int']>;
  /** Last ledger sequence */
  lastLedgerSequence?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** Memos */
  memos?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Result */
  result?: Maybe<Scalars['String']>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BigInt']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Tx signers */
  txSigners?: Maybe<Scalars['String']>;
  /** Type */
  type?: Maybe<Scalars['String']>;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_AnyArgs = {
  of: RippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_CountArgs = {
  accountTxnId?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  lastLedgerSequence?: InputMaybe<BigIntIdSelector>;
  memos?: InputMaybe<StringSelector>;
  result?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_CountBigIntArgs = {
  accountTxnId?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  lastLedgerSequence?: InputMaybe<BigIntIdSelector>;
  memos?: InputMaybe<StringSelector>;
  result?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_FeeArgs = {
  accountTxnId?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  lastLedgerSequence?: InputMaybe<BigIntIdSelector>;
  memos?: InputMaybe<StringSelector>;
  result?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_MaximumArgs = {
  get?: InputMaybe<RippleTransactionMeasurable>;
  of: RippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type RippleTransaction_MinimumArgs = {
  get?: InputMaybe<RippleTransactionMeasurable>;
  of: RippleTransactionMeasurable;
};

/** Ripple transaction */
export type RippleTransactionDimension = {
  __typename?: 'RippleTransactionDimension';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block */
  index: Scalars['Int'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']>;
  /** Transaction type */
  type?: Maybe<Scalars['String']>;
};

export type RippleTransactionFilter = {
  accountTxnId?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  flags?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  lastLedgerSequence?: InputMaybe<BigIntIdSelector>;
  memos?: InputMaybe<StringSelector>;
  result?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<BigIntIdSelector>;
  sourceTag?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  type?: InputMaybe<StringSelector>;
};

/** Ripple transaction with hash and index */
export type RippleTransactionHashIndexDimension = {
  __typename?: 'RippleTransactionHashIndexDimension';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block */
  index: Scalars['Int'];
};

export type RippleTransactionMeasurable =
  /** Account txn id */
  | 'accountTxnId'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee */
  | 'fee'
  /** Flags */
  | 'flags'
  /** Hash */
  | 'hash'
  /** Index */
  | 'index'
  /** Last ledger sequence */
  | 'lastLedgerSequence'
  /** Memos */
  | 'memos'
  /** Result */
  | 'result'
  /** Sender */
  | 'sender'
  /** Sequence */
  | 'sequence'
  /** Source tag */
  | 'sourceTag'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Type */
  | 'type';

export type RippleTransactionUniq =
  /** Uniq account txn id bins count */
  | 'accountTxnIds'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq indices count */
  | 'indices'
  /** Uniq last ledger sequences count */
  | 'lastLedgerSequences'
  /** Uniq results count */
  | 'results'
  /** Uniq senders count */
  | 'senders'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq types count */
  | 'types';

/** Transfer in Ripple blockchain */
export type RippleTransfer = {
  __typename?: 'RippleTransfer';
  amountFrom?: Maybe<Scalars['Float']>;
  amountTo?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency from */
  currencyFrom?: Maybe<Currency>;
  /** Currency to */
  currencyTo?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<RippleTransactionDimension>;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_AmountFromArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_AmountToArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_AnyArgs = {
  of: RippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_CountArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_CountBigIntArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<RippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_MaximumArgs = {
  get?: InputMaybe<RippleTransferMeasurable>;
  of: RippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type RippleTransfer_MinimumArgs = {
  get?: InputMaybe<RippleTransferMeasurable>;
  of: RippleTransferMeasurable;
};

export type RippleTransferFilter = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<CurrencySelector>;
  currencyToSymbol?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  transactionType?: InputMaybe<StringSelector>;
};

export type RippleTransferMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Block */
  | 'block'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Direction */
  | 'direction'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type RippleTransferUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies from name count */
  | 'currencyFromNames'
  /** Uniq currencies from symbol count */
  | 'currencyFromSymbols'
  /** Uniq currencies to name count */
  | 'currencyToNames'
  /** Uniq currencies to symbol count */
  | 'currencyToSymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq directions count */
  | 'directions'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Smart contract crypto currency ( token, coin, currency ) */
export type ScCurrency = {
  __typename?: 'ScCurrency';
  /** Decimals */
  decimals: Scalars['Int'];
  /** Currency name */
  name?: Maybe<Scalars['String']>;
  /** Currency symbol */
  symbol: Scalars['String'];
  /** Token Type */
  tokenType?: Maybe<Scalars['String']>;
};

export type ScriptTypeSelectorSelector =
  /** Peer-to-peer */
  | 'peer_to_peer_transaction'
  /** Unknown Transaction */
  | 'unknown_transaction';

export type SeedOptions = {
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']>;
};

/** Solana Sender */
export type Sender = {
  __typename?: 'Sender';
  address: Scalars['String'];
  mintAccount: Scalars['String'];
  type: Scalars['String'];
};

/** Smart contract method or event */
export type Signature = Event | Method;

export type SignatureTypeSelector =
  /** Smart contract event */
  | 'Event'
  /** Smart contract method */
  | 'Function';

/** Blockchain smart contract */
export type SmartContract = {
  __typename?: 'SmartContract';
  /** String address representation */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract Type */
  contractType: SmartContractType;
  /** Smart Contract Protocol Type */
  protocol?: Maybe<Scalars['String']>;
};

export type SmartContractArgumentsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique callers count */
  | 'callers'
  /** Calls or events */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique transaction senders */
  | 'senders'
  /** Unique signatures count */
  | 'signatures'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transactions count */
  | 'txs'
  /** Unique values */
  | 'values';

export type SmartContractCallsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique callers count */
  | 'callers'
  /** Calls */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique transaction senders */
  | 'senders'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transactions count */
  | 'txs';

export type SmartContractEventsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Shard ID */
  | 'shard_id'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** To Shard ID */
  | 'to_shard_id'
  /** Unique transaction senders */
  | 'tx_from'
  /** Unique callers count */
  | 'tx_to'
  /** Unique transactions count */
  | 'txs';

/** Blockchain smart contract */
export type SmartContractInfo = {
  __typename?: 'SmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type SmartContractReadonlyAttribute = {
  __typename?: 'SmartContractReadonlyAttribute';
  /** Value as address if applicable */
  address?: Maybe<EthereumAddressInfo>;
  /** Method name */
  name: Scalars['String'];
  /** Method return type */
  type: Scalars['String'];
  /** Method return value */
  value: Scalars['String'];
};

export type SmartContractType =
  /** Decentralized exchange */
  | 'DEX'
  /** General Purpose Smart contract */
  | 'Generic'
  /** Smart contract for token derivatives */
  | 'MarginPositionToken'
  /** Multi signature wallet */
  | 'Multisig'
  /** Not A Smart contract */
  | 'None'
  /** Transaction Execution Approval Language */
  | 'TEAL'
  /** Token */
  | 'Token'
  /** Token Sale */
  | 'TokenSale';

/** Selector of smart contract type */
export type SmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<SmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<SmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<SmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<SmartContractType>>;
};

/** Solana Chain */
export type Solana = {
  __typename?: 'Solana';
  /** Basic information about address */
  address: Array<SolanaAddressInfoWithBalance>;
  /** BlockRewards of Smart Contract Calls and Events */
  blockRewards?: Maybe<Array<SolanaBlockReward>>;
  /** Solana Blocks */
  blocks?: Maybe<Array<SolanaBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<SolanaCoinpath>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructionAccounts?: Maybe<Array<SolanaInstructionAccount>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructions?: Maybe<Array<SolanaInstruction>>;
  /** Solana Transaction */
  transactions?: Maybe<Array<SolanaTransaction>>;
  /** Currency transfers from/to addresses in crypto currencies */
  transfers?: Maybe<Array<SolanaTransfer>>;
};


/** Solana Chain */
export type Solana_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Solana Chain */
export type Solana_BlockRewardsArgs = {
  account?: InputMaybe<StringSelector>;
  any?: InputMaybe<Array<SolanaBlockRewardFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parentSlot?: InputMaybe<IntegerSelector>;
  postBalance?: InputMaybe<AmountSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  reward?: InputMaybe<AmountSelector>;
  rewardType?: InputMaybe<RewardTypeSelector>;
};


/** Solana Chain */
export type Solana_BlocksArgs = {
  any?: InputMaybe<Array<SolanaBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parentSlot?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  rewards?: InputMaybe<AmountSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Solana Chain */
export type Solana_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Solana Chain */
export type Solana_InstructionAccountsArgs = {
  account?: InputMaybe<StringSelector>;
  accountIndex?: InputMaybe<IntegerSelector>;
  accountOwner?: InputMaybe<StringSelector>;
  accountType?: InputMaybe<StringSelector>;
  any?: InputMaybe<Array<SolanaInstructionAccountFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Solana Chain */
export type Solana_InstructionsArgs = {
  any?: InputMaybe<Array<SolanaInstructionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<IntegerSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Solana Chain */
export type Solana_TransactionsArgs = {
  accountsCount?: InputMaybe<IntegerSelector>;
  any?: InputMaybe<Array<SolanaTransactionFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  innerInstructionsCount?: InputMaybe<IntegerSelector>;
  instructionsCount?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  parentSlot?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionFee?: InputMaybe<AmountSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Solana Chain */
export type Solana_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<SolanaTransferFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  currency?: InputMaybe<Array<SolanaCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<StringSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  receiverAddress?: InputMaybe<StringSelector>;
  receiverMintAddress?: InputMaybe<StringSelector>;
  receiverType?: InputMaybe<StringSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  senderAddress?: InputMaybe<StringSelector>;
  senderMintAddress?: InputMaybe<StringSelector>;
  senderType?: InputMaybe<StringSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  tokenAccount?: InputMaybe<Array<StringSelector>>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
};

/** Solana Account */
export type SolanaAccount = {
  __typename?: 'SolanaAccount';
  index: Scalars['Int'];
  name: Scalars['String'];
  owner: Scalars['String'];
  type: Scalars['String'];
};

/** Blockchain address */
export type SolanaAddressInfoWithBalance = {
  __typename?: 'SolanaAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<SmartContractInfo>;
};


/** Blockchain address */
export type SolanaAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Block in Solana  blockchain */
export type SolanaBlock = {
  __typename?: 'SolanaBlock';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['Float']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['Int']>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_AnyArgs = {
  of: SolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type SolanaBlock_BlockHashArgs = {
  blockHash?: InputMaybe<HashSelector>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_CountArgs = {
  uniq?: InputMaybe<SolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_CountBigIntArgs = {
  uniq?: InputMaybe<SolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Solana  blockchain */
export type SolanaBlock_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_MaximumArgs = {
  get?: InputMaybe<SolanaBlockMeasureable>;
  of: SolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type SolanaBlock_MinimumArgs = {
  get?: InputMaybe<SolanaBlockMeasureable>;
  of: SolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type SolanaBlock_ParentSlotArgs = {
  parentSlot?: InputMaybe<IntegerSelector>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_PreviousBlockHashArgs = {
  previousBlockHash?: InputMaybe<HashSelector>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_RewardsArgs = {
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  parentSlot?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  rewards?: InputMaybe<AmountSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};


/** Block in Solana  blockchain */
export type SolanaBlock_TransactionCountArgs = {
  transactionCount?: InputMaybe<IntegerSelector>;
};

export type SolanaBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  parentSlot?: InputMaybe<IntegerSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  rewards?: InputMaybe<AmountSelector>;
  transactionCount?: InputMaybe<IntegerSelector>;
};

/** Solana Block Info */
export type SolanaBlockInfo = {
  __typename?: 'SolanaBlockInfo';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  parentSlot?: Maybe<Scalars['BigInt']>;
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

export type SolanaBlockMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Number of reward lamports credited or debited by the account */
  | 'rewards'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** BlockReward in Solana  blockchain */
export type SolanaBlockReward = {
  __typename?: 'SolanaBlockReward';
  /** Account */
  account?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where  transaction is included */
  block?: Maybe<SolanaBlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  postBalance?: Maybe<Scalars['Float']>;
  /** Type of reward */
  rewardType?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_AccountArgs = {
  account?: InputMaybe<HashSelector>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_AmountArgs = {
  account?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  parentSlot?: InputMaybe<IntegerSelector>;
  postBalance?: InputMaybe<AmountSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  reward?: InputMaybe<AmountSelector>;
  rewardType?: InputMaybe<RewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_AnyArgs = {
  of: SolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_BlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parentSlot?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_CountArgs = {
  uniq?: InputMaybe<SolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_CountBigIntArgs = {
  uniq?: InputMaybe<SolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_ExpressionArgs = {
  get: Scalars['String'];
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_MaximumArgs = {
  get?: InputMaybe<SolanaBlockRewardMeasureable>;
  of: SolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_MinimumArgs = {
  get?: InputMaybe<SolanaBlockRewardMeasureable>;
  of: SolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_PostBalanceArgs = {
  account?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  parentSlot?: InputMaybe<IntegerSelector>;
  postBalance?: InputMaybe<AmountSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  reward?: InputMaybe<AmountSelector>;
  rewardType?: InputMaybe<RewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type SolanaBlockReward_RewardTypeArgs = {
  rewardType?: InputMaybe<RewardTypeSelector>;
};

export type SolanaBlockRewardFilter = {
  account?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  parentSlot?: InputMaybe<IntegerSelector>;
  postBalance?: InputMaybe<AmountSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  reward?: InputMaybe<AmountSelector>;
  rewardType?: InputMaybe<RewardTypeSelector>;
};

export type SolanaBlockRewardMeasureable =
  /** Account */
  | 'account'
  /** Number of reward lamports credited or debited by the account */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** Account balances after the transaction was processed */
  | 'post_balance'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time';

export type SolanaBlockRewardUniq =
  /** Unique accounts */
  | 'account'
  /** Unique hash of the the block */
  | 'block_hash'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique time */
  | 'times';

export type SolanaBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** Solana Coinpath */
export type SolanaCoinpath = {
  __typename?: 'SolanaCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  signature?: Maybe<SolanaSignatureValueDimension>;
};


/** Solana Coinpath */
export type SolanaCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Solana Coinpath */
export type SolanaCoinpath_AnyArgs = {
  of: SolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type SolanaCoinpath_MaximumArgs = {
  get?: InputMaybe<SolanaCoinpathMeasureable>;
  of: SolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type SolanaCoinpath_MinimumArgs = {
  get?: InputMaybe<SolanaCoinpathMeasureable>;
  of: SolanaCoinpathMeasureable;
};

export type SolanaCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Signature */
  | 'signature'
  /** Time */
  | 'time';

/** Crypto currency ( token, coin, currency ) */
export type SolanaCryptoCurrency = {
  __typename?: 'SolanaCryptoCurrency';
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']>;
  /** Decimals */
  decimals: Scalars['Int'];
  /** Currency name */
  name?: Maybe<Scalars['String']>;
  /** Currency symbol */
  symbol: Scalars['String'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']>;
};

/** Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol */
export type SolanaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Instruction in Solana  blockchain */
export type SolanaInstruction = {
  __typename?: 'SolanaInstruction';
  /** Accounts count */
  accountsCount?: Maybe<Scalars['Int']>;
  /** Action */
  action?: Maybe<Action>;
  any?: Maybe<Scalars['String']>;
  /** Block where  transaction is included */
  block?: Maybe<SolanaBlockInfo>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Instruction Data */
  data?: Maybe<Data>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External */
  external?: Maybe<Scalars['Boolean']>;
  /** External Action */
  externalAction?: Maybe<Action>;
  /** External Program */
  externalProgram?: Maybe<Program>;
  log?: Maybe<Log>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Program */
  program?: Maybe<Program>;
  /** Transaction where instruction is included */
  transaction?: Maybe<SolanaTransactionInfo>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ActionArgs = {
  parsedActionName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_AnyArgs = {
  of: SolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_BlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_CallPathArgs = {
  callPath?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_CountArgs = {
  uniq?: InputMaybe<SolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_CountBigIntArgs = {
  uniq?: InputMaybe<SolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_DataArgs = {
  dataBase58?: InputMaybe<StringSelector>;
  dataHex?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ExternalArgs = {
  external?: InputMaybe<BooleanSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ExternalActionArgs = {
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ExternalProgramArgs = {
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  externalProgramName?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_MaximumArgs = {
  get?: InputMaybe<SolanaInstructionMeasureable>;
  of: SolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_MinimumArgs = {
  get?: InputMaybe<SolanaInstructionMeasureable>;
  of: SolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_ProgramArgs = {
  parsedProgramName?: InputMaybe<StringSelector>;
  programId?: InputMaybe<StringSelector>;
  programName?: InputMaybe<StringSelector>;
};


/** Instruction in Solana  blockchain */
export type SolanaInstruction_TransactionArgs = {
  signature?: InputMaybe<HashSelector>;
};

/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount = {
  __typename?: 'SolanaInstructionAccount';
  /** Information about account */
  account?: Maybe<SolanaAccount>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<SolanaBlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Instruction */
  instruction?: Maybe<Instruction>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction */
  transaction?: Maybe<SolanaTransactionInfo>;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_AccountArgs = {
  accountIndex?: InputMaybe<IntegerSelector>;
  accountName?: InputMaybe<StringSelector>;
  accountOwner?: InputMaybe<StringSelector>;
  accountType?: InputMaybe<StringSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_AnyArgs = {
  of: SolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_BlockArgs = {
  blockHash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_CountArgs = {
  uniq?: InputMaybe<SolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_CountBigIntArgs = {
  uniq?: InputMaybe<SolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_ExpressionArgs = {
  get: Scalars['String'];
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_MaximumArgs = {
  get?: InputMaybe<SolanaInstructionAccountMeasureable>;
  of: SolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_MinimumArgs = {
  get?: InputMaybe<SolanaInstructionAccountMeasureable>;
  of: SolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type SolanaInstructionAccount_TransactionArgs = {
  signature?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type SolanaInstructionAccountFilter = {
  account?: InputMaybe<StringSelector>;
  accountIndex?: InputMaybe<IntegerSelector>;
  accountOwner?: InputMaybe<StringSelector>;
  accountType?: InputMaybe<StringSelector>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<IntegerSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type SolanaInstructionAccountMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time';

export type SolanaInstructionAccountUniq =
  /** Account name */
  | 'account_name'
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times';

export type SolanaInstructionFilter = {
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<IntegerSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  signature?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type SolanaInstructionMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time';

export type SolanaInstructionUniq =
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times';

export type SolanaNetwork =
  /** Solana Mainnat */
  | 'solana';

export type SolanaRewardType =
  /** fee type */
  | 'Fee'
  /** rent type */
  | 'Rent'
  /** staking type */
  | 'Staking'
  /** voing type */
  | 'Voting';

/** Blockchain transaction with value */
export type SolanaSignatureValueDimension = {
  __typename?: 'SolanaSignatureValueDimension';
  /** Transaction hash */
  hash: Scalars['String'];
  /** Transaction value */
  value: Scalars['Float'];
};

/** Transaction in Solana  blockchain */
export type SolanaTransaction = {
  __typename?: 'SolanaTransaction';
  /** Count of inner instructions */
  accountsCount?: Maybe<Scalars['Int']>;
  any?: Maybe<Scalars['String']>;
  /** Block where  transaction is included */
  block?: Maybe<SolanaBlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Error */
  error?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']>;
  /** Count of inner instructions */
  innerInstructionsCount?: Maybe<Scalars['Int']>;
  /** Count of instructions */
  instructionsCount?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Recent blockhash prevents duplication and to give transactions lifetimes */
  recentBlockHash?: Maybe<Scalars['String']>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']>;
  /** Accounts` public keys */
  signer?: Maybe<Scalars['String']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['Int']>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_AccountsCountArgs = {
  accountsCount?: InputMaybe<IntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_AnyArgs = {
  of: SolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_BlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_CountArgs = {
  uniq?: InputMaybe<SolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_CountBigIntArgs = {
  uniq?: InputMaybe<SolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_ErrorArgs = {
  error?: InputMaybe<StringSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_FeePayerArgs = {
  feePayer?: InputMaybe<HashSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_InnerInstructionsCountArgs = {
  innerInstructionsCount?: InputMaybe<IntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_InstructionsCountArgs = {
  instructionsCount?: InputMaybe<IntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_MaximumArgs = {
  get?: InputMaybe<SolanaTransactionMeasureable>;
  of: SolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_MinimumArgs = {
  get?: InputMaybe<SolanaTransactionMeasureable>;
  of: SolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_RecentBlockHashArgs = {
  recentBlockHash?: InputMaybe<HashSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_SignatureArgs = {
  signature?: InputMaybe<HashSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_SignerArgs = {
  signer?: InputMaybe<HashSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_SuccessArgs = {
  success?: InputMaybe<BooleanSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_TransactionFeeArgs = {
  accountsCount?: InputMaybe<IntegerSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  innerInstructionsCount?: InputMaybe<IntegerSelector>;
  instructionsCount?: InputMaybe<IntegerSelector>;
  parentSlot?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionFee?: InputMaybe<AmountSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type SolanaTransaction_TransactionIndexArgs = {
  transactionIndex?: InputMaybe<IntegerSelector>;
};

export type SolanaTransactionFilter = {
  accountsCount?: InputMaybe<IntegerSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<IntegerSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  innerInstructionsCount?: InputMaybe<IntegerSelector>;
  instructionsCount?: InputMaybe<IntegerSelector>;
  parentSlot?: InputMaybe<BlockSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  transactionFee?: InputMaybe<AmountSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
};

/** Solana Transaction Info */
export type SolanaTransactionInfo = {
  __typename?: 'SolanaTransactionInfo';
  feePayer?: Maybe<Scalars['String']>;
  signature?: Maybe<Scalars['String']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionIndex?: Maybe<Scalars['BigInt']>;
};

/** Solana Transaction Info Extended */
export type SolanaTransactionInfoExt = {
  __typename?: 'SolanaTransactionInfoExt';
  accountsCount?: Maybe<Scalars['Int']>;
  error?: Maybe<Scalars['String']>;
  fee?: Maybe<Scalars['Float']>;
  feePayer?: Maybe<Scalars['String']>;
  innerInstructionsCount?: Maybe<Scalars['Int']>;
  instructionsCount?: Maybe<Scalars['Int']>;
  recentBlockHash?: Maybe<Scalars['String']>;
  signature?: Maybe<Scalars['String']>;
  signer?: Maybe<Scalars['String']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionIndex?: Maybe<Scalars['BigInt']>;
};

export type SolanaTransactionMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time'
  /** Transaction Fee */
  | 'transaction_fee';

export type SolanaTransactionUniq =
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Accounts` public key */
  | 'signer'
  /** Unique time */
  | 'times';

/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer = {
  __typename?: 'SolanaTransfer';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<SolanaBlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<SolanaCryptoCurrency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Instruction where transfer is included */
  instruction?: Maybe<InstructionWithExternals>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Receiver>;
  /** Sender */
  sender?: Maybe<Sender>;
  /** Transaction where transfer is included */
  transaction?: Maybe<SolanaTransactionInfoExt>;
  /** Transfer Type */
  transferType?: Maybe<Scalars['String']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callPath?: InputMaybe<StringSelector>;
  currency?: InputMaybe<Array<SolanaCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<StringSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  receiverAddress?: InputMaybe<StringSelector>;
  receiverMintAddress?: InputMaybe<StringSelector>;
  receiverType?: InputMaybe<StringSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  senderAddress?: InputMaybe<StringSelector>;
  senderMintAddress?: InputMaybe<StringSelector>;
  senderType?: InputMaybe<StringSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  tokenAccount?: InputMaybe<Array<StringSelector>>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_AnyArgs = {
  of: SolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_BlockArgs = {
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  currency?: InputMaybe<Array<SolanaCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<StringSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  receiverAddress?: InputMaybe<StringSelector>;
  receiverMintAddress?: InputMaybe<StringSelector>;
  receiverType?: InputMaybe<StringSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  senderAddress?: InputMaybe<StringSelector>;
  senderMintAddress?: InputMaybe<StringSelector>;
  senderType?: InputMaybe<StringSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  tokenAccount?: InputMaybe<Array<StringSelector>>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
  uniq?: InputMaybe<SolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  currency?: InputMaybe<Array<SolanaCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<StringSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  receiverAddress?: InputMaybe<StringSelector>;
  receiverMintAddress?: InputMaybe<StringSelector>;
  receiverType?: InputMaybe<StringSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  senderAddress?: InputMaybe<StringSelector>;
  senderMintAddress?: InputMaybe<StringSelector>;
  senderType?: InputMaybe<StringSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  tokenAccount?: InputMaybe<Array<StringSelector>>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
  uniq?: InputMaybe<SolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_MaximumArgs = {
  get?: InputMaybe<SolanaTransferMeasureable>;
  of: SolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_MinimumArgs = {
  get?: InputMaybe<SolanaTransferMeasureable>;
  of: SolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_TransactionArgs = {
  signature?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfer_TransferTypeArgs = {
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
};

export type SolanaTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  blockHash?: InputMaybe<HashSelector>;
  callPath?: InputMaybe<StringSelector>;
  currency?: InputMaybe<Array<SolanaCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<StringSelector>;
  externalParsed?: InputMaybe<IntegerSelector>;
  externalParsedActionName?: InputMaybe<StringSelector>;
  externalParsedProgramName?: InputMaybe<StringSelector>;
  externalParsedType?: InputMaybe<StringSelector>;
  externalProgramId?: InputMaybe<StringSelector>;
  feePayer?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  parsed?: InputMaybe<IntegerSelector>;
  parsedActionName?: InputMaybe<StringSelector>;
  parsedProgramName?: InputMaybe<StringSelector>;
  parsedType?: InputMaybe<StringSelector>;
  previousBlockHash?: InputMaybe<HashSelector>;
  programId?: InputMaybe<StringSelector>;
  receiverAddress?: InputMaybe<StringSelector>;
  receiverMintAddress?: InputMaybe<StringSelector>;
  receiverType?: InputMaybe<StringSelector>;
  recentBlockHash?: InputMaybe<HashSelector>;
  senderAddress?: InputMaybe<StringSelector>;
  senderMintAddress?: InputMaybe<StringSelector>;
  senderType?: InputMaybe<StringSelector>;
  signature?: InputMaybe<HashSelector>;
  signer?: InputMaybe<HashSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  tokenAccount?: InputMaybe<Array<StringSelector>>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transferType?: InputMaybe<SolanaTransferTypeSelector>;
};

export type SolanaTransferMeasureable =
  /** Amount Transfer */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee_payer'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Transfer Type */
  | 'transfer_type';

export type SolanaTransferType =
  /** Burn */
  | 'burn'
  /** Close Account */
  | 'close_account'
  /** Create Account */
  | 'create_account'
  /** Mint */
  | 'mint'
  /** Nonce Withdraw */
  | 'nonce_withdraw'
  /** Rent Exemption */
  | 'rent_exemption'
  /** Self */
  | 'self'
  /** Stake */
  | 'stake'
  /** Stake Withdraw */
  | 'stake_withdraw'
  /** Trade Unknown */
  | 'trade_unknown'
  /** Transfer */
  | 'transfer'
  /** Vote */
  | 'vote';

/** Select by transfer type */
export type SolanaTransferTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<SolanaTransferType>>;
  /** Type is */
  is?: InputMaybe<SolanaTransferType>;
  /** Type not */
  not?: InputMaybe<SolanaTransferType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<SolanaTransferType>>;
};

export type SolanaTransferUniq =
  /** Currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Fee Payer */
  | 'fee_payer'
  /** Number of block in the blockchains */
  | 'height'
  /** Transfer To */
  | 'receiver_address'
  /** Transfer To Mint Address */
  | 'receiver_mint_address'
  /** Transfer From */
  | 'sender_address'
  /** Transfer From Mint Address */
  | 'sender_mint_address'
  /** Transaction Hash */
  | 'signature'
  /** Signer */
  | 'signer'
  /** Unique time */
  | 'times'
  /** Token Account Address */
  | 'token_account';

export type StakingTransactionsTypeEnum =
  | 'CollectRewards'
  | 'CreateValidator'
  | 'Delegate'
  | 'EditValidator'
  | 'Undelegate';

/** Indicates what type of operation the transaction is supposed to do. */
export type StakingTransactionsTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<StakingTransactionsTypeEnum>>;
  /** Type is */
  is?: InputMaybe<StakingTransactionsTypeEnum>;
  /** Type not */
  not?: InputMaybe<StakingTransactionsTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<StakingTransactionsTypeEnum>>;
};

/** Stellar Chain */
export type Stellar = {
  __typename?: 'Stellar';
  /** Basic information about address */
  address: Array<StellarAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<StellarAddressStats>>;
  /** Stellar Balance Effects */
  balanceEffects?: Maybe<Array<StellarBalanceEffect>>;
  /** Stellar Ledgers */
  blocks?: Maybe<Array<StellarBlock>>;
  /** Stellar Claimable Balance Effects */
  claimableBalanceEffects?: Maybe<Array<StellarClaimableBalanceEffect>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<StellarCoinpath>>;
  /** Stellar Effect Arguments */
  effectArguments?: Maybe<Array<StellarEffectArgument>>;
  /** Stellar Effects */
  effects?: Maybe<Array<StellarEffect>>;
  /** Stellar Liquidity Pool Effects */
  liquidityPoolEffects?: Maybe<Array<StellarLiquidityPoolEffect>>;
  /** Stellar Liquidity Pool Trade Effects */
  liquidityPoolTradeEffects?: Maybe<Array<StellarLiquidityPoolTradeEffect>>;
  /** Stellar Operations */
  operations?: Maybe<Array<StellarOperation>>;
  /** Stellar Payments */
  payments?: Maybe<Array<StellarPayment>>;
  /** Stellar Trade Effects */
  tradeEffects?: Maybe<Array<StellarTradeEffect>>;
  /** Stellar Transactions */
  transactions?: Maybe<Array<StellarTransaction>>;
  /** Stellar Transfers */
  transfers?: Maybe<Array<StellarTransfer>>;
};


/** Stellar Chain */
export type Stellar_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Stellar Chain */
export type Stellar_AddressStatsArgs = {
  address: AddressSelector;
  options?: InputMaybe<QueryOptions>;
};


/** Stellar Chain */
export type Stellar_BalanceEffectsArgs = {
  address?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<StellarBalanceEffectFilter>>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_BlocksArgs = {
  any?: InputMaybe<Array<StellarBlockFilter>>;
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  options?: InputMaybe<QueryOptions>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};


/** Stellar Chain */
export type Stellar_ClaimableBalanceEffectsArgs = {
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<StellarClaimableBalanceEffectFilter>>;
  balanceId?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  claimant?: InputMaybe<AddressSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  sponsor?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currencyFrom?: InputMaybe<CurrencySelector>;
  currencyTo?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Stellar Chain */
export type Stellar_EffectArgumentsArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<StellarEffectArgumentFilter>>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_EffectsArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<StellarEffectFilter>>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_LiquidityPoolEffectsArgs = {
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<StellarLiquidityPoolEffectFilter>>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_LiquidityPoolTradeEffectsArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<StellarLiquidityPoolTradeEffectFilter>>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_OperationsArgs = {
  any?: InputMaybe<Array<StellarOperationFilter>>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  sourceAccount?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_PaymentsArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<StellarPaymentFilter>>;
  block?: InputMaybe<BlockSelector>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_TradeEffectsArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<StellarTradeEffectFilter>>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Stellar Chain */
export type Stellar_TransactionsArgs = {
  any?: InputMaybe<Array<StellarTransactionFilter>>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
};


/** Stellar Chain */
export type Stellar_TransfersArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<StellarTransferFilter>>;
  block?: InputMaybe<BlockSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

/** Address detailed information for Stellar network */
export type StellarAddressInfo = {
  __typename?: 'StellarAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** XLM balance */
  balance?: Maybe<Scalars['Float']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<StellarTokenBalances>>;
};


/** Address detailed information for Stellar network */
export type StellarAddressInfo_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type StellarAddressStat = {
  __typename?: 'StellarAddressStat';
  /** Address */
  address?: Maybe<Address>;
  /** Balance */
  balance?: Maybe<Scalars['BigInt']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BigInt']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BigInt']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BigInt']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BigInt']>;
  /** First transfer at */
  firstTransferAt?: Maybe<DateTime>;
  /** First tx at */
  firstTxAt?: Maybe<DateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<DateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<DateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['BigInt']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BigInt']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BigInt']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BigInt']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['BigInt']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BigInt']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BigInt']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BigInt']>;
};

/** AddressStat */
export type StellarAddressStats = {
  __typename?: 'StellarAddressStats';
  /** Address With Statistics */
  address?: Maybe<StellarAddressStat>;
};

/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect = {
  __typename?: 'StellarBalanceEffect';
  /** Address */
  address?: Maybe<Address>;
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Issuer */
  issuer?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_AmountArgs = {
  address?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_AnyArgs = {
  of: StellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_MaximumArgs = {
  get?: InputMaybe<StellarBalanceEffectMeasurable>;
  of: StellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type StellarBalanceEffect_MinimumArgs = {
  get?: InputMaybe<StellarBalanceEffectMeasurable>;
  of: StellarBalanceEffectMeasurable;
};

export type StellarBalanceEffectFilter = {
  address?: InputMaybe<AddressSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarBalanceEffectMeasurable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarBalanceEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Block in Stellar blockchain */
export type StellarBlock = {
  __typename?: 'StellarBlock';
  any?: Maybe<Scalars['String']>;
  baseFee?: Maybe<Scalars['DecimalNumberAsDiv']>;
  baseReserve?: Maybe<Scalars['DecimalNumberAsDiv']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  feePool?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Ledger number (block|height) in blockchain */
  height: Scalars['Int'];
  /** Max transaction set size */
  maxTxSetSize: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Protocol version */
  protocolVersion: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalCoins?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Block in Stellar blockchain */
export type StellarBlock_AnyArgs = {
  of: StellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type StellarBlock_BaseFeeArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};


/** Block in Stellar blockchain */
export type StellarBlock_BaseReserveArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};


/** Block in Stellar blockchain */
export type StellarBlock_CountArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  uniq?: InputMaybe<StellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type StellarBlock_CountBigIntArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
  uniq?: InputMaybe<StellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type StellarBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Stellar blockchain */
export type StellarBlock_FeePoolArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};


/** Block in Stellar blockchain */
export type StellarBlock_MaximumArgs = {
  get?: InputMaybe<StellarBlockMeasurable>;
  of: StellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type StellarBlock_MinimumArgs = {
  get?: InputMaybe<StellarBlockMeasurable>;
  of: StellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type StellarBlock_TotalCoinsArgs = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};

export type StellarBlockFilter = {
  baseFee?: InputMaybe<FloatSelector>;
  baseReserve?: InputMaybe<FloatSelector>;
  date?: InputMaybe<DateSelector>;
  feePool?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  maxTxSetSize?: InputMaybe<IntegerSelector>;
  protocolVersion?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  totalCoins?: InputMaybe<FloatSelector>;
};

export type StellarBlockMeasurable =
  /** Base fee */
  | 'baseFee'
  /** Base reserve */
  | 'baseReserve'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee pool */
  | 'feePool'
  /** Block hash */
  | 'hash'
  /** Max tx set size */
  | 'maxTxSetSize'
  /** Protocol version */
  | 'protocolVersion'
  /** Time */
  | 'time'
  /** Total coins */
  | 'totalCoins';

export type StellarBlockUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq date count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq max tx set sizes count */
  | 'maxTxSetSizes'
  /** Uniq protocol versions */
  | 'protocolVersions';

/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect = {
  __typename?: 'StellarClaimableBalanceEffect';
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Balance */
  balanceId?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  /** Claimant */
  claimant?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect */
  effect?: Maybe<Scalars['String']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Issuer */
  issuer?: Maybe<Address>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  /** Sponsor */
  sponsor?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_AmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  balanceId?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  claimant?: InputMaybe<AddressSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sponsor?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_AnyArgs = {
  of: StellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_CountArgs = {
  amount?: InputMaybe<FloatSelector>;
  balanceId?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  claimant?: InputMaybe<AddressSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sponsor?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_CountBigIntArgs = {
  amount?: InputMaybe<FloatSelector>;
  balanceId?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  claimant?: InputMaybe<AddressSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sponsor?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_MaximumArgs = {
  get?: InputMaybe<StellarClaimableBalanceEffectMeasurable>;
  of: StellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type StellarClaimableBalanceEffect_MinimumArgs = {
  get?: InputMaybe<StellarClaimableBalanceEffectMeasurable>;
  of: StellarClaimableBalanceEffectMeasurable;
};

export type StellarClaimableBalanceEffectFilter = {
  amount?: InputMaybe<FloatSelector>;
  balanceId?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  claimant?: InputMaybe<AddressSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sponsor?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarClaimableBalanceEffectMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Claimant */
  | 'claimant'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sponsor */
  | 'sponsor'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarClaimableBalanceEffectUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq claimants count */
  | 'claimants'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operaion indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sponsors count */
  | 'sponsors'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Stellar Coinpath */
export type StellarCoinpath = {
  __typename?: 'StellarCoinpath';
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<Currency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<StellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<StellarCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<StellarTransactionCoinpathDimension>;
};


/** Stellar Coinpath */
export type StellarCoinpath_AmountFromArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type StellarCoinpath_AmountToArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type StellarCoinpath_AnyArgs = {
  of: StellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type StellarCoinpath_MaximumArgs = {
  get?: InputMaybe<StellarCoinpathMeasureable>;
  of: StellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type StellarCoinpath_MinimumArgs = {
  get?: InputMaybe<StellarCoinpathMeasureable>;
  of: StellarCoinpathMeasureable;
};

/** Address detailed information for Stellar network */
export type StellarCoinpathAddress = {
  __typename?: 'StellarCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** First Tx At */
  firstTransferAt?: Maybe<DateTime>;
  /** Last Tx At */
  lastTransferAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
};

export type StellarCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Effect in Stellar blockchain */
export type StellarEffect = {
  __typename?: 'StellarEffect';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Details */
  details?: Maybe<Scalars['String']>;
  /** Effect */
  effect?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Effect index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Effect in Stellar blockchain */
export type StellarEffect_AnyArgs = {
  of: StellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type StellarEffect_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type StellarEffect_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type StellarEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Effect in Stellar blockchain */
export type StellarEffect_MaximumArgs = {
  get?: InputMaybe<StellarEffectMeasurable>;
  of: StellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type StellarEffect_MinimumArgs = {
  get?: InputMaybe<StellarEffectMeasurable>;
  of: StellarEffectMeasurable;
};

/** Effect argument in Stellar blockchain */
export type StellarEffectArgument = {
  __typename?: 'StellarEffectArgument';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Argname */
  argname?: Maybe<Scalars['String']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect */
  effect?: Maybe<Scalars['String']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_AnyArgs = {
  of: StellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_ExpressionArgs = {
  get: Scalars['String'];
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_MaximumArgs = {
  get?: InputMaybe<StellarEffectArgumentMeasurable>;
  of: StellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type StellarEffectArgument_MinimumArgs = {
  get?: InputMaybe<StellarEffectArgumentMeasurable>;
  of: StellarEffectArgumentMeasurable;
};

export type StellarEffectArgumentFilter = {
  address?: InputMaybe<AddressSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarEffectArgumentMeasurable =
  /** Address */
  | 'address'
  /** Argname */
  | 'argname'
  /** Argvalue */
  | 'argvalue'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarEffectArgumentUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq argnames count */
  | 'argnames'
  /** Uniq argvalues count */
  | 'argvalues'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

export type StellarEffectFilter = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Details */
  | 'details'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq details count */
  | 'details'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect = {
  __typename?: 'StellarLiquidityPoolEffect';
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect */
  effect?: Maybe<Scalars['String']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Issuer */
  issuer?: Maybe<Address>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']>;
  /** Liquidity pool id bin */
  liquidityPoolId?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  shares?: Maybe<Scalars['DecimalNumber']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_AmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_AnyArgs = {
  of: StellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_CountArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_CountBigIntArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_MaximumArgs = {
  get?: InputMaybe<StellarLiquidityPoolEffectMeasurable>;
  of: StellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_MinimumArgs = {
  get?: InputMaybe<StellarLiquidityPoolEffectMeasurable>;
  of: StellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type StellarLiquidityPoolEffect_SharesArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarLiquidityPoolEffectFilter = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  effect?: InputMaybe<StringSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  issuer?: InputMaybe<AddressSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  shares?: InputMaybe<FloatSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarLiquidityPoolEffectMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Liquidity pool details */
  | 'liquidityPoolDetails'
  /** Liquidity pool id */
  | 'liquidityPoolId'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Shares */
  | 'shares'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarLiquidityPoolEffectUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq liquidity pool details count */
  | 'liquidityPoolDetails'
  /** Uniq liquidity pool ids count */
  | 'liquidityPoolIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect = {
  __typename?: 'StellarLiquidityPoolTradeEffect';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  buyAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Buy currency */
  buyCurrency?: Maybe<Currency>;
  /** Buy issuer */
  buyIssuer?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']>;
  /** Liquidity pool */
  liquidityPoolId?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  sellAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Sell currency */
  sellCurrency?: Maybe<Currency>;
  /** Sell issuer */
  sellIssuer?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_AnyArgs = {
  of: StellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_BuyAmountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_MaximumArgs = {
  get?: InputMaybe<StellarLiquidityPoolTradeEffectMeasurable>;
  of: StellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_MinimumArgs = {
  get?: InputMaybe<StellarLiquidityPoolTradeEffectMeasurable>;
  of: StellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type StellarLiquidityPoolTradeEffect_SellAmountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarLiquidityPoolTradeEffectFilter = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  liquidityPoolDetails?: InputMaybe<StringSelector>;
  liquidityPoolId?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarLiquidityPoolTradeEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Buy amount */
  | 'buyAmount'
  /** Buy currency name */
  | 'buyCurrencyName'
  /** Buy currency symbol */
  | 'buyCurrencySymbol'
  /** Buy issuer */
  | 'buyIssuer'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Liquidity pool details */
  | 'liquidityPoolDetails'
  /** Liquidity pool */
  | 'liquidityPoolId'
  /** Operation index */
  | 'opIndex'
  /** Opertation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sell amount */
  | 'sellAmount'
  /** Sell currency name */
  | 'sellCurrencyName'
  /** Sell currency symbol */
  | 'sellCurrencySymbol'
  /** Sell issuer */
  | 'sellIssuer'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarLiquidityPoolTradeEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq buy currency names count */
  | 'buyCurrencyNames'
  /** Uniq buy currency symbols count */
  | 'buyCurrencySymbols'
  /** Uniq buy issuers count */
  | 'buyIssuers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq liquidity pool details count */
  | 'liquidityPoolDetails'
  /** Uniq liquidity pool ids count */
  | 'liquidityPoolIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sell currency names count */
  | 'sellCurrencyNames'
  /** Uniq sell currency symbols count */
  | 'sellCurrencySymbols'
  /** Uniq sell issuers count */
  | 'sellIssuers'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

export type StellarNetwork =
  /** The Stellar Ledger */
  | 'stellar';

/** Operation in Stellar blockchain */
export type StellarOperation = {
  __typename?: 'StellarOperation';
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Details */
  details?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Operation index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Operation source account */
  sourceAccount?: Maybe<Address>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Operation in Stellar blockchain */
export type StellarOperation_AnyArgs = {
  of: StellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type StellarOperation_CountArgs = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  sourceAccount?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type StellarOperation_CountBigIntArgs = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  sourceAccount?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type StellarOperation_ExpressionArgs = {
  get: Scalars['String'];
};


/** Operation in Stellar blockchain */
export type StellarOperation_MaximumArgs = {
  get?: InputMaybe<StellarOperationMeasurable>;
  of: StellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type StellarOperation_MinimumArgs = {
  get?: InputMaybe<StellarOperationMeasurable>;
  of: StellarOperationMeasurable;
};

export type StellarOperationFilter = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  details?: InputMaybe<StringSelector>;
  index?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  sourceAccount?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarOperationMeasurable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Details */
  | 'details'
  /** Operation index */
  | 'index'
  /** Operation */
  | 'operation'
  /** Operation source account */
  | 'sourceAccount'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarOperationUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq details count */
  | 'details'
  /** Uniq operations count */
  | 'operations'
  /** Uniq op source accounts count */
  | 'sourceAccounts'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Payment in Stellar blockchain */
export type StellarPayment = {
  __typename?: 'StellarPayment';
  amountFrom?: Maybe<Scalars['DecimalNumberAsDiv']>;
  amountTo?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** The sequence number of the ledger */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  creditedToValue?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Sender's currency */
  currencyFrom?: Maybe<Currency>;
  /** Receiver's currency */
  currencyTo?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  debitedFromValue?: Maybe<Scalars['DecimalNumberAsDiv']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Source issuer */
  issuerFrom?: Maybe<Address>;
  /** Issuer */
  issuerTo?: Maybe<Address>;
  maxValueFrom?: Maybe<Scalars['DecimalNumberAsDiv']>;
  maximum?: Maybe<Scalars['String']>;
  minValueTo?: Maybe<Scalars['DecimalNumberAsDiv']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Path */
  path?: Maybe<Scalars['String']>;
  /** Payment receiver */
  receiver?: Maybe<Address>;
  /** Payment sender */
  sender?: Maybe<Address>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_AmountFromArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_AmountToArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_AnyArgs = {
  of: StellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type StellarPayment_CountArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_CountBigIntArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_CreditedToValueArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_DebitedFromValueArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_ExpressionArgs = {
  get: Scalars['String'];
};


/** Payment in Stellar blockchain */
export type StellarPayment_MaxValueFromArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_MaximumArgs = {
  get?: InputMaybe<StellarPaymentMeasurable>;
  of: StellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type StellarPayment_MinValueToArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Payment in Stellar blockchain */
export type StellarPayment_MinimumArgs = {
  get?: InputMaybe<StellarPaymentMeasurable>;
  of: StellarPaymentMeasurable;
};

export type StellarPaymentFilter = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  creditedToValue?: InputMaybe<FloatSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  debitedFromValue?: InputMaybe<FloatSelector>;
  issuerFrom?: InputMaybe<AddressSelector>;
  issuerTo?: InputMaybe<AddressSelector>;
  maxValueFrom?: InputMaybe<FloatSelector>;
  minValueTo?: InputMaybe<FloatSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  path?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarPaymentMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Block */
  | 'block'
  /** Credited to value */
  | 'creditedToValue'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Debited from value */
  | 'debitedFromValue'
  /** Issuer from */
  | 'issuerFrom'
  /** Issuer to */
  | 'issuerTo'
  /** Max value from */
  | 'maxValueFrom'
  /** Min value to */
  | 'minValueTo'
  /** Op index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Path */
  | 'path'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarPaymentUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies from name count */
  | 'currenciesFromName'
  /** Uniq currencies from symbol count */
  | 'currenciesFromSymbol'
  /** Uniq currencies to name count */
  | 'currenciesToName'
  /** Uniq currencies to symbol count */
  | 'currenciesToSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq issuers from count */
  | 'issuersFrom'
  /** Uniq issuers to count */
  | 'issuersTo'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq paths count */
  | 'paths'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Token Balance */
export type StellarTokenBalances = {
  __typename?: 'StellarTokenBalances';
  /** Asset code */
  assetCode?: Maybe<Scalars['String']>;
  /** Asset issuer */
  assetIssuer?: Maybe<Scalars['String']>;
  /** Asset type */
  assetType?: Maybe<Scalars['String']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']>;
};

/** Trade effect in Stellar blockchain */
export type StellarTradeEffect = {
  __typename?: 'StellarTradeEffect';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<Scalars['BigInt']>;
  buyAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Buy currency */
  buyCurrency?: Maybe<Currency>;
  /** Buy issuer */
  buyIssuer?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Offer */
  offerId?: Maybe<Scalars['BigInt']>;
  /** Operation */
  operation?: Maybe<OperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']>;
  sellAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Sell currency */
  sellCurrency?: Maybe<Currency>;
  /** Sell issuer */
  sellIssuer?: Maybe<Address>;
  /** Seller */
  seller?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_AnyArgs = {
  of: StellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_BuyAmountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_ExpressionArgs = {
  get: Scalars['String'];
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_MaximumArgs = {
  get?: InputMaybe<StellarTradeEffectMeasurable>;
  of: StellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_MinimumArgs = {
  get?: InputMaybe<StellarTradeEffectMeasurable>;
  of: StellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type StellarTradeEffect_SellAmountArgs = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarTradeEffectFilter = {
  address?: InputMaybe<AddressSelector>;
  block?: InputMaybe<BlockSelector>;
  buyAmount?: InputMaybe<FloatSelector>;
  buyCurrencyName?: InputMaybe<CurrencySelector>;
  buyIssuer?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  effectIndex?: InputMaybe<IntegerSelector>;
  offerId?: InputMaybe<IntegerSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  opSourceAccount?: InputMaybe<AddressSelector>;
  operation?: InputMaybe<StringSelector>;
  order?: InputMaybe<IntegerSelector>;
  sellAmount?: InputMaybe<FloatSelector>;
  sellCurrencyName?: InputMaybe<CurrencySelector>;
  sellIssuer?: InputMaybe<AddressSelector>;
  seller?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarTradeEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Buy amount */
  | 'buyAmount'
  /** Buy currency name */
  | 'buyCurrencyName'
  /** Buy currency symbol */
  | 'buyCurrencySymbol'
  /** Buy issuer */
  | 'buyIssuer'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Offer */
  | 'offerId'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sell amount */
  | 'sellAmount'
  /** Sell currency name */
  | 'sellCurrencyName'
  /** Sell currency symbol */
  | 'sellCurrencySymbol'
  /** Sell issuer */
  | 'sellIssuer'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarTradeEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq buy currency names count */
  | 'buyCurrencyNames'
  /** Uniq buy currency symbols count */
  | 'buyCurrencySymbols'
  /** Uniq buy issuers count */
  | 'buyIssuers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq offer ids count */
  | 'offerIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sell currency names count */
  | 'sellCurrencyNames'
  /** Uniq sell currency symbols count */
  | 'sellCurrencySymbols'
  /** Uniq sell issuers count */
  | 'sellIssuers'
  /** Uniq sellers count */
  | 'sellers'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Transaction in Stellar blockchain */
export type StellarTransaction = {
  __typename?: 'StellarTransaction';
  any?: Maybe<Scalars['String']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Fee payer */
  feeAccount?: Maybe<Address>;
  /** Hash of this transaction */
  hash?: Maybe<Scalars['String']>;
  /** Index of this transaction */
  index?: Maybe<Scalars['Int']>;
  maxFee?: Maybe<Scalars['DecimalNumberAsDiv']>;
  maximum?: Maybe<Scalars['String']>;
  /** Memo type */
  memoType?: Maybe<Scalars['String']>;
  /** Memos */
  memos?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Amout of operations */
  operationCount?: Maybe<Scalars['Int']>;
  /** Sender of this transaction */
  sender?: Maybe<Address>;
  /** Sequence */
  sequence?: Maybe<Scalars['BigInt']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Time bounds */
  timeBounds?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  timestamp?: Maybe<DateTime>;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_AnyArgs = {
  of: StellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_CountArgs = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<StellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_CountBigIntArgs = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<StellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_FeeArgs = {
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_MaxFeeArgs = {
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_MaximumArgs = {
  get?: InputMaybe<StellarTransactionMeasurable>;
  of: StellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type StellarTransaction_MinimumArgs = {
  get?: InputMaybe<StellarTransactionMeasurable>;
  of: StellarTransactionMeasurable;
};

/** Blockchain transaction Info */
export type StellarTransactionCoinpathDimension = {
  __typename?: 'StellarTransactionCoinpathDimension';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction Index */
  index: Scalars['Int'];
  /** Time */
  time?: Maybe<DateTime>;
  /** Transaction Value From */
  valueFrom?: Maybe<Scalars['Float']>;
  /** Transaction Value To */
  valueTo?: Maybe<Scalars['Float']>;
};

/** Blockchain transaction */
export type StellarTransactionDimension = {
  __typename?: 'StellarTransactionDimension';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block */
  index: Scalars['Int'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']>;
};

export type StellarTransactionFilter = {
  block?: InputMaybe<BlockSelector>;
  date?: InputMaybe<DateSelector>;
  fee?: InputMaybe<FloatSelector>;
  hash?: InputMaybe<HashSelector>;
  index?: InputMaybe<IntegerSelector>;
  maxFee?: InputMaybe<FloatSelector>;
  memoType?: InputMaybe<StringSelector>;
  memos?: InputMaybe<StringSelector>;
  sender?: InputMaybe<AddressSelector>;
  sequence?: InputMaybe<IntegerSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  timeBounds?: InputMaybe<StringSelector>;
};

export type StellarTransactionMeasurable =
  /** Ledger */
  | 'block'
  /** Date */
  | 'date'
  /** fee */
  | 'fee'
  /** Transaction Hash */
  | 'hash'
  /** Transaction Index */
  | 'index'
  /** Max fee */
  | 'maxFee'
  /** Memo type */
  | 'memoType'
  /** Memos */
  | 'memos'
  /** Transaction sender */
  | 'sender'
  /** Sequence */
  | 'sequence'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Time bounds */
  | 'timeBounds';

export type StellarTransactionUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq date count */
  | 'dates'
  /** Uniq transaction hashes count */
  | 'hashes'
  /** Uniq memo types count */
  | 'memoTypes'
  /** Uniq transaction senders */
  | 'senders'
  /** Uniq sequences count */
  | 'sequences';

/** Transfer in Stellar blockchain */
export type StellarTransfer = {
  __typename?: 'StellarTransfer';
  amountFrom?: Maybe<Scalars['Float']>;
  amountTo?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency from of transfer */
  currencyFrom?: Maybe<Currency>;
  /** Currency to of transfer */
  currencyTo?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<OperationIndexed>;
  /** The account this transaction is been sent to */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** The time this transaction was created */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<StellarTransactionDimension>;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_AmountFromArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_AmountToArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_AnyArgs = {
  of: StellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_CountArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_CountBigIntArgs = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<StellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_MaximumArgs = {
  get?: InputMaybe<StellarTransferMeasurable>;
  of: StellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type StellarTransfer_MinimumArgs = {
  get?: InputMaybe<StellarTransferMeasurable>;
  of: StellarTransferMeasurable;
};

export type StellarTransferFilter = {
  amountFrom?: InputMaybe<FloatSelector>;
  amountTo?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BlockSelector>;
  currencyFromName?: InputMaybe<CurrencySelector>;
  currencyToName?: InputMaybe<CurrencySelector>;
  date?: InputMaybe<DateSelector>;
  direction?: InputMaybe<StringSelector>;
  opIndex?: InputMaybe<IntegerSelector>;
  operation?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionIndex?: InputMaybe<IntegerSelector>;
  transactionSender?: InputMaybe<AddressSelector>;
};

export type StellarTransferMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Ledger */
  | 'block'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Direction */
  | 'direction'
  /** Operation index */
  | 'opIndex'
  /** Operation */
  | 'operation'
  /** Transfer Receiver */
  | 'receiver'
  /** Transfer Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction Hash */
  | 'transactionHash'
  /** Transaction Index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type StellarTransferUniq =
  /** Uniq currency from names */
  | 'currenciesFromName'
  /** Uniq currency from symbols */
  | 'currenciesFromSymbol'
  /** Uniq currency to names */
  | 'currenciesToName'
  /** Uniq currency to symbols */
  | 'currenciesToSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq directions */
  | 'directions'
  /** Uniq operation indices */
  | 'opIndices'
  /** Uniq operations */
  | 'operations'
  /** Uniq transfer receivers */
  | 'receivers'
  /** Uniq transfer senders */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes */
  | 'transactionHashes'
  /** Uniq transaction indices */
  | 'transactionIndices'
  /** Uniq transaction senders */
  | 'transactionSenders';

/** Select by ID */
export type StringIdSelector = {
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** ID is */
  is?: InputMaybe<Scalars['String']>;
  /** ID not */
  not?: InputMaybe<Scalars['String']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Select by string */
export type StringSelector = {
  /** String in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** String is */
  is?: InputMaybe<Scalars['String']>;
  /** String not */
  not?: InputMaybe<Scalars['String']>;
  /** String not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Search result subject */
export type Subject = Address | Currency | MessageHash | SmartContract | TransactionHash;

/** Blockchain Unified GraphQL Subscription API */
export type Subscription = {
  __typename?: 'Subscription';
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<Ethereum>;
};


/** Blockchain Unified GraphQL Subscription API */
export type Subscription_EthereumArgs = {
  network?: InputMaybe<EthereumNetwork>;
};

/** Tezos Chain */
export type Tezos = {
  __typename?: 'Tezos';
  /** Basic information about address */
  address: Array<TezosAddressInfoWithBalance>;
  /** Tezos Arguments */
  arguments?: Maybe<Array<TezosArgument>>;
  /** Tezos Balance Updates */
  balanceUpdates?: Maybe<Array<TezosBalanceUpdate>>;
  /** Tezos Blocks */
  blocks?: Maybe<Array<TezosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<TezosCoinpath>>;
  /** Tezos Operations */
  operations?: Maybe<Array<TezosOperation>>;
  /** Tezos Transactions */
  transactions?: Maybe<Array<TezosTransaction>>;
  /** Tezos Transfers */
  transfers?: Maybe<Array<TezosTransfer>>;
};


/** Tezos Chain */
export type Tezos_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Tezos Chain */
export type Tezos_ArgumentsArgs = {
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<TezosArgumentFilter>>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  status?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Tezos Chain */
export type Tezos_BalanceUpdatesArgs = {
  address?: InputMaybe<AddressSelector>;
  any?: InputMaybe<Array<TezosBalanceUpdateFilter>>;
  attribute?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  category?: InputMaybe<StringSelector>;
  change?: InputMaybe<FloatSelector>;
  cycle?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  freezer?: InputMaybe<BooleanSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Tezos Chain */
export type Tezos_BlocksArgs = {
  any?: InputMaybe<Array<TezosBlockFilter>>;
  baker?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Tezos Chain */
export type Tezos_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Tezos Chain */
export type Tezos_OperationsArgs = {
  any?: InputMaybe<Array<TezosOperationFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  contents?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Tezos Chain */
export type Tezos_TransactionsArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<TezosTransactionFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Tezos Chain */
export type Tezos_TransfersArgs = {
  amount?: InputMaybe<FloatSelector>;
  any?: InputMaybe<Array<TezosTransferFilter>>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  direction?: InputMaybe<StringSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  options?: InputMaybe<QueryOptions>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};

/** Address detailed information for Tezos network */
export type TezosAddressInfoWithBalance = {
  __typename?: 'TezosAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Wallet balance */
  balance?: Maybe<Array<TezosBalance>>;
};

/** Argument in Tezos blockchain */
export type TezosArgument = {
  __typename?: 'TezosArgument';
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Argname */
  argname?: Maybe<Scalars['String']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<TezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Status */
  status?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<TezosTransactionWithSourceDimension>;
};


/** Argument in Tezos blockchain */
export type TezosArgument_AmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  status?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Argument in Tezos blockchain */
export type TezosArgument_AnyArgs = {
  of: TezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type TezosArgument_CountArgs = {
  amount?: InputMaybe<FloatSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  status?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type TezosArgument_CountBigIntArgs = {
  amount?: InputMaybe<FloatSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  status?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type TezosArgument_ExpressionArgs = {
  get: Scalars['String'];
};


/** Argument in Tezos blockchain */
export type TezosArgument_MaximumArgs = {
  get?: InputMaybe<TezosArgumentMeasurable>;
  of: TezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type TezosArgument_MinimumArgs = {
  get?: InputMaybe<TezosArgumentMeasurable>;
  of: TezosArgumentMeasurable;
};

export type TezosArgumentFilter = {
  amount?: InputMaybe<FloatSelector>;
  argname?: InputMaybe<StringSelector>;
  argvalue?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  status?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};

export type TezosArgumentMeasurable =
  /** Amount */
  | 'amount'
  /** Argname */
  | 'argname'
  /** Argvalue */
  | 'argvalue'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Date */
  | 'date'
  /** Internal */
  | 'internal'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Status */
  | 'status'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type TezosArgumentUniq =
  /** Uniq argnames count */
  | 'argnames'
  /** Uniq argvalues count */
  | 'argvalues'
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq statuses count */
  | 'statuses'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** XTZ Balance */
export type TezosBalance = {
  __typename?: 'TezosBalance';
  /** Spendable Balance */
  available?: Maybe<Scalars['Float']>;
  /** Delegated Balance */
  delegated?: Maybe<Scalars['Float']>;
  /** Frozen Deposit */
  frozenDeposit?: Maybe<Scalars['Float']>;
  /** Staking Balance */
  staking?: Maybe<Scalars['Float']>;
  /** Total Balance */
  total?: Maybe<Scalars['Float']>;
};


/** XTZ Balance */
export type TezosBalance_AvailableArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** XTZ Balance */
export type TezosBalance_DelegatedArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** XTZ Balance */
export type TezosBalance_FrozenDepositArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** XTZ Balance */
export type TezosBalance_StakingArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** XTZ Balance */
export type TezosBalance_TotalArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate = {
  __typename?: 'TezosBalanceUpdate';
  /** Address */
  address?: Maybe<Address>;
  any?: Maybe<Scalars['String']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<TezosBlockWithHashDimension>;
  /** Category */
  category?: Maybe<Scalars['String']>;
  change?: Maybe<Scalars['DecimalNumberAsDiv']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Cycle */
  cycle?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Freezer */
  freezer?: Maybe<Scalars['Boolean']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']>;
  /** Kind */
  kind?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Source */
  source?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<TezosTransactionWithSourceDimension>;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_AnyArgs = {
  of: TezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_ChangeArgs = {
  address?: InputMaybe<AddressSelector>;
  attribute?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  category?: InputMaybe<StringSelector>;
  change?: InputMaybe<FloatSelector>;
  cycle?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  freezer?: InputMaybe<BooleanSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_CountArgs = {
  address?: InputMaybe<AddressSelector>;
  attribute?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  category?: InputMaybe<StringSelector>;
  change?: InputMaybe<FloatSelector>;
  cycle?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  freezer?: InputMaybe<BooleanSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_CountBigIntArgs = {
  address?: InputMaybe<AddressSelector>;
  attribute?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  category?: InputMaybe<StringSelector>;
  change?: InputMaybe<FloatSelector>;
  cycle?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  freezer?: InputMaybe<BooleanSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_ExpressionArgs = {
  get: Scalars['String'];
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_MaximumArgs = {
  get?: InputMaybe<TezosBalanceUpdateMeasurable>;
  of: TezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type TezosBalanceUpdate_MinimumArgs = {
  get?: InputMaybe<TezosBalanceUpdateMeasurable>;
  of: TezosBalanceUpdateMeasurable;
};

export type TezosBalanceUpdateFilter = {
  address?: InputMaybe<AddressSelector>;
  attribute?: InputMaybe<StringSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  category?: InputMaybe<StringSelector>;
  change?: InputMaybe<FloatSelector>;
  cycle?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  freezer?: InputMaybe<BooleanSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};

export type TezosBalanceUpdateMeasurable =
  /** Address */
  | 'address'
  /** Attribute */
  | 'attribute'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Category */
  | 'category'
  /** Change */
  | 'change'
  /** Cycle */
  | 'cycle'
  /** Date */
  | 'date'
  /** Freezer */
  | 'freezer'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Source */
  | 'source'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type TezosBalanceUpdateUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq attributes count */
  | 'attributes'
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq categories count */
  | 'categories'
  /** Uniq cycles count */
  | 'cycles'
  /** Uniq dates count */
  | 'dates'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq sources count */
  | 'sources'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Block in Tezos blockchain */
export type TezosBlock = {
  __typename?: 'TezosBlock';
  any?: Maybe<Scalars['String']>;
  /** Baker */
  baker?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Hash */
  hash?: Maybe<Scalars['String']>;
  /** Header */
  header?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
};


/** Block in Tezos blockchain */
export type TezosBlock_AnyArgs = {
  of: TezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type TezosBlock_CountArgs = {
  baker?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type TezosBlock_CountBigIntArgs = {
  baker?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type TezosBlock_ExpressionArgs = {
  get: Scalars['String'];
};


/** Block in Tezos blockchain */
export type TezosBlock_MaximumArgs = {
  get?: InputMaybe<TezosBlockMeasurable>;
  of: TezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type TezosBlock_MinimumArgs = {
  get?: InputMaybe<TezosBlockMeasurable>;
  of: TezosBlockMeasurable;
};

export type TezosBlockFilter = {
  baker?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  hash?: InputMaybe<HashSelector>;
  height?: InputMaybe<BlockSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type TezosBlockMeasurable =
  /** Baker */
  | 'baker'
  /** Date */
  | 'date'
  /** Hash */
  | 'hash'
  /** Header */
  | 'header'
  /** Height */
  | 'height'
  /** Metadata */
  | 'metadata'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Time */
  | 'time';

export type TezosBlockUniq =
  /** Uniq bakers count */
  | 'bakers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq headers count */
  | 'headers'
  /** Uniq heights count */
  | 'heights'
  /** Uniq metadatas count */
  | 'metadatas'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq times count */
  | 'times';

/** Tezos block with hash */
export type TezosBlockWithHashDimension = {
  __typename?: 'TezosBlockWithHashDimension';
  /** Block hash */
  hash: Scalars['String'];
  /** Block */
  height: Scalars['BigInt'];
};

/** Coinpath */
export type TezosCoinpath = {
  __typename?: 'TezosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type TezosCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type TezosCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TezosCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TezosCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export type TezosNetwork =
  /** Tezos */
  | 'tezos';

/** Operation in Tezos blockchain */
export type TezosOperation = {
  __typename?: 'TezosOperation';
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<TezosBlockWithHashDimension>;
  /** Contents */
  contents?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']>;
  /** Kind */
  kind?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Source */
  source?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<TezosTransactionWithSourceDimension>;
};


/** Operation in Tezos blockchain */
export type TezosOperation_AnyArgs = {
  of: TezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type TezosOperation_CountArgs = {
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  contents?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type TezosOperation_CountBigIntArgs = {
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  contents?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type TezosOperation_ExpressionArgs = {
  get: Scalars['String'];
};


/** Operation in Tezos blockchain */
export type TezosOperation_MaximumArgs = {
  get?: InputMaybe<TezosOperationMeasurable>;
  of: TezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type TezosOperation_MinimumArgs = {
  get?: InputMaybe<TezosOperationMeasurable>;
  of: TezosOperationMeasurable;
};

export type TezosOperationFilter = {
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  contents?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  source?: InputMaybe<StringSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};

export type TezosOperationMeasurable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Contents */
  | 'contents'
  /** Date */
  | 'date'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Source */
  | 'source'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type TezosOperationUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq contents count */
  | 'contents'
  /** Uniq dates count */
  | 'dates'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq sources count */
  | 'sources'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Transaction in Tezos blockchain */
export type TezosTransaction = {
  __typename?: 'TezosTransaction';
  /** Allocated destination contract */
  allocatedDestinationContract?: Maybe<Scalars['Boolean']>;
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<TezosBlockWithHashDimension>;
  burnAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  consumedGas?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['DecimalNumberAsDiv']>;
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']>;
  paidStorageAmount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  paidStorageSizeDiff?: Maybe<Scalars['BigInt']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Transaction source */
  source?: Maybe<Address>;
  /** Status */
  status?: Maybe<Scalars['String']>;
  storageSize?: Maybe<Scalars['BigInt']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_AmountArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_AnyArgs = {
  of: TezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_BurnAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_ConsumedGasArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_CountArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_CountBigIntArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_FeeArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_GasLimitArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_MaximumArgs = {
  get?: InputMaybe<TezosTransactionMeasurable>;
  of: TezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_MinimumArgs = {
  get?: InputMaybe<TezosTransactionMeasurable>;
  of: TezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_PaidStorageAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_PaidStorageSizeDiffArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type TezosTransaction_StorageSizeArgs = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type TezosTransactionFilter = {
  allocatedDestinationContract?: InputMaybe<BooleanSelector>;
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  burnAmount?: InputMaybe<FloatSelector>;
  consumedGas?: InputMaybe<BigIntIdSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  fee?: InputMaybe<FloatSelector>;
  gasLimit?: InputMaybe<BigIntIdSelector>;
  hash?: InputMaybe<HashSelector>;
  internal?: InputMaybe<BooleanSelector>;
  opPath?: InputMaybe<StringSelector>;
  paidStorageAmount?: InputMaybe<FloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BigIntIdSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  source?: InputMaybe<StringSelector>;
  status?: InputMaybe<StringSelector>;
  storageSize?: InputMaybe<BigIntIdSelector>;
  success?: InputMaybe<BooleanSelector>;
  time?: InputMaybe<DateTimeSelector>;
};

export type TezosTransactionMeasurable =
  /** Allocated destination contract */
  | 'allocatedDestinationContract'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Burn amount */
  | 'burnAmount'
  /** Consumed gas */
  | 'consumedGas'
  /** Date */
  | 'date'
  /** Destination contract */
  | 'destinationContract'
  /** Fee */
  | 'fee'
  /** Gas limit */
  | 'gasLimit'
  /** Transaction hash */
  | 'hash'
  /** Internal */
  | 'internal'
  /** Op path */
  | 'opPath'
  /** Paid storage amount */
  | 'paidStorageAmount'
  /** Paid storage size diff */
  | 'paid_storage_size_diff'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Transaction source */
  | 'source'
  /** Status */
  | 'status'
  /** Storage size */
  | 'storageSize'
  /** Success */
  | 'success'
  /** Time */
  | 'time';

export type TezosTransactionUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq transaction hashes count */
  | 'hashes'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq transaction sources count */
  | 'sources'
  /** Uniq statuses count */
  | 'statuses'
  /** Uniq times count */
  | 'times';

/** Tezos transaction with source */
export type TezosTransactionWithSourceDimension = {
  __typename?: 'TezosTransactionWithSourceDimension';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction source */
  source?: Maybe<Scalars['String']>;
};

/** Transfer in Tezos blockchain */
export type TezosTransfer = {
  __typename?: 'TezosTransfer';
  amount?: Maybe<Scalars['DecimalNumberAsDiv']>;
  any?: Maybe<Scalars['String']>;
  /** Block */
  block?: Maybe<TezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']>;
  /** Kind */
  kind?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']>;
  /** Proto */
  proto?: Maybe<Scalars['BigInt']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']>;
  /** Receiver */
  receiver?: Maybe<Address>;
  /** Sender */
  sender?: Maybe<Address>;
  /** Timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction */
  transaction?: Maybe<TezosTransactionWithSourceDimension>;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_AmountArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  direction?: InputMaybe<StringSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_AnyArgs = {
  of: TezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_CountArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  direction?: InputMaybe<StringSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_CountBigIntArgs = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  direction?: InputMaybe<StringSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
  uniq?: InputMaybe<TezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_MaximumArgs = {
  get?: InputMaybe<TezosTransferMeasurable>;
  of: TezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type TezosTransfer_MinimumArgs = {
  get?: InputMaybe<TezosTransferMeasurable>;
  of: TezosTransferMeasurable;
};

export type TezosTransferFilter = {
  amount?: InputMaybe<FloatSelector>;
  block?: InputMaybe<BigIntIdSelector>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  destinationContract?: InputMaybe<BooleanSelector>;
  direction?: InputMaybe<StringSelector>;
  internal?: InputMaybe<BooleanSelector>;
  kind?: InputMaybe<StringSelector>;
  opPath?: InputMaybe<StringSelector>;
  proto?: InputMaybe<BigIntIdSelector>;
  protocol?: InputMaybe<StringSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
  transactionHash?: InputMaybe<HashSelector>;
  transactionSource?: InputMaybe<StringSelector>;
};

export type TezosTransferMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination contract */
  | 'destinationContract'
  /** Direction */
  | 'direction'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type TezosTransferUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination contracts count */
  | 'destinationContracts'
  /** Uniq directions count */
  | 'directions'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Time Interval */
export type TimeInterval = {
  __typename?: 'TimeInterval';
  day: Scalars['String'];
  hour: Scalars['String'];
  minute: Scalars['String'];
  month: Scalars['String'];
  second: Scalars['String'];
  year: Scalars['String'];
};


/** Time Interval */
export type TimeInterval_DayArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};


/** Time Interval */
export type TimeInterval_HourArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};


/** Time Interval */
export type TimeInterval_MinuteArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};


/** Time Interval */
export type TimeInterval_MonthArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};


/** Time Interval */
export type TimeInterval_SecondArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};


/** Time Interval */
export type TimeInterval_YearArgs = {
  count?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<Scalars['String']>;
};

/** Timestamp */
export type Timestamp = {
  __typename?: 'Timestamp';
  /** Nanoseconds */
  nanoseconds: Scalars['BigInt'];
  time: Scalars['ISO8601Date'];
};

/** Select trade by ID */
export type TradeIdSelector = {
  /** Trade ID in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Trade ID is */
  is?: InputMaybe<Scalars['String']>;
  /** Trade ID not */
  not?: InputMaybe<Scalars['String']>;
  /** Trade ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type TradeSide =
  /** Buy side */
  | 'BUY'
  /** Sell side */
  | 'SELL';

/** Information about transaction */
export type TransactionElrond = {
  __typename?: 'TransactionElrond';
  /** Shard number of sender */
  data?: Maybe<Scalars['String']>;
  /** Shard number of sender */
  dataOperation?: Maybe<Scalars['String']>;
  fee?: Maybe<Scalars['Float']>;
  /** Shard number of sender */
  function?: Maybe<Scalars['String']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Hash of the receiver */
  receiver?: Maybe<Address>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BigInt']>;
  /** Hash of the sender */
  sender?: Maybe<Address>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BigInt']>;
  /** Shard number of sender */
  signature?: Maybe<Scalars['String']>;
  /** Shard number of sender */
  status?: Maybe<Scalars['String']>;
};


/** Information about transaction */
export type TransactionElrond_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Blockchain transaction */
export type TransactionHash = {
  __typename?: 'TransactionHash';
  /** Hash hex representation */
  hash: Scalars['String'];
};

/** Blockchain transaction */
export type TransactionHashIndex = {
  __typename?: 'TransactionHashIndex';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
};

/** Blockchain transaction with value */
export type TransactionHashValue = {
  __typename?: 'TransactionHashValue';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction value */
  value: Scalars['Float'];
};

/** Blockchain transaction with value and time */
export type TransactionHashValueTime = {
  __typename?: 'TransactionHashValueTime';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction time */
  time: DateTime;
  /** Transaction value */
  value: Scalars['Float'];
};

/** Transaction result */
export type TransactionResult = {
  __typename?: 'TransactionResult';
  /** Result ID */
  id: Scalars['Int'];
  /** Result name */
  name: Scalars['String'];
};

/** Identification of transaction source as client application */
export type TransactionSource = {
  __typename?: 'TransactionSource';
  /** ID numeric */
  code: Scalars['Int'];
  /** Name */
  name: Scalars['String'];
};

/** Select by type of transfer */
export type TransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<FilecoinTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<FilecoinTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<FilecoinTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<FilecoinTransferType>>;
};

export type TransfersUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique receivers count */
  | 'receivers'
  /** Unique senders count */
  | 'senders'
  /** Transfers */
  | 'transfers'
  /** Unique transactions count */
  | 'txs';

/** Tron Chain */
export type Tron = {
  __typename?: 'Tron';
  /** Basic information about address ( or smart contract ) */
  address: Array<TronAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<TronArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<TronBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<TronCoinpath>>;
  /** Blockchain Embedded Contracts */
  contracts?: Maybe<Array<TronSmartContracts>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<TronDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<TronSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<TronSmartContractEvents>>;
  /** Blockchain Embedded Contracts */
  trades?: Maybe<Array<TronTrades>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<TronTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<TronTransfers>>;
};


/** Tron Chain */
export type Tron_AddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Tron Chain */
export type Tron_ArgumentsArgs = {
  any?: InputMaybe<Array<TronArgumentFilter>>;
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Tron Chain */
export type Tron_BlocksArgs = {
  any?: InputMaybe<Array<TronBlockFilter>>;
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  parentBlockHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
  witness?: InputMaybe<AddressSelector>;
};


/** Tron Chain */
export type Tron_CoinpathArgs = {
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  depth?: InputMaybe<IntegerLimitedSelector>;
  finalAddress?: InputMaybe<AddressSelectorIn>;
  initialAddress?: InputMaybe<AddressSelector>;
  initialDate?: InputMaybe<DateSelector>;
  initialTime?: InputMaybe<DateTimeSelector>;
  options?: InputMaybe<CoinpathOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Tron Chain */
export type Tron_ContractsArgs = {
  any?: InputMaybe<Array<TronContractFilter>>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};


/** Tron Chain */
export type Tron_DexTradesArgs = {
  any?: InputMaybe<Array<TronDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  options?: InputMaybe<QueryOptions>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Tron Chain */
export type Tron_SmartContractCallsArgs = {
  any?: InputMaybe<Array<TronSmartContractCallFilter>>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Tron Chain */
export type Tron_SmartContractEventsArgs = {
  any?: InputMaybe<Array<TronSmartContractEventFilter>>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Tron Chain */
export type Tron_TradesArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<TronTradeFilter>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Tron Chain */
export type Tron_TransactionsArgs = {
  any?: InputMaybe<Array<TronTransactionFilter>>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Tron Chain */
export type Tron_TransfersArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  any?: InputMaybe<Array<TronTransferFilter>>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  options?: InputMaybe<QueryOptions>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Address detailed information for Tron network */
export type TronAddressInfo = {
  __typename?: 'TronAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<TronSmartContractInfo>;
};

/** Blockchain address */
export type TronAddressInfoWithBalance = {
  __typename?: 'TronAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** Balances by currencies for the address */
  balances?: Maybe<Array<TronBalance>>;
  /** Rewards that a witness or a user has not yet withdrawn */
  claimableRewards?: Maybe<Scalars['Float']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<TronSmartContractInfo>;
};


/** Blockchain address */
export type TronAddressInfoWithBalance_BalanceArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Blockchain address */
export type TronAddressInfoWithBalance_BalancesArgs = {
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelectorRange>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Blockchain address */
export type TronAddressInfoWithBalance_ClaimableRewardsArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

export type TronArgumentFilter = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

export type TronArgumentUniq =
  /** Unique Number of block in the blockchains */
  | 'block_height'
  /** Calls */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique Owners */
  | 'owners'
  /** Unique Receivers */
  | 'receivers'
  /** Unique Transaction Hash */
  | 'signature'
  /** Unique number of arguments */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Transactions */
  | 'txs'
  /** Unique Values */
  | 'values';

/** Arguments of Smart Contract Calls and Events */
export type TronArguments = {
  __typename?: 'TronArguments';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** Owner address */
  owner?: Maybe<TronAddressInfo>;
  /** Transaction receiver */
  receiver?: Maybe<TronAddressInfo>;
  /** Address value of method or event argument */
  reference?: Maybe<TronAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<TronSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** Transaction Hash */
  txHash?: Maybe<Scalars['String']>;
  /** Transaction Index */
  txIndex?: Maybe<Scalars['Int']>;
  /** The Value of method or event argument */
  value?: Maybe<ArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_AnyArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  as?: InputMaybe<TronArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  of: TronArgumentsMeasureable;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_ArgumentArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_CountArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<TronArgumentUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_CountBigIntArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  uniq?: InputMaybe<TronArgumentUniq>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_ExpressionArgs = {
  get: Scalars['String'];
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_MaximumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  as?: InputMaybe<TronArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<TronArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: TronArgumentsMeasureable;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_MinimumArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  as?: InputMaybe<TronArgumentsConvertable>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  get?: InputMaybe<TronArgumentsMeasureable>;
  height?: InputMaybe<BlockSelector>;
  of: TronArgumentsMeasureable;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_NumberArgs = {
  argument?: InputMaybe<Array<ArgumentSelector>>;
  argumentType?: InputMaybe<ArgumentTypeSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  callDepth?: InputMaybe<StringSelector>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  owner?: InputMaybe<AddressSelector>;
  receiver?: InputMaybe<AddressSelector>;
  reference?: InputMaybe<AddressSelector>;
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<IntegerSelector>;
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_SmartContractSignatureArgs = {
  signatureType?: InputMaybe<SignatureTypeSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type TronArguments_ValueArgs = {
  value?: InputMaybe<Array<ArgumentValueSelector>>;
};

export type TronArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type TronArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Owner */
  | 'owner'
  /** Receiver */
  | 'receiver'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index';

/** Balance in a currency */
export type TronBalance = {
  __typename?: 'TronBalance';
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<TronBalanceChange>>;
  value?: Maybe<Scalars['Float']>;
};


/** Balance in a currency */
export type TronBalance_ValueArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type TronBalanceChange = {
  __typename?: 'TronBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']>;
  value?: Maybe<Scalars['Float']>;
};

export type TronBlockFilter = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  parentBlockHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  version?: InputMaybe<IntegerSelector>;
  witness?: InputMaybe<AddressSelector>;
};

/** Blocks in Tron blockchain */
export type TronBlocks = {
  __typename?: 'TronBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Parent block hash */
  parentBlockHash: Scalars['String'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** TX Trie Root Hash */
  txTrieRoot: Scalars['String'];
  /** Block version */
  version?: Maybe<Scalars['Int']>;
  /** Block witness */
  witness?: Maybe<Address>;
  /** Witness signature */
  witnessSignature: Scalars['String'];
};


/** Blocks in Tron blockchain */
export type TronBlocks_AnyArgs = {
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocks_CountArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  parentBlockHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TronBlocksUniq>;
  version?: InputMaybe<IntegerSelector>;
  witness?: InputMaybe<AddressSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_CountBigIntArgs = {
  blockHash?: InputMaybe<HashSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  parentBlockHash?: InputMaybe<Array<HashSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  uniq?: InputMaybe<TronBlocksUniq>;
  version?: InputMaybe<IntegerSelector>;
  witness?: InputMaybe<AddressSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_ExpressionArgs = {
  get: Scalars['String'];
};


/** Blocks in Tron blockchain */
export type TronBlocks_HashArgs = {
  blockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_HeightArgs = {
  height?: InputMaybe<BlockSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_MaximumArgs = {
  get?: InputMaybe<TronBlocksMeasureable>;
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocks_MinimumArgs = {
  get?: InputMaybe<TronBlocksMeasureable>;
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocks_ParentBlockHashArgs = {
  parentBlockHash?: InputMaybe<Array<HashSelector>>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_TimestampArgs = {
  time?: InputMaybe<DateTimeSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_VersionArgs = {
  version?: InputMaybe<IntegerSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocks_WitnessArgs = {
  witness?: InputMaybe<AddressSelector>;
};

export type TronBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Block Version */
  | 'version'
  /** Block Witness address */
  | 'witness';

export type TronBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique witness count */
  | 'witnesses';

export type TronCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Action To */
  | 'tx_to';

/** Coinpath */
export type TronCoinpath = {
  __typename?: 'TronCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<TronCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<TronCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValueTime>;
};


/** Coinpath */
export type TronCoinpath_AmountArgs = {
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type TronCoinpath_AnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TronCoinpath_MaximumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TronCoinpath_MinimumArgs = {
  get?: InputMaybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type TronCoinpathAddress = {
  __typename?: 'TronCoinpathAddress';
  /** Address */
  address?: Maybe<Scalars['String']>;
  amountIn?: Maybe<Scalars['DecimalNumber']>;
  amountOut?: Maybe<Scalars['DecimalNumber']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['DecimalNumber']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<DateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<DateTime>;
  receiversCount?: Maybe<Scalars['Int']>;
  sendersCount?: Maybe<Scalars['Int']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<TronSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']>;
};

export type TronContractFilter = {
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};

/** Select contract type(s) */
export type TronContractTypeSelector = {
  /** Contract type in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Contract type is */
  is?: InputMaybe<Scalars['String']>;
  /** Contract type not */
  not?: InputMaybe<Scalars['String']>;
  /** Contract type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

export type TronContractsMeasureable =
  /** Block */
  | 'block'
  /** Contract */
  | 'contract_type'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction owner */
  | 'tx_owner';

/**
 * Currency selector in Tron blockchain.
 * Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
 */
export type TronCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']>>;
};

/** Tron DEX attributes */
export type TronDex = {
  __typename?: 'TronDex';
  /** Address for DEX exchange identification */
  address: Address;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']>;
};

export type TronDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};

/** Trades on DEX smart contracts */
export type TronDexTrades = {
  __typename?: 'TronDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<TronAddressInfo>;
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  /** Base currency */
  baseCurrency?: Maybe<Currency>;
  /** Block in the blockchain */
  block?: Maybe<BlockExtended>;
  buyAmount?: Maybe<Scalars['Float']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<Currency>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyFee?: Maybe<Scalars['Float']>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<TronDex>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  internalTransactionsCount?: Maybe<Scalars['Int']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;
  logsCount?: Maybe<Scalars['Int']>;
  logsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Trade 'maker' side */
  maker?: Maybe<TronAddressInfo>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netFee?: Maybe<Scalars['Float']>;
  netUsage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  /** Quote currency */
  quoteCurrency?: Maybe<Currency>;
  quotePrice?: Maybe<Scalars['Float']>;
  sellAmount?: Maybe<Scalars['Float']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<Currency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<TradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<TronSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<TronAddressInfo>;
  /** Time interval */
  timeInterval?: Maybe<TimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<TronTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_AddressArgs = {
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_AnyArgs = {
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_BaseAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_BaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_BuyAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_BuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_CountArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_CountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_EnergyFeeArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_EnergyUsageTotalArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_ExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_ExpressionArgs = {
  get: Scalars['String'];
};


/** Trades on DEX smart contracts */
export type TronDexTrades_FeeArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_InternalTransactionsCountArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_InternalTransactionsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_LogsCountArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_LogsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_MakerArgs = {
  maker?: InputMaybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_MaximumArgs = {
  get?: InputMaybe<TronDexTradesMeasureable>;
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_MinimumArgs = {
  get?: InputMaybe<TronDexTradesMeasureable>;
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_NetFeeArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_NetUsageArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_PriceArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<PriceAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_ProtocolArgs = {
  protocol?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_QuoteAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_QuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_QuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  calculate?: InputMaybe<PriceAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  exchangeAddress?: InputMaybe<Array<AddressSelector>>;
  exchangeName?: InputMaybe<Array<StringSelector>>;
  height?: InputMaybe<BlockSelector>;
  maker?: InputMaybe<Array<AddressSelector>>;
  makerOrTaker?: InputMaybe<Array<AddressSelector>>;
  price?: InputMaybe<Array<AmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;
  protocol?: InputMaybe<Array<StringSelector>>;
  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<AmountSelector>>;
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
  taker?: InputMaybe<Array<AddressSelector>>;
  time?: InputMaybe<DateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;
  tradeIndex?: InputMaybe<Array<StringSelector>>;
  txHash?: InputMaybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_SellAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in?: InputMaybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_SellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_SmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_TakerArgs = {
  taker?: InputMaybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_TradeAmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  in: BaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_TradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTrades_TransactionArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};

export type TronDexTradesMeasureable =
  /** Block */
  | 'block'
  /** Buy Amount */
  | 'buy_amount'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Date */
  | 'date'
  /** Maker */
  | 'maker'
  /** Price */
  | 'price'
  /** Quote Price */
  | 'quote_price'
  /** Sell Amount */
  | 'sell_amount'
  /** Sell Token address */
  | 'sell_currency_address'
  /** Sell Currency symbol */
  | 'sell_currency_symbol'
  /** Taker */
  | 'taker'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type TronDexTradesUniq =
  /** Unique makers & takers count */
  | 'address'
  /** Base currencies count */
  | 'base_currency'
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies count */
  | 'buy_currency'
  /** Unique date count */
  | 'dates'
  /** Unique makers count */
  | 'makers'
  /** Unique protocols count */
  | 'protocols'
  /** Quote currencies count */
  | 'quote_currency'
  /** Sell currencies count */
  | 'sell_currency'
  /** Unique smart contract count */
  | 'smart_contracts'
  /** Unique makers count */
  | 'takers'
  /** Unique transactions count */
  | 'txs';

export type TronEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Action To */
  | 'tx_to';

export type TronNetwork =
  /** TRON mainnet */
  | 'tron';

/** Tron smart contract */
export type TronSmartContract = {
  __typename?: 'TronSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type TronSmartContractCallFilter = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Smart Contract Calls */
export type TronSmartContractCalls = {
  __typename?: 'TronSmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Call arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Smart contract being called */
  smartContract?: Maybe<TronSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_AmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_AnyArgs = {
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_CountArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_EnergyUsageTotalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Calls */
export type TronSmartContractCalls_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_MaximumArgs = {
  get?: InputMaybe<TronCallsMeasureable>;
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_MinimumArgs = {
  get?: InputMaybe<TronCallsMeasureable>;
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_NetUsageArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  date?: InputMaybe<DateSelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractMethod?: InputMaybe<MethodSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_SmartContractArgs = {
  smartContractAddress?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_SmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<MethodSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCalls_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

export type TronSmartContractEventFilter = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Smart Contract Events */
export type TronSmartContractEvents = {
  __typename?: 'TronSmartContractEvents';
  any?: Maybe<Scalars['String']>;
  /** Call arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being Evented */
  smartContract?: Maybe<TronSmartContract>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<Event>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_AnyArgs = {
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEvents_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_CountArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_CountBigIntArgs = {
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  smartContractAddress?: InputMaybe<AddressSelector>;
  smartContractEvent?: InputMaybe<EventSelector>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_ExpressionArgs = {
  get: Scalars['String'];
};


/** Smart Contract Events */
export type TronSmartContractEvents_MaximumArgs = {
  get?: InputMaybe<TronEventsMeasureable>;
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEvents_MinimumArgs = {
  get?: InputMaybe<TronEventsMeasureable>;
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEvents_SmartContractArgs = {
  smartContractAddress?: InputMaybe<AddressSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_SmartContractEventArgs = {
  smartContractEvent?: InputMaybe<EventSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEvents_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

/** Blockchain smart contract */
export type TronSmartContractInfo = {
  __typename?: 'TronSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<ScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

/** Contracts */
export type TronSmartContracts = {
  __typename?: 'TronSmartContracts';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Transactio owner from address */
  txOwner?: Maybe<Address>;
};


/** Contracts */
export type TronSmartContracts_AmountArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContracts_AnyArgs = {
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContracts_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Contracts */
export type TronSmartContracts_ContractTypeArgs = {
  contractType?: InputMaybe<TronContractTypeSelector>;
};


/** Contracts */
export type TronSmartContracts_CountArgs = {
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Contracts */
export type TronSmartContracts_CountBigIntArgs = {
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<SmartContractCallsUniq>;
};


/** Contracts */
export type TronSmartContracts_CurrencyArgs = {
  currency?: InputMaybe<TronCurrencySelector>;
};


/** Contracts */
export type TronSmartContracts_EnergyUsageTotalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContracts_ExpressionArgs = {
  get: Scalars['String'];
};


/** Contracts */
export type TronSmartContracts_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContracts_MaximumArgs = {
  get?: InputMaybe<TronContractsMeasureable>;
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContracts_MinimumArgs = {
  get?: InputMaybe<TronContractsMeasureable>;
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContracts_NetUsageArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txOwner?: InputMaybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContracts_SuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']>>;
};


/** Contracts */
export type TronSmartContracts_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Contracts */
export type TronSmartContracts_TxOwnerArgs = {
  txOwner?: InputMaybe<AddressSelector>;
};

export type TronTradeFilter = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};

/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades = {
  __typename?: 'TronTrades';
  amountBuy?: Maybe<Scalars['Float']>;
  amountSell?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where Trade transaction is included */
  block?: Maybe<Block>;
  /** Buy Currency of Trade */
  buyCurrency?: Maybe<Currency>;
  /** Trade buyer */
  buyer?: Maybe<Address>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** exchange_id */
  exchangeId?: Maybe<Scalars['Int']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Sell Currency of Trade */
  sellCurrency?: Maybe<Currency>;
  /** Trade seller */
  seller?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction hash where Trade happened */
  txHash?: Maybe<Scalars['String']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_AmountBuyArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_AmountSellArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_AnyArgs = {
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_BuyCurrencyArgs = {
  buyCurrency?: InputMaybe<TronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_BuyerArgs = {
  buyer?: InputMaybe<AddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_ContractTypeArgs = {
  contractType?: InputMaybe<TronContractTypeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_CountArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_CountBigIntArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  uniq?: InputMaybe<TronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_EnergyUsageTotalArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_ExchangeIdArgs = {
  exchangeId?: InputMaybe<IntIdSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_FeeArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_MaximumArgs = {
  get?: InputMaybe<TronTradesMeasureable>;
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_MinimumArgs = {
  get?: InputMaybe<TronTradesMeasureable>;
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_NetUsageArgs = {
  amountBuy?: InputMaybe<Array<AmountSelector>>;
  amountSell?: InputMaybe<Array<AmountSelector>>;
  buyCurrency?: InputMaybe<TronCurrencySelector>;
  buyer?: InputMaybe<AddressSelector>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  date?: InputMaybe<DateSelector>;
  exchangeId?: InputMaybe<IntIdSelector>;
  height?: InputMaybe<BlockSelector>;
  sellCurrency?: InputMaybe<TronCurrencySelector>;
  seller?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_SellCurrencyArgs = {
  sellCurrency?: InputMaybe<TronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_SellerArgs = {
  seller?: InputMaybe<AddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};

export type TronTradesMeasureable =
  /** Amount Sell */
  | 'amount_buy'
  /** Amount Sell */
  | 'amount_sell'
  /** Block */
  | 'block'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency name */
  | 'buy_currency_name'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Buy Token address */
  | 'buy_token_id'
  /** Buy Token type */
  | 'buy_token_type'
  /** Buyer */
  | 'buyer'
  /** Contract Type */
  | 'contract_type'
  /** Date */
  | 'date'
  /** Exchange ID */
  | 'exchange_id'
  /** Buy Token address */
  | 'sell_currency_address'
  /** Buy Currency name */
  | 'sell_currency_name'
  /** Buy Currency symbol */
  | 'sell_currency_symbol'
  /** Buy Token address */
  | 'sell_token_id'
  /** Buy Token type */
  | 'sell_token_type'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type TronTradesUniq =
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies */
  | 'buy_currencies'
  /** Buyers count */
  | 'buyers'
  /** Unique date count */
  | 'dates'
  /** Exchange IDs */
  | 'exchanges'
  /** Sell currencies */
  | 'sell_currencies'
  /** Sellers count */
  | 'sellers';

export type TronTransactionFilter = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};

/** Blockchain Transaction Extended info */
export type TronTransactionInfoExtended = {
  __typename?: 'TronTransactionInfoExtended';
  /** Contract Address */
  contractAddress?: Maybe<Address>;
  /** Expiration */
  expiration: Scalars['BigInt'];
  /** Fee Limit */
  feeLimit: Scalars['Int'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String'];
  /** Result message */
  result?: Maybe<Scalars['String']>;
  /** Signatures */
  signatures: Scalars['String'];
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};

/** Transactions in Tron blockchain */
export type TronTransactions = {
  __typename?: 'TronTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Contract Address */
  contractAddress?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyFee?: Maybe<Scalars['Float']>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Expiration */
  expiration: Scalars['Int'];
  expression?: Maybe<Scalars['DecimalNumber']>;
  fee?: Maybe<Scalars['Float']>;
  /** Fee Limit */
  feeLimit: Scalars['Int'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  internalTransactionsCount?: Maybe<Scalars['Int']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;
  logsCount?: Maybe<Scalars['Int']>;
  logsCountBigInt?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netFee?: Maybe<Scalars['Float']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String'];
  /** Result message */
  result?: Maybe<Scalars['String']>;
  /** Signatures */
  signatures: Scalars['String'];
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_AnyArgs = {
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactions_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_ContractAddressArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_CountArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  uniq?: InputMaybe<TronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_CountBigIntArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
  uniq?: InputMaybe<TronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_EnergyFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_EnergyUsageTotalArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_ExpressionArgs = {
  get: Scalars['String'];
};


/** Transactions in Tron blockchain */
export type TronTransactions_FeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_HashArgs = {
  txHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_IndexArgs = {
  txIndex?: InputMaybe<Array<TxIndexSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_InternalTransactionsCountArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_InternalTransactionsCountBigIntArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_LogsCountArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_LogsCountBigIntArgs = {
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_MaximumArgs = {
  get?: InputMaybe<TronTransactionsMeasureable>;
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactions_MinimumArgs = {
  get?: InputMaybe<TronTransactionsMeasureable>;
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactions_NetFeeArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_NetUsageArgs = {
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractAddress?: InputMaybe<AddressSelector>;
  date?: InputMaybe<DateSelector>;
  height?: InputMaybe<BlockSelector>;
  refBlockHash?: InputMaybe<Array<HashSelector>>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txHash?: InputMaybe<HashSelector>;
  txIndex?: InputMaybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_RefBlockHashArgs = {
  refBlockHash?: InputMaybe<Array<HashSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactions_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};

export type TronTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Energy Fee */
  | 'energy_fee'
  /** Fee */
  | 'fee'
  /** Fee Limit */
  | 'fee_limit'
  /** Internal transactions count */
  | 'internal_transactions_count'
  /** Net usage */
  | 'net_usage'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type TronTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type TronTransferFilter = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers = {
  __typename?: 'TronTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  expression?: Maybe<Scalars['DecimalNumber']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_AmountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_AnyArgs = {
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_BlockArgs = {
  height?: InputMaybe<BlockSelector>;
  time?: InputMaybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_ContractTypeArgs = {
  contractType?: InputMaybe<TronContractTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_CountArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_CountBigIntArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
  uniq?: InputMaybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_CurrencyArgs = {
  currency?: InputMaybe<TronCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_EnergyUsageTotalArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_EntityIdArgs = {
  entityId?: InputMaybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_ExpressionArgs = {
  get: Scalars['String'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_ExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_FeeArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  in?: InputMaybe<BaseCurrencyEnum>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_MaximumArgs = {
  get?: InputMaybe<TronTransfersMeasureable>;
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_MinimumArgs = {
  get?: InputMaybe<TronTransfersMeasureable>;
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_NetUsageArgs = {
  amount?: InputMaybe<Array<AmountSelector>>;
  amountInUSD?: InputMaybe<Array<AmountSelector>>;
  calculate?: InputMaybe<AmountAggregateFunction>;
  contractType?: InputMaybe<TronContractTypeSelector>;
  currency?: InputMaybe<TronCurrencySelector>;
  date?: InputMaybe<DateSelector>;
  entityId?: InputMaybe<EntitySelector>;
  external?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<BlockSelector>;
  receiver?: InputMaybe<AddressSelector>;
  sender?: InputMaybe<AddressSelector>;
  success?: InputMaybe<Scalars['Boolean']>;
  time?: InputMaybe<DateTimeSelector>;
  txFrom?: InputMaybe<AddressSelector>;
  txHash?: InputMaybe<HashSelector>;
  txTo?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_ReceiverArgs = {
  receiver?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_SenderArgs = {
  sender?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_SuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_TxFromArgs = {
  txFrom?: InputMaybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_TxHashArgs = {
  txHash?: InputMaybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers_TxToArgs = {
  txTo?: InputMaybe<AddressSelector>;
};

export type TronTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** Transaction hash */
  | 'tx_hash';

/** Selector of index of transaction in block */
export type TxIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** Select transactions by subtype */
export type TxSubtypeSelector = {
  /** Transaction SubType in the list */
  in?: InputMaybe<Array<AlgorandTxSubType>>;
  /** Transaction SubType is */
  is?: InputMaybe<AlgorandTxSubType>;
  /** Transaction SubType not */
  not?: InputMaybe<AlgorandTxSubType>;
  /** Transaction SubType not in the list */
  notIn?: InputMaybe<Array<AlgorandTxSubType>>;
};

/** Select transactions by type */
export type TxTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<AlgorandTxType>>;
  /** Transaction Type is */
  is?: InputMaybe<AlgorandTxType>;
  /** Transaction Type not */
  not?: InputMaybe<AlgorandTxType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<AlgorandTxType>>;
};

/** Utilities */
export type Utilities = {
  __typename?: 'Utilities';
  /** Active period */
  activePeriod?: Maybe<ActivePeriod>;
  /** Query metrics */
  metrics?: Maybe<Metrics>;
};


/** Utilities */
export type Utilities_ActivePeriodArgs = {
  apiKey: Scalars['String'];
  options?: InputMaybe<SeedOptions>;
};


/** Utilities */
export type Utilities_MetricsArgs = {
  options?: InputMaybe<SeedOptions>;
  queryId: Scalars['String'];
};

/** UtilitiesDate */
export type UtilitiesDate = {
  __typename?: 'UtilitiesDate';
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int'];
  /** Month number (1-12) */
  month: Scalars['Int'];
  /** Year number */
  year: Scalars['Int'];
};

export type GetSmartContractCallsByAddressQueryVariables = Exact<{
  network: EthereumNetwork;
  address?: InputMaybe<Scalars['String']>;
  contracts?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
  from?: InputMaybe<Scalars['ISO8601DateTime']>;
}>;


export type GetSmartContractCallsByAddressQuery = { __typename?: 'Query', ethereum?: { __typename?: 'Ethereum', smartContractCalls?: Array<{ __typename?: 'EthereumSmartContractCalls', count?: number | null, smartContract?: { __typename?: 'EthereumSmartContract', address: { __typename?: 'Address', address?: string | null } } | null }> | null } | null };

export type GetTokenHoldingsByAddressQueryVariables = Exact<{
  network: EthereumNetwork;
  tokens?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
  receiver: Scalars['String'];
  from?: InputMaybe<Scalars['ISO8601DateTime']>;
  till?: InputMaybe<Scalars['ISO8601DateTime']>;
}>;


export type GetTokenHoldingsByAddressQuery = { __typename?: 'Query', ethereum?: { __typename?: 'Ethereum', transfers?: Array<{ __typename?: 'EthereumTransfers', amount?: number | null, external?: boolean | null, block?: { __typename?: 'Block', height: number, timestamp?: { __typename?: 'DateTime', time: string } | null } | null, sender?: { __typename?: 'EthereumAddressInfo', address?: string | null } | null, receiver?: { __typename?: 'EthereumAddressInfo', address?: string | null } | null, transaction?: { __typename?: 'EthereumTransactionInfo', hash: string } | null, currency?: { __typename?: 'Currency', symbol: string, tokenId?: string | null, name?: string | null, tokenType?: string | null, address?: string | null } | null }> | null } | null };


export const GetSmartContractCallsByAddressDocument = gql`
    query GetSmartContractCallsByAddress($network: EthereumNetwork!, $address: String, $contracts: [String!], $from: ISO8601DateTime) {
  ethereum(network: $network) {
    smartContractCalls(
      caller: {is: $address}
      smartContractAddress: {in: $contracts}
      date: {since: $from}
    ) {
      count
      smartContract {
        address {
          address
        }
      }
    }
  }
}
    `;
export const GetTokenHoldingsByAddressDocument = gql`
    query GetTokenHoldingsByAddress($network: EthereumNetwork!, $tokens: [String!], $receiver: String!, $from: ISO8601DateTime, $till: ISO8601DateTime) {
  ethereum(network: $network) {
    transfers(
      options: {desc: "block.timestamp.time", limit: 10000, offset: 0}
      date: {since: $from, till: $till}
      amount: {gt: 0}
      currency: {in: $tokens}
      receiver: {is: $receiver}
    ) {
      block {
        timestamp {
          time(format: "%Y-%m-%d %H:%M:%S")
        }
        height
      }
      sender {
        address
      }
      receiver {
        address
      }
      transaction {
        hash
      }
      amount
      currency {
        symbol
        tokenId
        name
        tokenType
        address
      }
      external
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    GetSmartContractCallsByAddress(variables: GetSmartContractCallsByAddressQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetSmartContractCallsByAddressQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetSmartContractCallsByAddressQuery>(GetSmartContractCallsByAddressDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetSmartContractCallsByAddress', 'query');
    },
    GetTokenHoldingsByAddress(variables: GetTokenHoldingsByAddressQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTokenHoldingsByAddressQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTokenHoldingsByAddressQuery>(GetTokenHoldingsByAddressDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetTokenHoldingsByAddress', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;